diff --git a/node_modules/@editablejs/editor/dist/index.d.ts b/node_modules/@editablejs/editor/dist/index.d.ts
index b6cc44e..355046c 100644
--- a/node_modules/@editablejs/editor/dist/index.d.ts
+++ b/node_modules/@editablejs/editor/dist/index.d.ts
@@ -418,6 +418,7 @@ type EditableProps = {
     role?: string;
     style?: React$1.CSSProperties;
     as?: React$1.ElementType;
+    className?: string;
     selectionDrawingStyle?: SelectionDrawingStyle;
 };
 /**
diff --git a/node_modules/@editablejs/editor/dist/index.js.map b/node_modules/@editablejs/editor/dist/index.js.map
index be1d517..8331b26 100644
--- a/node_modules/@editablejs/editor/dist/index.js.map
+++ b/node_modules/@editablejs/editor/dist/index.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../src/index.ts","../src/utils/constants.ts","../src/utils/data-transfer.ts","../src/hooks/use-locale.ts","../src/plugin/locale.ts","../src/hooks/use-editable.tsx","../src/components/content.tsx","../src/hooks/use-children.tsx","../src/components/element.tsx","../src/components/text.tsx","../src/components/leaf.tsx","../src/components/string.tsx","../src/plugin/editable.ts","../src/utils/weak-maps.ts","../src/utils/dom.ts","../src/utils/environment.ts","../src/utils/nearby.ts","../src/utils/text.ts","../src/utils/selection.ts","../src/hooks/use-focused.ts","../src/utils/event.ts","../src/hooks/use-read-only.ts","../src/hooks/use-isomorphic-layout-effect.ts","../src/hooks/use-decorate.ts","../src/plugin/decorate.ts","../src/hooks/use-placeholder.ts","../src/plugin/placeholder.ts","../src/hooks/use-node-selected.ts","../src/hooks/use-node-focused.ts","../src/hooks/use-grid.ts","../src/hooks/use-multiple-click.ts","../src/hooks/use-cancellable-promises.ts","../src/components/shadow.tsx","../src/components/caret.tsx","../src/hooks/use-selection-drawing.ts","../src/plugin/selection-drawing.ts","../src/components/selection.tsx","../src/components/input.tsx","../src/hooks/use-drag.ts","../src/plugin/drag.ts","../src/components/drag-caret.tsx","../src/components/slot.tsx","../src/hooks/use-slot.ts","../src/plugin/solt.ts","../src/components/touch-point.tsx","../src/components/editable.tsx","../src/hooks/use-grid-selection.ts","../src/hooks/use-grid-selection-rect.ts","../src/hooks/use-grid-selected.ts","../src/plugin/with-editable.tsx","../src/utils/lines.ts","../src/plugin/emitter.ts","../src/plugin/event.ts","../src/plugin/with-input.ts","../src/plugin/with-keydown.ts","../src/utils/hotkeys.ts","../src/plugin/with-normalize-node.ts","../src/plugin/with-data-transfer.ts","../src/utils/clipboard.ts"],"sourcesContent":["// Constants\nexport * from './utils/constants'\n\n// FormatData\nexport * as FormatData from './utils/data-transfer'\n\n// Locale\nexport * from './hooks/use-locale'\n\n// Component\nexport { ContentEditable } from './components/content'\nexport { EditableProvider } from './components/editable'\n\n// Hooks\nexport { useIsomorphicLayoutEffect } from './hooks/use-isomorphic-layout-effect'\nexport { useEditableStatic, useEditable, useEditableStore } from './hooks/use-editable'\nexport { useFocused } from './hooks/use-focused'\nexport { useReadOnly } from './hooks/use-read-only'\nexport { useNodeSelected } from './hooks/use-node-selected'\nexport { useNodeFocused } from './hooks/use-node-focused'\nexport * from './hooks/use-drag'\nexport * from './hooks/use-selection-drawing'\nexport * from './hooks/use-slot'\n\n// Grid Hooks\nexport { useGrid } from './hooks/use-grid'\nexport { useGridSelection } from './hooks/use-grid-selection'\nexport { useGridSelectionRect } from './hooks/use-grid-selection-rect'\nexport { useGridSelected } from './hooks/use-grid-selected'\n\n// Plugin\nexport { Editable } from './plugin/editable'\nexport { withEditable } from './plugin/with-editable'\nexport * from './plugin/event'\nexport * from './plugin/drag'\nexport * from './plugin/solt'\nexport * from './plugin/locale'\nexport * from './plugin/decorate'\nexport * from './plugin/placeholder'\nexport * from './plugin/selection-drawing'\n\n// Environment\nexport * from './utils/environment'\n// Dom\nexport * from './utils/dom'\n// DataTransfer\nexport * from './utils/data-transfer'\n// Clipboard\nexport * from './utils/clipboard'\n\nexport type {\n  RenderElementProps,\n  RenderLeafProps,\n  RenderElementAttributes,\n  RenderLeafAttributes,\n  ElementAttributes,\n  NodeAttributes,\n  TextAttributes,\n  PlaceholderAttributes,\n} from './plugin/editable'\n\nexport { useCancellablePromises, cancellablePromise } from './hooks/use-cancellable-promises'\n\nexport { Hotkey } from './utils/hotkeys'\n","export const APPLICATION_FRAGMENT_TYPE = 'application/x-editable-fragment'\nexport const TEXT_HTML = 'text/html'\nexport const TEXT_PLAIN = 'text/plain'\nexport const DATA_EDITABLE_FRAGMENT = `data-ea-fragment`\nexport const DATA_EDITABLE_NODE = `data-ea-node`\nexport const DATA_EDITABLE_INLINE = `data-ea-inline`\nexport const DATA_EDITABLE_STRING = `data-ea-string`\nexport const DATA_EDITABLE_COMPOSITION = `data-ea-composition`\nexport const DATA_EDITABLE_ZERO_WIDTH = `data-ea-zero-width`\nexport const DATA_EDITABLE_LENGTH = `data-ea-length`\nexport const DATA_EDITABLE_VOID = `data-ea-void`\nexport const DATA_EDITABLE_PLACEHOLDER = `data-ea-placeholder`\nexport const DATA_EDITABLE_LEAF = `data-ea-leaf`\n\nexport const Constants = {\n  applicationType: APPLICATION_FRAGMENT_TYPE,\n  htmlType: TEXT_HTML,\n  plainType: TEXT_PLAIN,\n  dataFragment: DATA_EDITABLE_FRAGMENT,\n  dataNode: DATA_EDITABLE_NODE,\n  dataInline: DATA_EDITABLE_INLINE,\n  dataString: DATA_EDITABLE_STRING,\n  dataComposition: DATA_EDITABLE_COMPOSITION,\n  dataZeroWidth: DATA_EDITABLE_ZERO_WIDTH,\n  dataLength: DATA_EDITABLE_LENGTH,\n  dataVoid: DATA_EDITABLE_VOID,\n  dataPlaceholder: DATA_EDITABLE_PLACEHOLDER,\n  dataLeaf: DATA_EDITABLE_LEAF,\n}\n","import { Descendant } from '@editablejs/models'\nimport {\n  APPLICATION_FRAGMENT_TYPE,\n  DATA_EDITABLE_FRAGMENT,\n  TEXT_HTML,\n  TEXT_PLAIN,\n} from './constants'\n\ninterface DataTransferFormatData {\n  html: string\n  text: string\n  fragment: Descendant[]\n  files: File[]\n}\n\n/**\n * Convert fragment to string\n * @param fragment\n * @returns string representation of the fragment\n **/\nexport const fragmentToString = (fragment: Descendant[]) => {\n  const string = JSON.stringify(fragment)\n  return window.btoa(encodeURIComponent(string))\n}\n\n/**\n * Parse fragment from string\n * @param fragment string representation of the fragment\n * @returns fragment\n **/\nexport const parseFragmentFromString = (fragment: string): Descendant[] => {\n  const string = decodeURIComponent(window.atob(fragment))\n  try {\n    return JSON.parse(string)\n  } catch (error) {\n    return []\n  }\n}\n\n/**\n * Match fragment string from HTML\n * @param html\n * @returns string representation of the fragment\n **/\nexport const matchFragmentStringFromHTML = (html: string) => {\n  const reg = new RegExp(`${DATA_EDITABLE_FRAGMENT}=\"(.+?)\"`)\n  return html.match(reg)?.[1] ?? ''\n}\n\n/**\n * Parse files from DataTransfer object\n * @param dataTransfer\n * @returns array of files\n **/\nexport const parseDataTransferFiles = (dataTransfer: DataTransfer) => {\n  let files: File[] = []\n\n  try {\n    if (dataTransfer.items && dataTransfer.items.length > 0) {\n      for (const item of dataTransfer.items) {\n        let file = item.kind === 'file' ? item.getAsFile() : null\n        if (file !== null) {\n          if (file.type && file.type.indexOf('image/png') > -1 && !file.lastModified) {\n            file = new File([file], 'image.png', {\n              type: file.type,\n            })\n          }\n        }\n        if (file) files.push(file)\n      }\n    } else if (dataTransfer.files && dataTransfer.files.length > 0) {\n      files = Array.from(dataTransfer.files)\n    }\n  } catch (err) {\n    if (dataTransfer.files && dataTransfer.files.length > 0) {\n      files = Array.from(dataTransfer.files)\n    }\n  }\n  return files\n}\n\n/**\n * Parse Data from DataTransfer\n * @param dataTransfer\n * @returns DataTransferFormatData\n **/\nexport const parseDataTransfer = (dataTransfer: DataTransfer): DataTransferFormatData => {\n  const text = dataTransfer.getData(TEXT_PLAIN)\n  const html = dataTransfer.getData(TEXT_HTML)\n  let fragment = dataTransfer.getData(APPLICATION_FRAGMENT_TYPE)\n  if (!fragment) fragment = matchFragmentStringFromHTML(html)\n  return {\n    text,\n    html,\n    fragment: fragment ? parseFragmentFromString(fragment) : [],\n    files: parseDataTransferFiles(dataTransfer),\n  }\n}\n\n/**\n * Set Data to DataTransfer\n * @param dataTransfer\n * @param data\n **/\nexport const setDataTransfer = (\n  dataTransfer: DataTransfer,\n  data: Partial<DataTransferFormatData>,\n) => {\n  const { text, html, fragment, files } = data\n  if (text) dataTransfer.setData(TEXT_PLAIN, text)\n  if (html) dataTransfer.setData(TEXT_HTML, html)\n  if (fragment) dataTransfer.setData(APPLICATION_FRAGMENT_TYPE, fragmentToString(fragment))\n  if (files) {\n    for (const file of files) {\n      dataTransfer.items.add(file)\n    }\n  }\n}\n","import * as React from 'react'\nimport { useStore } from 'zustand'\nimport { Editable } from '../plugin/editable'\nimport { Locale, LocaleComponentName } from '../plugin/locale'\nimport { useEditableStatic } from './use-editable'\n\nexport const useLocaleStore = (editor: Editable) => {\n  return React.useMemo(() => {\n    return Locale.getStore(editor)\n  }, [editor])\n}\n\nexport const useLang = (editor: Editable): string => {\n  const store = useLocaleStore(editor)\n  return useStore(store, state => state.lang)\n}\n\nexport const useLocale = <\n  L extends Locale,\n  T extends LocaleComponentName<L> = LocaleComponentName<L>,\n>(\n  componentName: T,\n  defaultLocale?: L[T] | (() => L[T]),\n): L[T] => {\n  const editor = useEditableStatic()\n  const lang = useLang(editor)\n  const localeContext = useLocales<L>(editor, lang)\n  const componentLocaleContext = localeContext[componentName]\n\n  const componentLocale = React.useMemo(() => {\n    const locale = componentLocaleContext || defaultLocale\n    return {\n      ...(locale instanceof Function ? locale() : locale),\n    } as L[T]\n  }, [defaultLocale, componentLocaleContext])\n\n  return componentLocale\n}\n\nexport const useLocales = <T extends Locale>(editor: Editable, lang: string): T => {\n  const store = useLocaleStore(editor)\n\n  const locales = useStore(store, state => state.locales[lang] ?? state.locales['en-US'])\n  return locales as T\n}\n\nexport const useLocaleFormat = <\n  L extends Locale,\n  T extends LocaleComponentName<L> = LocaleComponentName<L>,\n>(\n  componentName: T,\n) => {\n  const locale = useLocale<L>(componentName)\n  return {\n    format: (key: keyof typeof locale, options?: Record<string, string | number>) => {\n      const value = locale[key]\n      if (typeof value === 'string') {\n        if (!options) return value\n        return value.replace(/{(\\w+)}/g, (match, key) => String(options[key]) || match)\n      }\n      return ''\n    },\n  }\n}\n","import merge from 'lodash.merge'\nimport create, { StoreApi, UseBoundStore } from 'zustand'\nimport { Editor } from '@editablejs/models'\nexport interface Locale {\n  locale: string\n}\n\nexport interface LocaleState {\n  lang: string\n  locales: Record<string, Locale>\n}\n\nconst EDITOR_TO_LOCALE_STORE: WeakMap<Editor, UseBoundStore<StoreApi<LocaleState>>> = new WeakMap()\n\nconst getStore = (editor: Editor) => {\n  let store = EDITOR_TO_LOCALE_STORE.get(editor)\n  if (!store) {\n    store = create<LocaleState>(() => ({\n      lang: 'en-US',\n      locales: {},\n    }))\n    EDITOR_TO_LOCALE_STORE.set(editor, store)\n  }\n  return store\n}\n\nexport const Locale = {\n  getStore,\n\n  setLocale: <T extends Locale>(editor: Editor, ...locales: Record<string, T>[]) => {\n    const store = getStore(editor)\n    store.setState(state => {\n      const { lang, locales: prevLocales } = state\n      const newLocales = Object.assign({}, prevLocales)\n      for (const locale of locales) {\n        for (const key in locale) {\n          newLocales[key] = merge(newLocales[key], locale[key])\n        }\n      }\n      return {\n        lang,\n        locales: newLocales,\n      }\n    })\n  },\n\n  getLang: (editor: Editor) => {\n    const state = getStore(editor).getState()\n    return state.lang\n  },\n\n  setLang: (editor: Editor, lang: string) => {\n    const store = getStore(editor)\n    store.setState(state => {\n      return {\n        lang,\n        locales: state.locales,\n      }\n    })\n  },\n\n  getLocale: <T extends Locale>(editor: Editor): T => {\n    const lang = Locale.getLang(editor)\n    const locales = Locale.getLocales(editor)\n    return (locales[lang] ?? locales['en-US']) as any\n  },\n\n  getLocales: (editor: Editor): Record<string, Locale> => {\n    const state = getStore(editor).getState()\n    return state.locales\n  },\n}\n\nexport type LocaleComponentName<T extends Locale> = Exclude<keyof T, 'locale'>\n","import * as React from 'react'\nimport { StoreApi, UseBoundStore, useStore } from 'zustand'\nimport { Editable } from '../plugin/editable'\n\nexport interface EditableStore {\n  editor: [Editable]\n}\n\nexport const useEditableStore = () => {\n  const contenxt = React.useContext(EditableStoreContext)\n  if (!contenxt) {\n    throw new Error(\n      `The \\`useEditableStore\\` hook must be used inside the <EditableProvider> component's context.`,\n    )\n  }\n\n  return contenxt.store\n}\n\nexport interface EditableStoreContext {\n  store: UseBoundStore<StoreApi<EditableStore>>\n  editor: Editable\n}\n\nexport const EditableStoreContext = React.createContext<EditableStoreContext | null>(null)\n\n/**\n * 静态的编辑器对象\n * @returns\n */\nexport const useEditableStatic = (): Editable => {\n  const contenxt = React.useContext(EditableStoreContext)\n\n  if (!contenxt) {\n    throw new Error(\n      `The \\`useEditableStatic\\` hook must be used inside the <EditableProvider> component's context.`,\n    )\n  }\n\n  return contenxt.editor\n}\n\n/**\n * 实时变化的编辑器对象\n * @returns\n */\nexport const useEditable = (): Editable => {\n  const store = useEditableStore()\n\n  return useStore(store, state => {\n    return state.editor\n  })[0]\n}\n","import * as React from 'react'\nimport {\n  Editor,\n  Range,\n  Transforms,\n  Point,\n  Path,\n  Element,\n  DOMNode,\n  getDefaultView,\n  isDOMNode,\n} from '@editablejs/models'\n\nimport useChildren from '../hooks/use-children'\nimport { useEditable, useEditableStatic } from '../hooks/use-editable'\nimport { Editable } from '../plugin/editable'\nimport { useReadOnly } from '../hooks/use-read-only'\nimport { useIsomorphicLayoutEffect } from '../hooks/use-isomorphic-layout-effect'\nimport { inAbsoluteDOMElement } from '../utils/dom'\nimport {\n  EDITOR_TO_ELEMENT,\n  ELEMENT_TO_NODE,\n  NODE_TO_ELEMENT,\n  EDITOR_TO_WINDOW,\n  IS_SHIFT_PRESSED,\n  EDITOR_TO_SHADOW,\n  IS_MOUSEDOWN,\n  IS_TOUCHMOVING,\n  IS_TOUCHING,\n  IS_TOUCH_HOLD,\n} from '../utils/weak-maps'\nimport { useMultipleClick } from '../hooks/use-multiple-click'\nimport { Focused, useFocused } from '../hooks/use-focused'\nimport ShadowContainer from './shadow'\nimport { CaretComponent } from './caret'\nimport { SelectionComponent } from './selection'\nimport { InputComponent } from './input'\nimport { useDragging, useDragMethods, useDragTo } from '../hooks/use-drag'\nimport { SelectionDrawing, SelectionDrawingStyle } from '../plugin/selection-drawing'\nimport { APPLICATION_FRAGMENT_TYPE, DATA_EDITABLE_NODE } from '../utils/constants'\nimport { DragCaretComponent } from './drag-caret'\nimport { parseFragmentFromString, setDataTransfer } from '../utils/data-transfer'\nimport { Slots } from './slot'\nimport { Drag } from '../plugin/drag'\nimport { Placeholder } from '../plugin/placeholder'\nimport { usePlaceholder } from '../hooks/use-placeholder'\nimport { isTouchDevice } from '../utils/environment'\nimport { TouchPointComponent } from './touch-point'\nimport { getNativeEvent, isMouseEvent, isTouchEvent } from '../utils/event'\nimport { canForceTakeFocus, isEditableDOMElement } from '../utils/dom'\nimport { Locale } from '../plugin/locale'\n\nconst Children = (props: Omit<Parameters<typeof useChildren>[0], 'node' | 'selection'>) => {\n  const editor = useEditable()\n  return (\n    <React.Fragment>\n      {useChildren({ ...props, node: editor, selection: editor.selection })}\n    </React.Fragment>\n  )\n}\n\n/**\n * `EditableProps` are passed to the `<Editable>` component.\n */\nexport type EditableProps = {\n  readOnly?: boolean\n  lang?: string\n  autoFocus?: boolean\n  placeholder?: React.ReactNode\n  role?: string\n  style?: React.CSSProperties\n  as?: React.ElementType\n  selectionDrawingStyle?: SelectionDrawingStyle\n}\n\n/**\n * ContentEditable.\n */\nexport const ContentEditable = (props: EditableProps) => {\n  const {\n    autoFocus = true,\n    placeholder,\n    readOnly: readOnlyProp = false,\n    lang,\n    style = {},\n    as: Component = 'div',\n    selectionDrawingStyle: selectionDrawingStyleProp,\n    ...attributes\n  } = props\n  const editor = useEditableStatic()\n\n  const ref = React.useRef<HTMLDivElement>(null)\n  const [readOnly, setReadOnly] = useReadOnly()\n  // 标记是否是刚拖拽完毕\n  const isDragEnded = React.useRef(false)\n  const dragTo = useDragTo()\n  const dragging = useDragging()\n  const { getDrag, setDrag } = useDragMethods()\n\n  const [rendered, setRendered] = React.useState(false)\n\n  // Touch hold timer\n  const touchHoldTimer = React.useRef<number | null>(null)\n\n  React.useEffect(() => {\n    if (placeholder && !readOnly) {\n      const unsubscribe = Placeholder.subscribe(\n        editor,\n        ([node]) => {\n          if (Editable.isEditor(node) && !node.children.some(n => Editor.isList(editor, n)))\n            return () => placeholder\n        },\n        true,\n      )\n\n      return () => {\n        unsubscribe()\n      }\n    }\n  }, [editor, placeholder, readOnly])\n\n  useIsomorphicLayoutEffect(() => {\n    setReadOnly(readOnlyProp)\n  }, [readOnlyProp])\n\n  useIsomorphicLayoutEffect(() => {\n    Locale.setLang(editor, props.lang || 'en-US')\n  }, [editor, lang])\n\n  useIsomorphicLayoutEffect(() => {\n    if (selectionDrawingStyleProp) SelectionDrawing.setStyle(editor, selectionDrawingStyleProp)\n  }, [editor, selectionDrawingStyleProp])\n\n  const [focused, setFocused] = useFocused()\n\n  const startPointRef = React.useRef<Point | null>(null)\n  const isContextMenu = React.useRef(false)\n\n  const clearTouchHoldTimer = () => {\n    if (touchHoldTimer.current) clearTimeout(touchHoldTimer.current)\n  }\n\n  const handleDocumentMouseDown = (event: MouseEvent | TouchEvent) => {\n    const isMouseDown = IS_MOUSEDOWN.get(editor)\n    const isTouching = IS_TOUCHING.get(editor)\n    if (!isMouseDown && !isTouching && !event.defaultPrevented) setFocused(false)\n  }\n\n  const handleSelecting = (point: Point | null, rest = true, forceFocus = true) => {\n    if (!point) return\n    const { selection } = editor\n    if (!rest && selection && Range.includes(selection, point)) {\n      return\n    }\n    let anchor: Point | null = null\n\n    if (IS_TOUCHING.get(editor)) {\n      anchor = point\n    } else {\n      anchor = IS_SHIFT_PRESSED.get(editor) && selection ? selection.anchor : startPointRef.current\n    }\n    if (!anchor) return\n    const range: Range = { anchor, focus: point }\n    if (selection && forceFocus && Range.equals(range, selection)) {\n      editor.focus()\n      setFocused(true)\n      return true\n    }\n    Transforms.select(editor, range)\n    return range\n  }\n\n  const handleDocumentTouchEnd = (event: TouchEvent) => {\n    if (event.defaultPrevented) return\n    clearTouchHoldTimer()\n    // touch move 之后不会触发 mouse up 事件，所以需要在 touch end 时触发\n    if (IS_TOUCHMOVING.get(editor)) {\n      handleDocumentMouseUp(event)\n      IS_TOUCHING.set(editor, false)\n    } else if (IS_TOUCH_HOLD.get(editor)) {\n      IS_TOUCHING.set(editor, false)\n      IS_MOUSEDOWN.set(editor, false)\n      IS_TOUCH_HOLD.set(editor, false)\n      event.preventDefault()\n      editor.onTouchHold(event)\n    }\n  }\n\n  const handleDocumentMouseUp = (event: MouseEvent | TouchEvent) => {\n    const drag = getDrag()\n    const isMouseDown = IS_MOUSEDOWN.get(editor)\n    if (\n      drag ||\n      (IS_TOUCHING.get(editor) && !IS_TOUCH_HOLD.get(editor)) ||\n      (isMouseDown &&\n        (!event.defaultPrevented || (event instanceof MouseEvent && event.button === 2)))\n    ) {\n      if (focused && !isEditableDOMElement(event.target) && canForceTakeFocus()) {\n        editor.focus()\n      }\n      const point = Editable.findEventPoint(editor, event)\n      let isSelectedSame = false\n      if (point && drag) {\n        const { from, data, type = 'text' } = drag\n        const fromRange = Editor.range(editor, from)\n        if (!Range.includes(fromRange, point)) {\n          const fragment = parseFragmentFromString(data.getData(APPLICATION_FRAGMENT_TYPE))\n          if (type === 'block') {\n            const path = Drag.toBlockPath(editor)\n            if (path && fragment.length > 0) {\n              const rangeRef = Editor.rangeRef(editor, {\n                anchor: {\n                  path,\n                  offset: 0,\n                },\n                focus: {\n                  path,\n                  offset: 0,\n                },\n              })\n              Transforms.removeNodes(editor, { at: from })\n              const at = rangeRef.unref()\n              Transforms.insertNodes(editor, fragment, {\n                at: at?.anchor.path ?? path,\n                select: true,\n              })\n            }\n          } else {\n            const deleteAfterRange = Editor.rangeRef(editor, Editor.range(editor, point))\n            Transforms.delete(editor, {\n              at: from,\n              unit: 'line',\n              hanging: true,\n            })\n            const anchorRange = deleteAfterRange.unref()\n            Transforms.select(editor, anchorRange ?? point)\n            Transforms.insertFragment(editor, fragment)\n            const focus = editor.selection?.focus\n            if (anchorRange && focus) {\n              let anchor = anchorRange.anchor\n              const anchorElement = Editor.above(editor, {\n                at: anchorRange,\n                match: node => Element.isElement(node),\n                voids: true,\n              })\n\n              const nextPath = Path.next(anchor.path)\n\n              if (anchorElement && Editor.hasPath(editor, nextPath)) {\n                const nextRange = Editor.range(editor, nextPath)\n                const element = Editor.above(editor, {\n                  at: nextRange,\n                  match: node => Element.isElement(node),\n                  voids: true,\n                })\n                if (element && anchorElement[0] !== element[0]) {\n                  anchor = nextRange.anchor\n                }\n              }\n              Transforms.select(editor, {\n                anchor,\n                focus,\n              })\n            }\n          }\n\n          isDragEnded.current = true\n        } else {\n          Transforms.select(editor, point)\n        }\n      } else {\n        const { selection } = editor\n        if (\n          IS_TOUCHING.get(editor) &&\n          point &&\n          selection &&\n          isSelectedOnCurrentSelection(editor, selection, point)\n        ) {\n          isSelectedSame = true\n        } else {\n          // 是否选中在同一个位置\n          isSelectedSame =\n            handleSelecting(point, !isContextMenu.current, !isEditableDOMElement(event.target)) ===\n            true\n        }\n      }\n      // 修复 touch 时，触发了 mouse up 事件，导致无法触发 onSelectStart\n      if (IS_TOUCHING.get(editor) && !IS_TOUCH_HOLD.get(editor)) {\n        // touch 在同一个位置，触发 onTouchTrack\n        if (isSelectedSame) editor.onTouchTrack()\n        else editor.onSelectStart()\n      }\n      setDrag(null)\n      if (!isDragEnded.current && (!IS_TOUCHING.get(editor) || !isSelectedSame))\n        editor.onSelectEnd()\n    }\n\n    isContextMenu.current = false\n    startPointRef.current = null\n    IS_TOUCHMOVING.set(editor, false)\n    IS_TOUCHING.set(editor, false)\n    IS_MOUSEDOWN.set(editor, false)\n  }\n\n  const handleDocumentMouseMove = (event: MouseEvent | TouchEvent) => {\n    const darg = getDrag()\n    const isMouseDown = IS_MOUSEDOWN.get(editor)\n    // 未长按不触发 move 事件\n    if (IS_TOUCHING.get(editor) && !IS_TOUCH_HOLD.get(editor)) {\n      clearTouchHoldTimer()\n      return\n    }\n    const isTouchMoving = isTouchEvent(event)\n    IS_TOUCHMOVING.set(editor, isTouchMoving)\n\n    if (\n      !isTouchMoving &&\n      !darg &&\n      ((isMouseEvent(event) && event.button !== 0) ||\n        !isMouseDown ||\n        event.defaultPrevented ||\n        isContextMenu.current)\n    )\n      return\n    const point = event.defaultPrevented ? null : Editable.findEventPoint(editor, event)\n    if (point && dragging && isMouseEvent(event)) {\n      setDrag({\n        to: {\n          anchor: point,\n          focus: point,\n        },\n        position: {\n          x: event.clientX,\n          y: event.clientY,\n        },\n      })\n      return\n    }\n    // 阻止 touchmove 时页面滚动\n    if (isTouchMoving) event.preventDefault()\n    const range = handleSelecting(point)\n    if (range) editor.onSelecting()\n  }\n\n  const handleRootTouchStart = (event: React.TouchEvent) => {\n    if (event.defaultPrevented) return\n    if (\n      !event.target ||\n      !ref.current?.contains(event.target as DOMNode) ||\n      isEditableDOMElement(event.target) ||\n      inAbsoluteDOMElement(event.target)\n    )\n      return\n\n    const { selection } = editor\n\n    IS_TOUCHING.set(editor, true)\n    IS_TOUCH_HOLD.set(editor, false)\n    clearTouchHoldTimer()\n    // touch hold\n    touchHoldTimer.current = setTimeout(() => {\n      IS_TOUCH_HOLD.set(editor, true)\n\n      if (Focused.is(editor)) {\n        handleRootMouseDown(event)\n      } else if (!selection || Range.isCollapsed(selection)) {\n        IS_TOUCHING.set(editor, false)\n        const point = Editable.findEventPoint(editor, event)\n        if (point)\n          editor.selectWord({\n            at: {\n              anchor: point,\n              focus: point,\n            },\n          })\n      }\n    }, 530)\n  }\n\n  const handleRootMouseDown = (e: React.MouseEvent | React.TouchEvent) => {\n    const event = getNativeEvent(e)\n    if (e.defaultPrevented && isMouseEvent(event) && event.button !== 2) return\n    if (\n      !event.target ||\n      !ref.current?.contains(event.target as DOMNode) ||\n      isEditableDOMElement(event.target) ||\n      inAbsoluteDOMElement(event.target)\n    )\n      return\n\n    IS_MOUSEDOWN.set(editor, true)\n    if (isDoubleClickRef.current) {\n      if (isSamePoint(event)) {\n        return\n      } else {\n        isDoubleClickRef.current = false\n      }\n    }\n    setFocused(true)\n    const point = Editable.findEventPoint(editor, event)\n    if (point) {\n      const isShift = IS_SHIFT_PRESSED.get(editor)\n      if (!isShift) {\n        const { selection } = editor\n        if (event instanceof MouseEvent && event.button === 2) {\n          isContextMenu.current = true\n        }\n        // Perform drag on existing selection while selected.\n        else if (\n          selection &&\n          focused &&\n          isSelectedOnCurrentSelection(editor, selection, point, isTouchDevice)\n        ) {\n          // Drag not performed on touch devices.\n          if (!isTouchDevice) {\n            const dataTransfer = new DataTransfer()\n            setDataTransfer(dataTransfer, {\n              fragment: editor.getFragment(selection),\n            })\n            setDrag({\n              from: selection,\n              data: dataTransfer,\n              position: {\n                x: event.clientX,\n                y: event.clientY,\n              },\n            })\n            editor.onSelectStart()\n          }\n          return\n        }\n        startPointRef.current = point\n      }\n      const range = handleSelecting(\n        point,\n        !isContextMenu.current,\n        !isEditableDOMElement(event.target),\n      )\n      if (range) editor.onSelectStart()\n    } else startPointRef.current = null\n  }\n\n  const handleRootMouseUp = () => {\n    startPointRef.current = null\n  }\n\n  const isDoubleClickRef = React.useRef(false)\n  const isDoubleClickTimerRef = React.useRef<number>()\n  const { handleMultipleClick, isSamePoint } = useMultipleClick({\n    onClick: () => {\n      isDoubleClickRef.current = false\n    },\n    onMultipleClick: (event, count) => {\n      const { selection } = editor\n      if (!selection || event.defaultPrevented) return\n      event.preventDefault()\n      const container = Editable.toDOMNode(editor, editor)\n      if (isDOMNode(event.target) && !container.contains(event.target)) return\n      const isCollapsed = Range.isCollapsed(selection)\n      if (count === 1 && !isCollapsed) {\n        return false\n      } else if (count === 2) {\n        editor.selectWord()\n        isDoubleClickRef.current = true\n        if (isDoubleClickTimerRef.current) clearTimeout(isDoubleClickTimerRef.current)\n        isDoubleClickTimerRef.current = setTimeout(() => {\n          isDoubleClickRef.current = false\n        }, 500)\n        return\n      } else if (count === 3) {\n        editor.selectLine()\n        isDoubleClickRef.current = false\n        return false\n      }\n    },\n  })\n\n  const [awaitUpdateDrawingSelection, setAwaitUpdateDrawingSelection] = React.useState(\n    editor.selection,\n  )\n\n  useIsomorphicLayoutEffect(() => {\n    const handleChange = () => {\n      const { selection } = editor\n      setAwaitUpdateDrawingSelection(selection ? Object.assign({}, selection) : null)\n    }\n    editor.on('change', handleChange)\n\n    const handleShift = (event: KeyboardEvent) => {\n      if (event.key.toLowerCase() === 'shift') {\n        IS_SHIFT_PRESSED.set(editor, false)\n      }\n    }\n\n    let window: Window | null = null\n    if (ref.current && (window = getDefaultView(ref.current))) {\n      EDITOR_TO_WINDOW.set(editor, window)\n      EDITOR_TO_ELEMENT.set(editor, ref.current)\n      NODE_TO_ELEMENT.set(editor, ref.current)\n      ELEMENT_TO_NODE.set(ref.current, editor)\n      setRendered(true)\n\n      window.addEventListener('keyup', handleShift)\n      window.addEventListener('mousedown', handleDocumentMouseDown)\n      window.addEventListener('mouseup', handleDocumentMouseUp)\n      if (isTouchDevice) {\n        window.addEventListener('touchend', handleDocumentTouchEnd)\n        window.addEventListener('touchmove', handleDocumentMouseMove, { passive: false })\n      } else {\n        window.addEventListener('mousemove', handleDocumentMouseMove)\n      }\n    } else {\n      NODE_TO_ELEMENT.delete(editor)\n    }\n\n    return () => {\n      editor.off('change', handleChange)\n      window?.removeEventListener('keyup', handleShift)\n      window?.removeEventListener('mousedown', handleDocumentMouseDown)\n      window?.removeEventListener('mouseup', handleDocumentMouseUp)\n      if (isTouchDevice) {\n        window?.removeEventListener('touchend', handleDocumentTouchEnd)\n        window?.removeEventListener('touchmove', handleDocumentMouseMove)\n      } else {\n        window?.removeEventListener('mousemove', handleDocumentMouseMove)\n      }\n    }\n  }, [editor, handleDocumentMouseDown, handleDocumentMouseMove, handleDocumentMouseUp])\n\n  React.useEffect(() => {\n    // 在拖拽完成后触发onSelectEnd，否则内容可能还未渲染完毕\n    if (isDragEnded.current) {\n      editor.onSelectEnd()\n      isDragEnded.current = false\n    }\n  }, [awaitUpdateDrawingSelection, editor])\n\n  useIsomorphicLayoutEffect(() => {\n    SelectionDrawing.setSelection(editor, awaitUpdateDrawingSelection)\n  }, [awaitUpdateDrawingSelection])\n\n  // 处理文件拖拽\n  const handleDragOver = (event: React.DragEvent) => {\n    event.preventDefault()\n    if (readOnly) return\n    const point = Editable.findEventPoint(editor, event)\n    if (point) {\n      const dragRange = {\n        anchor: point,\n        focus: point,\n      }\n      const position = {\n        x: event.clientX,\n        y: event.clientY,\n      }\n      if (!dragging) {\n        setDrag({\n          type: 'text',\n          from: dragRange,\n          data: event.dataTransfer,\n        })\n      }\n      setDrag({\n        position,\n        to: dragRange,\n      })\n    }\n  }\n\n  const handleDrop = (event: React.DragEvent) => {\n    event.preventDefault()\n    event.stopPropagation()\n    setDrag(null)\n    if (readOnly) return\n    const point = Editable.findEventPoint(editor, event)\n    if (point) {\n      Transforms.select(editor, point)\n      const clipboardEvent = new ClipboardEvent('paset', { clipboardData: event.dataTransfer })\n      editor.onPaste(clipboardEvent)\n    }\n  }\n\n  const handleContextMenu = (event: React.MouseEvent) => {\n    if (!isTouchDevice) editor.onContextMenu(event.nativeEvent)\n  }\n\n  const cursor = React.useMemo(() => {\n    if (dragging && dragTo) {\n      return 'default'\n    }\n    return 'text'\n  }, [dragTo, dragging])\n\n  const renderPlaceholder = usePlaceholder(editor)\n\n  const handleAnchorTouchPointStart = React.useCallback(\n    (event: React.TouchEvent) => {\n      event.stopPropagation()\n      const { selection } = editor\n      if (!selection) return\n      startPointRef.current = Range.end(selection)\n      IS_MOUSEDOWN.set(editor, true)\n      editor.onSelectStart()\n    },\n    [editor],\n  )\n\n  const handleFocusTouchPointStart = React.useCallback(\n    (event: React.TouchEvent) => {\n      event.stopPropagation()\n      const { selection } = editor\n      if (!selection) return\n      startPointRef.current = Range.start(selection)\n      IS_MOUSEDOWN.set(editor, true)\n      editor.onSelectStart()\n    },\n    [editor],\n  )\n\n  return (\n    <div\n      style={{\n        ...style,\n        position: 'relative',\n      }}\n    >\n      <Component\n        role={readOnly ? undefined : 'textbox'}\n        {...attributes}\n        {...{ [DATA_EDITABLE_NODE]: 'editor' }}\n        zindex={-1}\n        ref={ref}\n        style={{\n          // Prevent the default outline styles.\n          outline: 'none',\n          // Preserve adjacent whitespace and new lines.\n          whiteSpace: 'pre-wrap',\n          // Allow words to break if they are too long.\n          wordBreak: 'break-word',\n          // Disable the default user-select behavior.\n          userSelect: 'none',\n          // Set cursor to text.\n          cursor,\n          //\n          overflowWrap: 'break-word',\n        }}\n        onTouchStart={isTouchDevice ? handleRootTouchStart : undefined}\n        onMouseDown={isTouchDevice ? undefined : handleRootMouseDown}\n        onMouseUp={handleRootMouseUp}\n        onClick={handleMultipleClick}\n        onDragOver={handleDragOver}\n        onDrop={handleDrop}\n        onContextMenu={handleContextMenu}\n      >\n        <Children renderPlaceholder={renderPlaceholder} />\n      </Component>\n      <ShadowContainer ref={current => EDITOR_TO_SHADOW.set(editor, current)}>\n        <CaretComponent />\n        <DragCaretComponent />\n        <SelectionComponent />\n        <InputComponent autoFocus={autoFocus} />\n      </ShadowContainer>\n      <TouchPointComponent\n        onAnchorTouchStart={handleAnchorTouchPointStart}\n        onFocusTouchStart={handleFocusTouchPointStart}\n      />\n      {rendered && <Slots />}\n    </div>\n  )\n}\n\nconst isSelectedOnCurrentSelection = (\n  editor: Editor,\n  selection: Range,\n  point: Point,\n  compareOnCollapsed = false,\n) => {\n  return (\n    (Range.includes(selection, point) &&\n      ((!Point.equals(Range.end(selection), point) &&\n        !Point.equals(Range.start(selection), point)) ||\n        (Range.isCollapsed(selection) &&\n          !!Editor.above(editor, { match: n => Editor.isVoid(editor, n) })))) ||\n    (compareOnCollapsed &&\n      Range.isCollapsed(selection) &&\n      Point.equals(Range.start(selection), point))\n  )\n}\n","import { Editor, Range, Element, Ancestor, Descendant } from '@editablejs/models'\n\nimport ElementComponent from '../components/element'\nimport TextComponent from '../components/text'\nimport { Editable } from '../plugin/editable'\nimport { useEditableStatic } from './use-editable'\nimport { NODE_TO_INDEX, NODE_TO_PARENT } from '../utils/weak-maps'\nimport { NodeSelectedContext } from './use-node-selected'\nimport { NodeFocusedContext } from './use-node-focused'\nimport { GridContext } from './use-grid'\nimport { PlaceholderRender } from '../plugin/placeholder'\n\n/**\n * Children.\n */\nconst useChildren = (props: {\n  node: Ancestor\n  selection: Range | null\n  renderPlaceholder?: PlaceholderRender\n}) => {\n  const { node, selection, renderPlaceholder } = props\n  const editor = useEditableStatic()\n  const path = Editable.findPath(editor, node)\n  const children = []\n  const isLeafBlock =\n    Element.isElement(node) && !editor.isInline(node) && Editor.hasInlines(editor, node)\n\n  for (let i = 0; i < node.children.length; i++) {\n    const p = path.concat(i)\n    const n = node.children[i] as Descendant\n    const key = Editable.findKey(editor, n)\n    const range = Editor.range(editor, p)\n    const sel = selection && Range.intersection(range, selection)\n    const focused =\n      selection && Range.includes(range, selection.anchor) && Range.includes(range, selection.focus)\n\n    if (Element.isElement(n)) {\n      const element = (\n        <NodeSelectedContext.Provider key={`selected-provider-${key.id}`} value={!!sel}>\n          <NodeFocusedContext.Provider key={`focused-provider-${key.id}`} value={focused ?? false}>\n            <ElementComponent\n              element={n}\n              key={key.id}\n              selection={sel}\n              renderPlaceholder={renderPlaceholder}\n            />\n          </NodeFocusedContext.Provider>\n        </NodeSelectedContext.Provider>\n      )\n      if (Editor.isGrid(editor, n)) {\n        children.push(\n          <GridContext.Provider key={`grid-provider-${key.id}`} value={n}>\n            {element}\n          </GridContext.Provider>,\n        )\n      } else {\n        children.push(element)\n      }\n    } else {\n      children.push(\n        <TextComponent\n          renderPlaceholder={renderPlaceholder}\n          key={key.id}\n          isLast={isLeafBlock && i === node.children.length - 1}\n          parent={node}\n          text={n}\n        />,\n      )\n    }\n\n    NODE_TO_INDEX.set(n, i)\n    NODE_TO_PARENT.set(n, node)\n  }\n\n  return children\n}\n\nexport default useChildren\n","import * as React from 'react'\nimport getDirection from 'direction'\nimport { Editor, Node, Range, Element as SlateElement } from '@editablejs/models'\n\nimport Text from './text'\nimport useChildren from '../hooks/use-children'\nimport { Editable, useEditableStatic, ElementAttributes } from '..'\nimport { useIsomorphicLayoutEffect } from '../hooks/use-isomorphic-layout-effect'\nimport {\n  NODE_TO_ELEMENT,\n  ELEMENT_TO_NODE,\n  NODE_TO_PARENT,\n  NODE_TO_INDEX,\n  EDITOR_TO_KEY_TO_ELEMENT,\n} from '../utils/weak-maps'\nimport { DATA_EDITABLE_INLINE, DATA_EDITABLE_NODE, DATA_EDITABLE_VOID } from '../utils/constants'\nimport { useElementDecorations } from '../hooks/use-decorate'\nimport { PlaceholderRender } from '../plugin/placeholder'\nimport { usePlaceholder } from '../hooks/use-placeholder'\n\n/**\n * Element.\n */\nconst Element = (props: {\n  element: SlateElement\n  selection: Range | null\n  renderPlaceholder?: PlaceholderRender\n}) => {\n  const { element, selection, renderPlaceholder } = props\n  const ref = React.useRef<HTMLElement>(null)\n  const editor = useEditableStatic()\n  const isInline = editor.isInline(element)\n  const key = Editable.findKey(editor, element)\n\n  const currentRenderPlaceholder = usePlaceholder(element)\n  let children: React.ReactNode = useChildren({\n    node: element,\n    selection,\n    renderPlaceholder: Editor.isEmpty(editor, element)\n      ? currentRenderPlaceholder ?? renderPlaceholder\n      : undefined,\n  })\n\n  // Attributes that the developer must mix into the element in their\n  // custom node renderer component.\n  const attributes: ElementAttributes = {\n    [DATA_EDITABLE_NODE]: 'element',\n    ref,\n  }\n\n  if (isInline) {\n    attributes[DATA_EDITABLE_INLINE] = true\n  }\n\n  // If it's a block node with inline children, add the proper `dir` attribute\n  // for text direction.\n  if (!isInline && Editor.hasInlines(editor, element)) {\n    const text = Node.string(element)\n    const dir = getDirection(text)\n\n    if (dir === 'rtl') {\n      attributes.dir = dir\n    }\n  }\n\n  // If it's a void node, wrap the children in extra void-specific elements.\n  if (Editor.isVoid(editor, element)) {\n    attributes[DATA_EDITABLE_VOID] = true\n\n    const Tag = isInline ? 'span' : 'div'\n    const [[text]] = Node.texts(element)\n\n    children = (\n      <Tag\n        style={{\n          height: '0',\n          color: 'transparent',\n          outline: 'none',\n        }}\n      >\n        <Text\n          renderPlaceholder={renderPlaceholder ?? currentRenderPlaceholder}\n          isLast={false}\n          parent={element}\n          text={text}\n        />\n      </Tag>\n    )\n\n    NODE_TO_INDEX.set(text, 0)\n    NODE_TO_PARENT.set(text, element)\n  }\n\n  // Update element-related weak maps with the DOM element ref.\n  useIsomorphicLayoutEffect(() => {\n    const KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor)\n    if (ref.current) {\n      KEY_TO_ELEMENT?.set(key, ref.current)\n      NODE_TO_ELEMENT.set(element, ref.current)\n      ELEMENT_TO_NODE.set(ref.current, element)\n    } else {\n      KEY_TO_ELEMENT?.delete(key)\n      NODE_TO_ELEMENT.delete(element)\n    }\n  })\n  const path = Editable.findPath(editor, element)\n\n  const newAttributes = editor.renderElementAttributes({ attributes, element })\n\n  let content = editor.renderElement({ attributes: newAttributes, children, element })\n\n  const decorates = useElementDecorations(element, path)\n\n  if (decorates.length > 0) {\n    content = decorates.reduceRight((children, decorate) => {\n      return decorate.renderElement({\n        node: element,\n        path,\n        children,\n      })\n    }, content)\n  }\n\n  return content\n}\n\nconst MemoizedElement = React.memo(Element, (prev, next) => {\n  return (\n    prev.element === next.element &&\n    prev.renderPlaceholder === next.renderPlaceholder &&\n    (prev.selection === next.selection ||\n      (!!prev.selection && !!next.selection && Range.equals(prev.selection, next.selection)))\n  )\n})\n\nexport default MemoizedElement\n","import * as React from 'react'\nimport { Element, Text as SlateText } from '@editablejs/models'\n\nimport Leaf from './leaf'\nimport { useIsomorphicLayoutEffect } from '../hooks/use-isomorphic-layout-effect'\nimport { NODE_TO_ELEMENT, ELEMENT_TO_NODE, EDITOR_TO_KEY_TO_ELEMENT } from '../utils/weak-maps'\nimport { useEditableStatic } from '../hooks/use-editable'\nimport { Editable } from '../plugin/editable'\nimport { DATA_EDITABLE_NODE } from '../utils/constants'\nimport { useTextDecorations } from '../hooks/use-decorate'\nimport { PlaceholderRender } from '../plugin/placeholder'\n\n/**\n * Text.\n */\nconst Text = (props: {\n  isLast: boolean\n  parent: Element\n  text: SlateText\n  renderPlaceholder?: PlaceholderRender\n}) => {\n  const { isLast, parent, text, renderPlaceholder } = props\n  const editor = useEditableStatic()\n  const ref = React.useRef<HTMLSpanElement>(null)\n  const key = Editable.findKey(editor, text)\n  const path = Editable.findPath(editor, text)\n  const decorates = useTextDecorations(text, path).map((d, index) => ({\n    ...d,\n    key: `__decorate__${index}`,\n  }))\n\n  const ranges = decorates\n    .map(({ ranges, key }) => ranges.map(range => ({ ...range, [key]: true })))\n    .flat()\n  const leaves = SlateText.decorations(text, ranges)\n\n  const decorateKeys = decorates.map(d => d.key)\n  const children = []\n  for (let i = 0; i < leaves.length; i++) {\n    const leaf = leaves[i]\n    let content = (\n      <Leaf\n        renderPlaceholder={renderPlaceholder}\n        isLast={isLast && i === leaves.length - 1}\n        key={`${key.id}-${i}`}\n        text={text}\n        leaf={leaf}\n        parent={parent}\n      />\n    )\n    for (const key of decorateKeys) {\n      if (key in leaf) {\n        const dec = decorates[decorateKeys.indexOf(key)].decorate.renderText({\n          node: text,\n          path,\n          children: content,\n        })\n        content = React.cloneElement(dec, { key })\n      }\n    }\n    children.push(content)\n  }\n  // Update element-related weak maps with the DOM element ref.\n  useIsomorphicLayoutEffect(() => {\n    const KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor)\n    if (ref.current) {\n      KEY_TO_ELEMENT?.set(key, ref.current)\n      NODE_TO_ELEMENT.set(text, ref.current)\n      ELEMENT_TO_NODE.set(ref.current, text)\n    } else {\n      KEY_TO_ELEMENT?.delete(key)\n      NODE_TO_ELEMENT.delete(text)\n    }\n  })\n\n  return (\n    <span {...{ [DATA_EDITABLE_NODE]: 'text' }} ref={ref}>\n      {children}\n    </span>\n  )\n}\n\nconst MemoizedText = React.memo(Text, (prev, next) => {\n  return (\n    next.parent === prev.parent &&\n    next.isLast === prev.isLast &&\n    next.text === prev.text &&\n    prev.renderPlaceholder === next.renderPlaceholder\n  )\n})\n\nexport default MemoizedText\n","import * as React from 'react'\nimport { Element, Text } from '@editablejs/models'\nimport String from './string'\nimport { useEditableStatic } from '../hooks/use-editable'\nimport { TextAttributes } from '../plugin/editable'\nimport { DATA_EDITABLE_LEAF, DATA_EDITABLE_PLACEHOLDER } from '../utils/constants'\nimport { PlaceholderRender } from '../plugin/placeholder'\n\n/**\n * Individual leaves in a text node with unique formatting.\n */\nconst Leaf = (props: {\n  isLast: boolean\n  parent: Element\n  leaf: Text\n  text: Text\n  renderPlaceholder?: PlaceholderRender\n}) => {\n  const { isLast, text, leaf, parent, renderPlaceholder } = props\n\n  let children = <String isLast={isLast} parent={parent} text={text} leaf={leaf} />\n\n  const editor = useEditableStatic()\n  if (renderPlaceholder) {\n    const placeholderComponent = editor.renderPlaceholder({\n      attributes: { [DATA_EDITABLE_PLACEHOLDER]: true },\n      node: text,\n      children: renderPlaceholder({ node: text }),\n    })\n    if (placeholderComponent)\n      children = (\n        <React.Fragment>\n          {placeholderComponent}\n          {children}\n        </React.Fragment>\n      )\n  }\n\n  // COMPAT: Having the `data-` attributes on these leaf elements ensures that\n  // in certain misbehaving browsers they aren't weirdly cloned/destroyed by\n  // contenteditable behaviors. (2019/05/08)\n  const attributes: TextAttributes = {\n    [DATA_EDITABLE_LEAF]: true,\n  }\n  const newAttributes = editor.renderLeafAttributes({ attributes, text })\n  return editor.renderLeaf({ attributes: newAttributes, children, text })\n}\n\nconst MemoizedLeaf = React.memo(Leaf, (prev, next) => {\n  return (\n    next.parent === prev.parent &&\n    prev.renderPlaceholder === next.renderPlaceholder &&\n    next.isLast === prev.isLast &&\n    next.text === prev.text\n  )\n})\n\nexport default MemoizedLeaf\n","import * as React from 'react'\nimport { Editor, Text, Path, Element, Node, CompositionText } from '@editablejs/models'\n\nimport { Editable } from '../plugin/editable'\nimport { useEditableStatic } from '../hooks/use-editable'\nimport {\n  DATA_EDITABLE_COMPOSITION,\n  DATA_EDITABLE_LENGTH,\n  DATA_EDITABLE_STRING,\n  DATA_EDITABLE_ZERO_WIDTH,\n} from '../utils/constants'\n\n/**\n * Leaf content strings.\n */\nconst String: React.FC<{\n  isLast: boolean\n  parent: Element\n  text: Text\n\n  leaf: Text\n}> = props => {\n  const { isLast, parent, text, leaf } = props\n  const editor = useEditableStatic()\n  const path = Editable.findPath(editor, text)\n  const parentPath = Path.parent(path)\n\n  // COMPAT: Render text inside void nodes with a zero-width space.\n  // So the node can contain selection but the text is not visible.\n  if (editor.isVoid(parent)) {\n    return <ZeroWidthString length={Node.string(parent).length} />\n  }\n\n  if (CompositionText.isCompositionText(text)) {\n    const { offset, text: compositionText } = text.composition\n    const content = text.text\n    const left = content.substring(0, offset)\n    const right = content.substring(offset)\n    return (\n      <>\n        {left && <TextString text={left} />}\n        <CompositionString text={compositionText} />\n        {right && <TextString text={right} />}\n      </>\n    )\n  }\n  // COMPAT: If this is the last text node in an empty block, render a zero-\n  // width space that will convert into a line break when copying and pasting\n  // to support expected plain text.\n  if (\n    leaf.text === '' &&\n    parent.children[parent.children.length - 1] === text &&\n    !editor.isInline(parent) &&\n    Editor.string(editor, parentPath) === ''\n  ) {\n    return <ZeroWidthString isLineBreak />\n  }\n\n  // COMPAT: If the text is empty, it's because it's on the edge of an inline\n  // node, so we render a zero-width space so that the selection can be\n  // inserted next to it still.\n  if (leaf.text === '') {\n    return <ZeroWidthString />\n  }\n\n  // COMPAT: Browsers will collapse trailing new lines at the end of blocks,\n  // so we need to add an extra trailing new lines to prevent that.\n  if (isLast && leaf.text.slice(-1) === '\\n') {\n    return <TextString isTrailing text={leaf.text} />\n  }\n  return <TextString text={leaf.text} />\n}\n\n/**\n * Leaf strings with text in them.\n */\nconst TextString = (props: { text: string; isTrailing?: boolean }) => {\n  const { text, isTrailing = false } = props\n\n  const getTextContent = () => {\n    return `${text ?? ''}${isTrailing ? '\\n' : ''}`\n  }\n\n  return <span {...{ [DATA_EDITABLE_STRING]: true }}>{getTextContent()}</span>\n}\n\nconst CompositionString = (props: { text: string }) => {\n  const { text } = props\n  return <u {...{ [DATA_EDITABLE_COMPOSITION]: true }}>{text}</u>\n}\n\n/**\n * Leaf strings without text, render as zero-width strings.\n */\n\nconst ZeroWidthString = (props: { length?: number; isLineBreak?: boolean }) => {\n  const { length = 0, isLineBreak = false } = props\n  return (\n    <span\n      {...{ [DATA_EDITABLE_ZERO_WIDTH]: isLineBreak ? 'n' : 'z', [DATA_EDITABLE_LENGTH]: length }}\n    >\n      {'\\uFEFF'}\n      {isLineBreak ? <br /> : null}\n    </span>\n  )\n}\n\nexport default String\n","import {\n  Editor,\n  Node,\n  Text,\n  Element,\n  Path,\n  Point,\n  Range,\n  Scrubber,\n  Transforms,\n  SelectionEdge,\n  Key,\n  DOMElement,\n  DOMNode,\n  DOMPoint,\n  DOMRange,\n  DOMSelection,\n  DOMStaticRange,\n  isDOMElement,\n  isDOMSelection,\n  isDOMNode,\n  isDOMText,\n} from '@editablejs/models'\n\nimport {\n  EDITOR_TO_ELEMENT,\n  ELEMENT_TO_NODE,\n  NODE_TO_INDEX,\n  NODE_TO_KEY,\n  NODE_TO_PARENT,\n  EDITOR_TO_WINDOW,\n  EDITOR_TO_KEY_TO_ELEMENT,\n  IS_COMPOSING,\n  NODE_TO_ELEMENT,\n} from '../utils/weak-maps'\nimport { normalizeDOMPoint, hasShadowRoot } from '../utils/dom'\nimport { IS_CHROME, IS_FIREFOX } from '../utils/environment'\nimport findNearbyNodes, { isAlignY } from '../utils/nearby'\nimport { getTextOffset } from '../utils/text'\nimport { getLineRectsByNode, getLineRectsByRange } from '../utils/selection'\nimport { Focused } from '../hooks/use-focused'\nimport { EventHandler, EventType } from './event'\nimport {\n  DATA_EDITABLE_COMPOSITION,\n  DATA_EDITABLE_INLINE,\n  DATA_EDITABLE_LEAF,\n  DATA_EDITABLE_LENGTH,\n  DATA_EDITABLE_NODE,\n  DATA_EDITABLE_PLACEHOLDER,\n  DATA_EDITABLE_STRING,\n  DATA_EDITABLE_VOID,\n  DATA_EDITABLE_ZERO_WIDTH,\n} from '../utils/constants'\nimport { getNativeEvent, isTouch } from '../utils/event'\nimport { ReadOnly } from '../hooks/use-read-only'\nimport scrollIntoView from 'scroll-into-view-if-needed'\n\nexport type BaseAttributes = Omit<React.HTMLAttributes<HTMLElement>, 'children'>\n\nexport interface ElementAttributes<T extends any = any> extends BaseAttributes {\n  [DATA_EDITABLE_NODE]: 'element'\n  [DATA_EDITABLE_INLINE]?: true\n  [DATA_EDITABLE_VOID]?: true\n  dir?: 'rtl'\n  ref: React.MutableRefObject<T>\n}\n\nexport interface TextAttributes extends BaseAttributes {\n  [DATA_EDITABLE_LEAF]?: true\n}\n\nexport type NodeAttributes = ElementAttributes | TextAttributes\n\nexport interface PlaceholderAttributes extends BaseAttributes {\n  [DATA_EDITABLE_PLACEHOLDER]: true\n}\n\nexport interface RenderElementAttributes<T extends Element = Element> {\n  element: T\n  attributes: ElementAttributes\n}\n\nexport interface RenderLeafAttributes<T extends Text = Text> {\n  text: T\n  attributes: TextAttributes\n}\n\n/**\n * `RenderElementProps` are passed to the `renderElement` handler.\n */\nexport interface RenderElementProps<T extends Element = Element, R extends any = any> {\n  children: any\n  element: T\n  attributes: ElementAttributes<R>\n}\n\n/**\n * `RenderLeafProps` are passed to the `renderLeaf` handler.\n */\nexport interface RenderLeafProps<T extends Text = Text> {\n  children: any\n  text: T\n  attributes: TextAttributes\n}\n\nexport interface RenderPlaceholderProps<T extends Node = Node> {\n  children: any\n  attributes: PlaceholderAttributes\n  node: T\n}\n\nexport interface SerializeHtmlOptions {\n  node: Node\n  attributes?: Record<string, any>\n  styles?: Record<string, any>\n}\n\nexport interface DeserializeHtmlOptions {\n  node: DOMNode\n  attributes?: Record<string, any>\n  markAttributes?: Record<string, any>\n  stripBreak?: true | ((text: string) => boolean)\n}\n\nexport interface SelectWordOptions {\n  at?: Range\n  edge?: SelectionEdge\n}\n\n/**\n * A React and DOM-specific version of the `Editor` interface.\n */\nexport interface Editable extends Editor {\n  blur(): void\n  focus(start?: boolean): void\n  copy(range?: Range): void\n  cut(range?: Range): void\n  selectWord: (options?: SelectWordOptions) => void\n  selectLine: (options?: SelectWordOptions) => void\n  insertFromClipboard(at?: Range): void\n  insertTextFromClipboard(at?: Range): void\n  insertFile(file: File, at?: Range): void\n  on: <T extends EventType>(type: T, handler: EventHandler<T>, prepend?: boolean) => void\n  once: <T extends EventType>(type: T, handler: EventHandler<T>, prepend?: boolean) => void\n  off: <T extends EventType>(type: T, handler: EventHandler<T>) => void\n  emit: <T extends EventType>(type: T, ...args: Parameters<EventHandler<T>>) => void\n  onKeydown: (event: KeyboardEvent) => void\n  onKeyup: (event: KeyboardEvent) => void\n  onFocus: () => void\n  onBlur: () => void\n  onPaste: (event: ClipboardEvent) => void\n  onCut: (event: ClipboardEvent) => void\n  onCopy: (event: ClipboardEvent) => void\n  onInput: (value: string) => void\n  onBeforeInput: (value: string) => void\n  onCompositionStart: (value: string) => void\n  onCompositionEnd: (value: string) => void\n  onSelectStart: () => void\n  onSelecting: () => void\n  onSelectEnd: () => void\n  onSelectionChange: () => void\n  onTouchHold: (event: TouchEvent) => void\n  onTouchTrack: () => void\n  onContextMenu: (event: MouseEvent) => void\n  onDestory: () => void\n  renderElementAttributes: (props: RenderElementAttributes) => ElementAttributes\n  renderLeafAttributes: (props: RenderLeafAttributes) => TextAttributes\n  renderElement: (props: RenderElementProps) => JSX.Element\n  renderLeaf: (props: RenderLeafProps) => JSX.Element\n  renderPlaceholder: (props: RenderPlaceholderProps) => JSX.Element | void | null\n  toDataTransfer: (range?: Range) => DataTransfer | null\n}\n\nexport const Editable = {\n  isEditor(value: any): value is Editable {\n    return !!value && Editor.isEditor(value) && 'onSelectionChange' in value\n  },\n  /**\n   * Check if the user is currently composing inside the editor.\n   */\n  isComposing(editor: Editor): boolean {\n    return !!IS_COMPOSING.get(editor)\n  },\n\n  /**\n   * 获取在选区内选中一行内容的节点以及所在行的索引\n   * @param editor\n   * @param options\n   * @returns\n   */\n  getSelectLine(\n    editor: Editor,\n    options: { range?: Range; match?: (element: Element) => boolean } = {},\n  ): [Element, number] | undefined {\n    const { range = editor.selection, match = () => true } = options\n    if (!range || Range.isCollapsed(range)) return\n    const start = Range.start(range)\n    const entry = Editor.above(editor, { at: start, match: n => Editor.isBlock(editor, n) })\n    if (!entry) return\n    const rangeLines = getLineRectsByRange(editor, range)\n    let [block, path] = entry\n    while (block) {\n      if (match(block)) {\n        const elLines = getLineRectsByNode(editor, block)\n        for (const rangeLine of rangeLines) {\n          const index = elLines.findIndex(\n            elLine =>\n              elLine.left === rangeLine.left &&\n              elLine.top === rangeLine.top &&\n              elLine.width === rangeLine.width,\n          )\n          if (~index) {\n            return [block, index]\n          }\n        }\n      }\n      const next = Editor.next(editor, { at: path, match: n => Editor.isBlock(editor, n) })\n      if (!next) return\n      const [n, p] = next\n      block = n as Element\n      path = p\n    }\n    return\n  },\n  /**\n   * 检查选区是否选中在内容一行的开始或者结尾\n   * @param editor\n   * @param options\n   * @returns\n   */\n  isSelectLineEdge(editor: Editor, options: { point?: Point; edge?: SelectionEdge } = {}): boolean {\n    const { point = editor.selection?.focus, edge = 'start' } = options\n    if (!point) return false\n    const entry = Editor.above(editor, { at: point, match: n => Editor.isBlock(editor, n) })\n    if (!entry) return false\n    const [block] = entry\n    const rangeLines = getLineRectsByRange(editor, { anchor: point, focus: point })\n    if (rangeLines.length === 0) return false\n    const rangeLine = rangeLines[0]\n    const lines = getLineRectsByNode(editor, block)\n    for (const line of lines) {\n      if (\n        ~['start', 'anchor'].indexOf(edge) &&\n        line.left === rangeLine.left &&\n        line.top === rangeLine.top\n      ) {\n        return true\n      } else if (\n        ~['end', 'focus'].indexOf(edge) &&\n        line.right === rangeLine.right &&\n        line.top === rangeLine.top\n      ) {\n        return true\n      }\n    }\n    return false\n  },\n\n  /**\n   * Return the host window of the current editor.\n   */\n  getWindow(editor: Editor): Window {\n    const window = EDITOR_TO_WINDOW.get(editor)\n    if (!window) {\n      throw new Error('Unable to find a host window element for this editor')\n    }\n    return window\n  },\n\n  /**\n   * Find a key for a Editor node.\n   */\n\n  findKey(editor: Editor, node: Node): Key {\n    let key = NODE_TO_KEY.get(node)\n\n    if (!key) {\n      key = new Key()\n      NODE_TO_KEY.set(node, key)\n    }\n\n    return key\n  },\n\n  /**\n   * Find the path of Editor node.\n   */\n\n  findPath(editor: Editor, node: Node): Path {\n    const path: Path = []\n    let child = node\n\n    while (true) {\n      const parent = NODE_TO_PARENT.get(child)\n\n      if (parent == null) {\n        if (Editor.isEditor(child)) {\n          return path\n        } else {\n          break\n        }\n      }\n\n      const i = NODE_TO_INDEX.get(child)\n\n      if (i == null) {\n        break\n      }\n\n      path.unshift(i)\n      child = parent\n    }\n\n    throw new Error(`Unable to find the path for Editor node: ${Scrubber.stringify(node)}`)\n  },\n\n  /**\n   * Find the DOM node that implements DocumentOrShadowRoot for the editor.\n   */\n\n  findDocumentOrShadowRoot(editor: Editor): Document | ShadowRoot {\n    const el = Editable.toDOMNode(editor, editor)\n    const root = el.getRootNode()\n\n    if (\n      (root instanceof Document || root instanceof ShadowRoot) &&\n      (root as any).getSelection != null\n    ) {\n      return root\n    }\n\n    return el.ownerDocument\n  },\n\n  /**\n   * Check if the editor is focused.\n   */\n  isFocused(editor: Editor): boolean {\n    return Focused.is(editor)\n  },\n\n  /**\n   * Check if the editor is in read-only mode.\n   */\n\n  isReadOnly(editor: Editor): boolean {\n    return ReadOnly.is(editor)\n  },\n\n  /**\n   * Blur the editor.\n   */\n\n  blur(editor: Editable): void {\n    editor.blur()\n  },\n\n  /**\n   * Focus the editor.\n   */\n  focus(editor: Editable): void {\n    editor.focus()\n  },\n\n  deselect(editor: Editor): void {\n    const { selection } = editor\n    if (selection) {\n      Transforms.deselect(editor)\n    }\n  },\n\n  /**\n   * Check if a DOM node is within the editor.\n   */\n  hasDOMNode(editor: Editor, target: DOMNode): boolean {\n    const editorEl = Editable.toDOMNode(editor, editor)\n    let targetEl\n\n    // COMPAT: In Firefox, reading `target.nodeType` will throw an error if\n    // target is originating from an internal \"restricted\" element (e.g. a\n    // stepper arrow on a number input). (2018/05/04)\n    // https://github.com/ianstormtaylor/slate/issues/1819\n    try {\n      targetEl = (isDOMElement(target) ? target : target.parentElement) as HTMLElement\n    } catch (err: any) {\n      if (!err.message.includes('Permission denied to access property \"nodeType\"')) {\n        throw err\n      }\n    }\n\n    if (!targetEl) {\n      return false\n    }\n\n    return targetEl.closest(`[${DATA_EDITABLE_NODE}=\"editor\"]`) === editorEl\n  },\n\n  /**\n   * Find the native DOM element from a Editor node.\n   */\n\n  toDOMNode(editor: Editor, node: Node): HTMLElement {\n    const KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor)\n    const offsetNode = Editor.isEditor(node)\n      ? EDITOR_TO_ELEMENT.get(editor)\n      : KEY_TO_ELEMENT?.get(Editable.findKey(editor, node))\n\n    if (!offsetNode) {\n      throw new Error(`Cannot resolve a DOM node from Editor node: ${Scrubber.stringify(node)}`)\n    }\n\n    return offsetNode\n  },\n\n  /**\n   * Find a native DOM selection point from a Editor point.\n   */\n  toDOMPoint(editor: Editor, point: Point): DOMPoint {\n    const [node] = Editor.node(editor, point.path)\n    const el = Editable.toDOMNode(editor, node)\n    let domPoint: DOMPoint | undefined\n\n    // If we're inside a void node, force the offset to 0, otherwise the zero\n    // width spacing character will result in an incorrect offset of 1\n    if (Editor.void(editor, { at: point })) {\n      point = { path: point.path, offset: 0 }\n    }\n\n    // For each leaf, we need to isolate its content, which means filtering\n    // to its direct text and zero-width spans. (We have to filter out any\n    // other siblings that may have been rendered alongside them.)\n    const selector = `[${DATA_EDITABLE_STRING}], [${DATA_EDITABLE_COMPOSITION}], [${DATA_EDITABLE_ZERO_WIDTH}]`\n    const texts = Array.from(el.querySelectorAll(selector))\n    let start = 0\n\n    for (const text of texts) {\n      const offsetNode = text.childNodes[0] as HTMLElement\n\n      if (offsetNode == null || offsetNode.textContent == null) {\n        continue\n      }\n\n      const { length } = offsetNode.textContent\n      const attr = text.getAttribute(DATA_EDITABLE_LENGTH)\n      const trueLength = attr == null ? length : parseInt(attr, 10)\n      const end = start + trueLength\n\n      if (point.offset <= end) {\n        const offset = Math.min(length, Math.max(0, point.offset - start))\n        domPoint = [offsetNode, offset]\n        break\n      }\n\n      start = end\n    }\n\n    if (!domPoint) {\n      throw new Error(`Cannot resolve a DOM point from Editor point: ${Scrubber.stringify(point)}`)\n    }\n\n    return domPoint\n  },\n\n  /**\n   * Find a native DOM range from a Editor `range`.\n   *\n   * Notice: the returned range will always be ordinal regardless of the direction of Editor `range` due to DOM API limit.\n   *\n   * there is no way to create a reverse DOM Range using Range.setStart/setEnd\n   * according to https://dom.spec.whatwg.org/#concept-range-bp-set.\n   */\n  toDOMRange(editor: Editor, range: Range): DOMRange {\n    const { anchor, focus } = range\n    const isBackward = Range.isBackward(range)\n    const domAnchor = Editable.toDOMPoint(editor, anchor)\n    const domFocus = Range.isCollapsed(range) ? domAnchor : Editable.toDOMPoint(editor, focus)\n\n    const window = Editable.getWindow(editor)\n    const domRange = window.document.createRange()\n    const [startNode, startOffset] = isBackward ? domFocus : domAnchor\n    const [endNode, endOffset] = isBackward ? domAnchor : domFocus\n\n    // A editor Point at zero-width Leaf always has an offset of 0 but a native DOM selection at\n    // zero-width node has an offset of 1 so we have to check if we are in a zero-width node and\n    // adjust the offset accordingly.\n    const startEl = (isDOMElement(startNode) ? startNode : startNode.parentElement) as HTMLElement\n    const isStartAtZeroWidth = !!startEl.getAttribute(DATA_EDITABLE_ZERO_WIDTH)\n    const endEl = (isDOMElement(endNode) ? endNode : endNode.parentElement) as HTMLElement\n    const isEndAtZeroWidth = !!endEl.getAttribute(DATA_EDITABLE_ZERO_WIDTH)\n\n    domRange.setStart(startNode, isStartAtZeroWidth ? 1 : startOffset)\n    domRange.setEnd(endNode, isEndAtZeroWidth ? 1 : endOffset)\n    return domRange\n  },\n\n  /**\n   * Find a Editor node from a native DOM `element`.\n   */\n  toEditorNode(editor: Editor, offsetNode: DOMNode): Node {\n    let domEl = isDOMElement(offsetNode) ? offsetNode : offsetNode.parentElement\n\n    if (domEl && !domEl.hasAttribute(DATA_EDITABLE_NODE)) {\n      domEl = domEl.closest(`[${DATA_EDITABLE_NODE}]`)\n    }\n\n    const node = domEl ? ELEMENT_TO_NODE.get(domEl as HTMLElement) : null\n\n    if (!node) {\n      throw new Error(`Cannot resolve a Editor node from DOM node: ${domEl}`)\n    }\n\n    return node\n  },\n\n  findLowestDOMElements(editor: Editor, node: Node) {\n    const domNode = Editable.toDOMNode(editor, node)\n    if (Editor.isVoid(editor, node)) return [domNode]\n    const nodes = domNode.querySelectorAll(\n      `[${DATA_EDITABLE_STRING}], [${DATA_EDITABLE_COMPOSITION}], [${DATA_EDITABLE_ZERO_WIDTH}]`,\n    )\n    return Array.from(nodes)\n  },\n\n  findClosestPoint(editor: Editor, domNode: DOMNode, x: number, y: number): Point | null {\n    const domEl = isDOMElement(domNode) ? domNode : domNode.parentElement\n    if (!domEl) return null\n    const elements: DOMElement[] = []\n    let element: DOMElement | null = domEl.hasAttribute(DATA_EDITABLE_NODE)\n      ? domEl\n      : domEl.closest(`[${DATA_EDITABLE_NODE}]`)\n\n    const addToElements = (node: Node) => {\n      if (!NODE_TO_ELEMENT.get(node)) return\n      const children = Editable.findLowestDOMElements(editor, node)\n      for (const child of children) {\n        if (~elements.indexOf(child)) continue\n        elements.push(child)\n      }\n    }\n\n    if (!element) {\n      const nodes = Node.nodes(editor)\n      for (const [node] of nodes) {\n        addToElements(node)\n      }\n    } else {\n      const node = Editable.toEditorNode(editor, element)\n      if (Text.isText(node) || Editor.isVoid(editor, node)) {\n        addToElements(node)\n      } else {\n        if (!Editor.isSolidVoid(editor, node)) {\n          const rect = element.getBoundingClientRect()\n          const reverse = x < rect.left + rect.width / 2\n          const adjacent = (reverse ? Editor.previous : Editor.next)(editor, {\n            at: Editable.findPath(editor, node),\n          })\n          if (adjacent) {\n            addToElements(adjacent[0])\n          }\n        } else {\n          const isGrid = Editor.isGrid(editor, node)\n          const nodes = Editor.nodes(editor, {\n            at: Editable.findPath(editor, node),\n            match: n => (isGrid && Editor.isGridCell(editor, n)) || Text.isText(n),\n            mode: 'highest',\n          })\n          for (const [child] of nodes) {\n            if (Editor.isBlock(editor, child)) {\n              elements.push(Editable.toDOMNode(editor, child))\n            } else addToElements(child)\n          }\n        }\n      }\n    }\n    let top = y,\n      left = x\n    const nodes = findNearbyNodes(elements, x, y)\n    if (!nodes) return null\n    let offsetNode: DOMElement | null = null\n    if (isDOMNode(nodes)) {\n      offsetNode = nodes\n    } else {\n      const { top: nearbyTop, left: nearbyLeft, right: nearbyRight, below: nearbyBelow } = nodes\n\n      if (nearbyLeft && nearbyBelow) {\n        if (isAlignY(nearbyBelow.rect, nearbyLeft.rect)) {\n          offsetNode = nearbyBelow.node\n          top = nearbyBelow.rect.top\n        } else {\n          offsetNode = nearbyLeft.node\n          left = nearbyLeft.rect.right\n        }\n      } else if (nearbyRight && nearbyBelow) {\n        if (isAlignY(nearbyBelow.rect, nearbyRight.rect)) {\n          offsetNode = nearbyBelow.node\n          top = nearbyBelow.rect.top\n        } else {\n          offsetNode = nearbyRight.node\n          left = nearbyRight.rect.left\n        }\n      } else if (nearbyLeft) {\n        offsetNode = nearbyLeft.node\n        if (left <= nearbyLeft.rect.left) left = nearbyLeft.rect.left\n        else if (left >= nearbyLeft.rect.right) left = nearbyLeft.rect.right\n        else {\n          top = nearbyLeft.rect.top\n        }\n      } else if (nearbyRight) {\n        offsetNode = nearbyRight.node\n        if (left <= nearbyRight.rect.left) left = nearbyRight.rect.left\n        else if (left >= nearbyRight.rect.right) left = nearbyRight.rect.right\n        else {\n          top = nearbyRight.rect.top\n        }\n      } else if (nearbyBelow) {\n        if (left < nearbyBelow.rect.left) {\n          left = nearbyBelow.rect.left\n        } else if (left > nearbyBelow.rect.right) {\n          left = nearbyBelow.rect.right\n        }\n        top = nearbyBelow.rect.top\n        offsetNode = nearbyBelow.node\n      } else if (nearbyTop) {\n        offsetNode = nearbyTop.node\n        if (left < nearbyTop.rect.left) {\n          left = nearbyTop.rect.left\n        } else if (left > nearbyTop.rect.right) {\n          left = nearbyTop.rect.right\n        }\n        top = nearbyTop.rect.bottom\n      }\n    }\n    if (!offsetNode) return null\n    const node = Editable.toEditorNode(editor, offsetNode)\n    if (Text.isText(node)) {\n      const path = Editable.findPath(editor, node)\n      if (node.text.length === 0) {\n        return {\n          path,\n          offset: 0,\n        }\n      }\n      const textNodes = Editable.findLowestDOMElements(editor, node)\n      let startOffset = 0\n      for (let s = 0; s < textNodes.length; s++) {\n        const textNode = textNodes[s]\n        if (textNode === offsetNode) break\n        startOffset += (textNode.textContent ?? '').length\n      }\n      const textNode = isDOMText(offsetNode) ? offsetNode : offsetNode.firstChild\n      if (!isDOMText(textNode)) return null\n      const content = textNode.textContent ?? ''\n      const offset = getTextOffset(textNode, left, top, 0, content.length, content.length)\n      return {\n        path,\n        offset: startOffset + offset,\n      }\n    } else if (Element.isElement(node)) {\n      const point = Editable.toEditorPoint(editor, [offsetNode, 0], {\n        exactMatch: false,\n        suppressThrow: true,\n      })\n      if (!point) return Editor.start(editor, Editable.findPath(editor, node))\n      return point\n    }\n    return null\n  },\n  /**\n   * Get the target point from a DOM `event`.\n   */\n  findEventPoint(editor: Editor, event: any): Point | null {\n    event = getNativeEvent(event)\n    const { clientX: x, clientY: y } = event\n\n    if (x == null || y == null) {\n      throw new Error(`Cannot resolve a Editor range from a DOM event: ${event}`)\n    }\n    let target = event.target\n    if (isTouch(event)) {\n      target = document.elementFromPoint(event.clientX, event.clientY)\n    }\n    return Editable.findClosestPoint(editor, target, x, y)\n  },\n\n  findPreviousLinePoint(editor: Editor, at?: Range): Point | null {\n    const { selection } = editor\n    if (!at && selection) at = selection\n    if (!at) return null\n    const startPoint = Range.start(at)\n    const endPoint = Range.end(at)\n    const startRange = Editable.toDOMRange(editor, { anchor: startPoint, focus: startPoint })\n    const endRange = Editable.toDOMRange(editor, { anchor: endPoint, focus: endPoint })\n\n    const startRects = startRange.getClientRects()\n    const endRects = endRange.getClientRects()\n\n    const block = Editor.above(editor, {\n      at: at.focus,\n      match: n => Editor.isBlock(editor, n),\n    })\n    let top = endRects[0].top\n    let isFind = false\n\n    let isSameLine = true\n\n    let prevBlock = block\n    let domBlock: DOMElement | null = null\n    while (prevBlock && !isFind) {\n      const [block, path] = prevBlock\n      domBlock = Editable.toDOMNode(editor, block)\n      const lowestElements = Editable.findLowestDOMElements(editor, block)\n      for (let l = lowestElements.length - 1; l >= 0 && !isFind; l--) {\n        const lowestElement = lowestElements[l]\n        const rects = lowestElement.getClientRects()\n        for (let i = 0; i < rects.length; i++) {\n          const rect = rects[i]\n          if (rect.height === 0) continue\n          if (rect.bottom <= top) {\n            isFind = true\n            top = rect.bottom - rect.height / 2\n            break\n          }\n        }\n      }\n      if (!isFind) {\n        isSameLine = false\n        prevBlock = Editor.previous(editor, {\n          at: path,\n          match: n => Editor.isBlock(editor, n),\n        })\n      }\n    }\n    if (!domBlock) return null\n    return Editable.findClosestPoint(\n      editor,\n      domBlock,\n      isFind && !isSameLine ? startRects[0].x : 0,\n      top,\n    )\n  },\n\n  findLineEdgePoint(\n    editor: Editor,\n    { at, edge = 'start' }: { at?: Range; edge?: 'start' | 'end' } = {},\n  ): Point | null {\n    const { selection } = editor\n    if (!at && selection) at = selection\n    if (!at) return null\n    const isStart = edge === 'start'\n    const point = isStart ? Range.start(at) : Range.end(at)\n    const range = Editable.toDOMRange(editor, {\n      anchor: point,\n      focus: point,\n    })\n    range.collapse(isStart)\n    const rects = range.getClientRects()\n    const rect = rects[rects.length - 1]\n    const bottom = rect.top + rect.height / 2\n    const block = Editor.above(editor, {\n      at: point,\n      match: n => Editor.isBlock(editor, n),\n    })\n    if (!block) return null\n    const domBlock = Editable.toDOMNode(editor, block[0])\n    return Editable.findClosestPoint(editor, domBlock, isStart ? -99999 : 99999, bottom)\n  },\n\n  findNextLinePoint(editor: Editor, at?: Range): Point | null {\n    const { selection } = editor\n    if (!at && selection) at = selection\n    if (!at) return null\n    const startPoint = Range.start(at)\n    const endPoint = Range.end(at)\n    const startRange = Editable.toDOMRange(editor, { anchor: startPoint, focus: startPoint })\n    const endRange = Editable.toDOMRange(editor, { anchor: endPoint, focus: endPoint })\n\n    const startRects = startRange.getClientRects()\n    const endRects = endRange.getClientRects()\n\n    let blockEntry = Editor.above(editor, {\n      at: at.focus,\n      match: n => Editor.isBlock(editor, n),\n    })\n    let bottom = endRects[0].bottom\n    let isFind = false\n    let isSameLine = true\n    let domBlock: DOMElement | null = null\n    while (blockEntry && !isFind) {\n      const [block, path] = blockEntry\n      domBlock = Editable.toDOMNode(editor, block)\n      const lowestElements = Editable.findLowestDOMElements(editor, block)\n      for (let l = 0; l < lowestElements.length && !isFind; l++) {\n        const lowestElement = lowestElements[l]\n        const rects = lowestElement.getClientRects()\n        for (let i = 0; i < rects.length; i++) {\n          const rect = rects[i]\n          if (rect.height === 0) continue\n          if (rect.top >= bottom) {\n            isFind = true\n            bottom = rect.top + rect.height / 2\n            break\n          }\n        }\n      }\n      if (!isFind) {\n        blockEntry = Editor.next(editor, {\n          at: path,\n          match: n => Editor.isBlock(editor, n),\n        })\n        isSameLine = false\n      }\n    }\n    if (!domBlock) return null\n\n    return Editable.findClosestPoint(\n      editor,\n      domBlock,\n      isFind && !isSameLine ? startRects[0].x : 99999,\n      bottom,\n    )\n  },\n\n  findTextOffsetOnLine(editor: Editor, point: Point) {\n    const blockEntry = Editor.above(editor, {\n      match: n => Editor.isBlock(editor, n),\n      at: point,\n    })\n    const data = {\n      text: '',\n      offset: 0,\n    }\n    if (!blockEntry) {\n      throw new Error(`Cannot resolve a Editor block from a point: ${point}`)\n    }\n    const textNodes = Node.texts(blockEntry[0])\n    let isFindOffset = false\n    for (const [textNode, textPath] of textNodes) {\n      let { text } = textNode\n      const path = blockEntry[1].concat(textPath)\n      const [parent] = Editor.parent(editor, path)\n      if (parent && Editor.isVoid(editor, parent)) {\n        text = ''\n      }\n      if (Path.equals(path, point.path)) {\n        data.offset += point.offset\n        isFindOffset = true\n      } else if (!isFindOffset) {\n        data.offset += text.length\n      }\n      data.text += text\n    }\n    return data\n  },\n\n  findPointOnLine(editor: Editor, path: Path, offset: number, moveNext: boolean = false) {\n    const blockEntry = Editor.above(editor, {\n      match: n => Editor.isBlock(editor, n),\n      at: path,\n    })\n    if (!blockEntry) {\n      throw new Error(`Cannot resolve a Editor block from a path: ${path}`)\n    }\n    const textNodes = Node.texts(blockEntry[0])\n    let findOffset = 0\n    for (const [textNode, textPath] of textNodes) {\n      let { text } = textNode\n      const path = blockEntry[1].concat(textPath)\n      const [parent, parentPath] = Editor.parent(editor, path)\n      const isVoid = parent && Editor.isVoid(editor, parent)\n      if (isVoid) {\n        text = ' '\n      }\n      const textLength = text.length\n      const totalOffset = findOffset + textLength\n      if (totalOffset >= offset) {\n        if (moveNext && offset > 0 && totalOffset === offset) {\n          const next = Editor.next(editor, {\n            at: isVoid ? parentPath : path,\n          })\n          if (next) {\n            return {\n              path: next[1],\n              offset: 0,\n            }\n          }\n        }\n        return { path, offset: textLength - (totalOffset - offset) }\n      } else {\n        findOffset += textLength\n      }\n    }\n    return { path, offset }\n  },\n\n  /**\n   * Find a Editor point from a DOM selection's `offsetNode` and `domOffset`.\n   */\n  toEditorPoint<T extends boolean>(\n    editor: Editor,\n    domPoint: DOMPoint,\n    options: {\n      exactMatch: T\n      suppressThrow: T\n    },\n  ): T extends true ? Point | null : Point {\n    const { exactMatch, suppressThrow } = options\n    const [nearestNode, nearestOffset] = exactMatch ? domPoint : normalizeDOMPoint(domPoint)\n    const parentNode = nearestNode.parentNode as DOMElement\n    let textNode: DOMElement | null = null\n    let offset = 0\n\n    if (parentNode) {\n      const editorEl = Editable.toDOMNode(editor, editor)\n      const potentialVoidNode = parentNode.closest(`[${DATA_EDITABLE_VOID}]`)\n      // Need to ensure that the closest void node is actually a void node\n      // within this editor, and not a void node within some parent editor. This can happen\n      // if this editor is within a void node of another editor (\"nested editors\", like in\n      // the \"Editable Voids\" example on the docs site).\n      const voidNode =\n        potentialVoidNode && editorEl.contains(potentialVoidNode) ? potentialVoidNode : null\n      let leafNode = parentNode.closest(`[${DATA_EDITABLE_LEAF}]`)\n      let offsetNode: DOMElement | null = null\n\n      // Calculate how far into the text node the `nearestNode` is, so that we\n      // can determine what the offset relative to the text node is.\n      if (leafNode) {\n        textNode = leafNode.closest(`[${DATA_EDITABLE_NODE}=\"text\"]`)\n\n        if (textNode) {\n          const window = Editable.getWindow(editor)\n          const range = window.document.createRange()\n          range.setStart(textNode, 0)\n          range.setEnd(nearestNode, nearestOffset)\n\n          const contents = range.cloneContents()\n          const removals = [\n            ...Array.prototype.slice.call(\n              contents.querySelectorAll(`[${DATA_EDITABLE_ZERO_WIDTH}]`),\n            ),\n          ]\n\n          removals.forEach(el => {\n            el!.parentNode!.removeChild(el)\n          })\n\n          // COMPAT: Edge has a bug where Range.prototype.toString() will\n          // convert \\n into \\r\\n. The bug causes a loop when slate-react\n          // attempts to reposition its cursor to match the native position. Use\n          // textContent.length instead.\n          // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\n          offset = contents.textContent!.length\n          offsetNode = textNode\n        }\n      } else if (voidNode) {\n        // For void nodes, the element with the offset key will be a cousin, not an\n        // ancestor, so find it by going down from the nearest void parent.\n        leafNode = voidNode.querySelector(`[${DATA_EDITABLE_LEAF}]`)!\n\n        // COMPAT: In read-only editors the leaf is not rendered.\n        if (!leafNode) {\n          offset = 1\n        } else {\n          textNode = leafNode.closest(`[${DATA_EDITABLE_NODE}=\"text\"]`)!\n          offsetNode = leafNode\n          offset = offsetNode.textContent!.length\n          offsetNode.querySelectorAll(`[${DATA_EDITABLE_ZERO_WIDTH}]`).forEach(el => {\n            offset -= el.textContent!.length\n          })\n        }\n      }\n\n      if (\n        offsetNode &&\n        offset === offsetNode.textContent!.length &&\n        // COMPAT: If the parent node is a Editor zero-width space, editor is\n        // because the text node should have no characters. However, during IME\n        // composition the ASCII characters will be prepended to the zero-width\n        // space, so subtract 1 from the offset to account for the zero-width\n        // space character.\n        (parentNode.hasAttribute(DATA_EDITABLE_ZERO_WIDTH) ||\n          // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\\n'\n          // when the document ends with a new-line character. This results in the offset\n          // length being off by one, so we need to subtract one to account for this.\n          (IS_FIREFOX && offsetNode.textContent?.endsWith('\\n\\n')))\n      ) {\n        offset--\n      }\n    }\n\n    if (!textNode) {\n      if (suppressThrow) {\n        return null as T extends true ? Point | null : Point\n      }\n      throw new Error(`Cannot resolve a Editor point from DOM point: ${domPoint}`)\n    }\n\n    // COMPAT: If someone is clicking from one Editor editor into another,\n    // the select event fires twice, once for the old editor's `element`\n    // first, and then afterwards for the correct `element`. (2017/03/03)\n    const editorNode = Editable.toEditorNode(editor, textNode!)\n    const path = Editable.findPath(editor, editorNode)\n    return { path, offset } as T extends true ? Point | null : Point\n  },\n\n  /**\n   * Find a Editor range from a DOM range or selection.\n   */\n  toEditorRange<T extends boolean>(\n    editor: Editor,\n    domRange: DOMRange | DOMStaticRange | DOMSelection,\n    options: {\n      exactMatch: T\n      suppressThrow: T\n    },\n  ): T extends true ? Range | null : Range {\n    const { exactMatch, suppressThrow } = options\n    const el = isDOMSelection(domRange) ? domRange.anchorNode : domRange.startContainer\n    let anchorNode\n    let anchorOffset\n    let focusNode\n    let focusOffset\n    let isCollapsed\n\n    if (el) {\n      if (isDOMSelection(domRange)) {\n        anchorNode = domRange.anchorNode\n        anchorOffset = domRange.anchorOffset\n        focusNode = domRange.focusNode\n        focusOffset = domRange.focusOffset\n        // COMPAT: There's a bug in chrome that always returns `true` for\n        // `isCollapsed` for a Selection that comes from a ShadowRoot.\n        // (2020/08/08)\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n        if (IS_CHROME && hasShadowRoot()) {\n          isCollapsed =\n            domRange.anchorNode === domRange.focusNode &&\n            domRange.anchorOffset === domRange.focusOffset\n        } else {\n          isCollapsed = domRange.isCollapsed\n        }\n      } else {\n        anchorNode = domRange.startContainer\n        anchorOffset = domRange.startOffset\n        focusNode = domRange.endContainer\n        focusOffset = domRange.endOffset\n        isCollapsed = domRange.collapsed\n      }\n    }\n\n    if (anchorNode == null || focusNode == null || anchorOffset == null || focusOffset == null) {\n      throw new Error(`Cannot resolve a Editor range from DOM range: ${domRange}`)\n    }\n\n    const anchor = Editable.toEditorPoint(editor, [anchorNode, anchorOffset], {\n      exactMatch,\n      suppressThrow,\n    })\n    if (!anchor) {\n      return null as T extends true ? Range | null : Range\n    }\n\n    const focus = isCollapsed\n      ? anchor\n      : Editable.toEditorPoint(editor, [focusNode, focusOffset], {\n          exactMatch,\n          suppressThrow,\n        })\n    if (!focus) {\n      return null as T extends true ? Range | null : Range\n    }\n\n    let range: Range = { anchor: anchor as Point, focus: focus as Point }\n    // if the selection is a hanging range that ends in a void\n    // and the DOM focus is an Element\n    // (meaning that the selection ends before the element)\n    // unhang the range to avoid mistakenly including the void\n    if (\n      Range.isExpanded(range) &&\n      Range.isForward(range) &&\n      isDOMElement(focusNode) &&\n      Editor.void(editor, { at: range.focus, mode: 'highest' })\n    ) {\n      range = Editor.unhangRange(editor, range, { voids: true })\n    }\n\n    return range as unknown as T extends true ? Range | null : Range\n  },\n\n  toRelativePosition(editor: Editor, x: number, y: number): [number, number] {\n    const container = Editable.toDOMNode(editor, editor)\n    const rootRect = container.getBoundingClientRect()\n\n    return [x - rootRect.left, y - rootRect.top]\n  },\n\n  reverseRelativePosition(editor: Editor, x: number, y: number): [number, number] {\n    const container = Editable.toDOMNode(editor, editor)\n    const rootRect = container.getBoundingClientRect()\n    return [x + rootRect.left, y + rootRect.top]\n  },\n\n  scrollIntoView(editor: Editor, range = editor.selection) {\n    if (!range) return\n    const domRange = Editable.toDOMRange(editor, range)\n    const focusEl = domRange.endContainer.parentElement!\n    scrollIntoView(focusEl, {\n      scrollMode: 'if-needed',\n    })\n  },\n}\n","import { Ancestor, Editor, Node, Key } from '@editablejs/models'\n\n/**\n * Two weak maps that allow us rebuild a path given a node. They are populated\n * at render time such that after a render occurs we can always backtrack.\n */\n\nexport const NODE_TO_INDEX: WeakMap<Node, number> = new WeakMap()\nexport const NODE_TO_PARENT: WeakMap<Node, Ancestor> = new WeakMap()\n\n/**\n * Weak maps that allow us to go between Slate nodes and DOM nodes. These\n * are used to resolve DOM event-related logic into Slate actions.\n */\nexport const EDITOR_TO_WINDOW: WeakMap<Editor, Window> = new WeakMap()\nexport const EDITOR_TO_ELEMENT: WeakMap<Editor, HTMLElement> = new WeakMap()\nexport const EDITOR_TO_INPUT: WeakMap<Editor, HTMLTextAreaElement> = new WeakMap()\nexport const EDITOR_TO_SHADOW: WeakMap<Editor, ShadowRoot | null> = new WeakMap()\nexport const ELEMENT_TO_NODE: WeakMap<HTMLElement, Node> = new WeakMap()\nexport const NODE_TO_ELEMENT: WeakMap<Node, HTMLElement> = new WeakMap()\nexport const NODE_TO_KEY: WeakMap<Node, Key> = new WeakMap()\nexport const EDITOR_TO_KEY_TO_ELEMENT: WeakMap<Editor, WeakMap<Key, HTMLElement>> = new WeakMap()\nexport const EDITOR_TO_SELECTION_RECTS = new WeakMap<Editor, DOMRect[]>()\n\n/**\n * Weak maps for storing editor-related state.\n */\nexport const IS_CLICKING: WeakMap<Editor, boolean> = new WeakMap()\nexport const IS_COMPOSING: WeakMap<Editor, boolean> = new WeakMap()\nexport const IS_ON_COMPOSITION_END: WeakMap<Editor, boolean> = new WeakMap()\nexport const IS_SHIFT_PRESSED: WeakMap<Editor, boolean> = new WeakMap()\nexport const IS_MOUSEDOWN: WeakMap<Editor, boolean> = new WeakMap()\nexport const IS_TOUCHMOVING: WeakMap<Editor, boolean> = new WeakMap()\nexport const IS_TOUCHING: WeakMap<Editor, boolean> = new WeakMap()\nexport const IS_TOUCH_HOLD: WeakMap<Editor, boolean> = new WeakMap()\n/**\n * Weak map for associating the context `onChange` context with the plugin.\n */\nexport const NODE_TO_RESTORE_DOM = new WeakMap<Node, () => void>()\n\nexport const IS_PASTE_TEXT: WeakMap<Editor, boolean> = new WeakMap()\n","// COMPAT: This is required to prevent TypeScript aliases from doing some very\n// weird things for Slate's types with the same name as globals. (2019/11/27)\nimport {\n  DOMPoint,\n  isDOMElement,\n  DOMElement,\n  DOMNode,\n  isDOMComment,\n  isDOMHTMLElement,\n} from '@editablejs/models'\nimport { Constants } from './constants'\nimport { CAN_USE_DOM } from './environment'\n\n/**\n * Normalize a DOM point so that it always refers to a text node.\n */\n\nexport const normalizeDOMPoint = (domPoint: DOMPoint): DOMPoint => {\n  let [node, offset] = domPoint\n\n  // If it's an element node, its offset refers to the index of its children\n  // including comment nodes, so try to find the right text child node.\n  if (isDOMElement(node) && node.childNodes.length) {\n    let isLast = offset === node.childNodes.length\n    let index = isLast ? offset - 1 : offset\n    ;[node, index] = getEditableChildAndIndex(node, index, isLast ? 'backward' : 'forward')\n    // If the editable child found is in front of input offset, we instead seek to its end\n    isLast = index < offset\n\n    // If the node has children, traverse until we have a leaf node. Leaf nodes\n    // can be either text nodes, or other void DOM nodes.\n    while (isDOMElement(node) && node.childNodes.length) {\n      const i = isLast ? node.childNodes.length - 1 : 0\n      node = getEditableChild(node, i, isLast ? 'backward' : 'forward')\n    }\n\n    // Determine the new offset inside the text node.\n    offset = isLast && node.textContent != null ? node.textContent.length : 0\n  }\n\n  // Return the node and offset.\n  return [node, offset]\n}\n\n/**\n * Determines wether the active element is nested within a shadowRoot\n */\n\nexport const hasShadowRoot = () => {\n  return !!(window.document.activeElement && window.document.activeElement.shadowRoot)\n}\n\n/**\n * Get the nearest editable child and index at `index` in a `parent`, preferring\n * `direction`.\n */\n\nexport const getEditableChildAndIndex = (\n  parent: DOMElement,\n  index: number,\n  direction: 'forward' | 'backward',\n): [DOMNode, number] => {\n  const { childNodes } = parent\n  let child = childNodes[index]\n  let i = index\n  let triedForward = false\n  let triedBackward = false\n\n  // While the child is a comment node, or an element node with no children,\n  // keep iterating to find a sibling non-void, non-comment node.\n  while (isDOMComment(child) || (isDOMElement(child) && child.childNodes.length === 0)) {\n    if (triedForward && triedBackward) {\n      break\n    }\n\n    if (i >= childNodes.length) {\n      triedForward = true\n      i = index - 1\n      direction = 'backward'\n      continue\n    }\n\n    if (i < 0) {\n      triedBackward = true\n      i = index + 1\n      direction = 'forward'\n      continue\n    }\n\n    child = childNodes[i]\n    index = i\n    i += direction === 'forward' ? 1 : -1\n  }\n\n  return [child, index]\n}\n\n/**\n * Get the nearest editable child at `index` in a `parent`, preferring\n * `direction`.\n */\n\nexport const getEditableChild = (\n  parent: DOMElement,\n  index: number,\n  direction: 'forward' | 'backward',\n): DOMNode => {\n  const [child] = getEditableChildAndIndex(parent, index, direction)\n  return child\n}\n\nexport const isEditableDOMElement = (value: any): boolean => {\n  if (isDOMHTMLElement(value)) {\n    return ['INPUT', 'TEXTAREA'].indexOf(value.nodeName) > -1 || value.isContentEditable\n  }\n  return false\n}\n\nexport const canForceTakeFocus = () => {\n  if (!CAN_USE_DOM) return true\n  const activeElement = document.activeElement\n  if (isEditableDOMElement(activeElement)) return false\n  return true\n}\n\nexport const inAbsoluteDOMElement = (value: any): boolean => {\n  if (isDOMHTMLElement(value)) {\n    let node: HTMLElement | null = value\n    while (node) {\n      const attributeNames = node.getAttributeNames()\n      if (attributeNames.some(name => Constants.dataNode === name)) return false\n      const styles = getComputedStyle(node)\n      if (~['absolute', 'fixed'].indexOf(styles.position)) {\n        return true\n      }\n      node = node.parentElement\n    }\n  }\n  return false\n}\n","import * as React from 'react'\n\nexport const IS_REACT_VERSION_17_OR_ABOVE = parseInt(React.version.split('.')[0], 10) >= 17\n\nexport const IS_IOS =\n  typeof navigator !== 'undefined' &&\n  typeof window !== 'undefined' &&\n  /iPad|iPhone|iPod/.test(navigator.userAgent) &&\n  !(window as any).MSStream\n\nexport const IS_APPLE = typeof navigator !== 'undefined' && /Mac OS X/.test(navigator.userAgent)\n\nexport const IS_FIREFOX =\n  typeof navigator !== 'undefined' && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent)\n\nexport const IS_SAFARI =\n  typeof navigator !== 'undefined' && /Version\\/[\\d\\.]+.*Safari/.test(navigator.userAgent)\n\n// \"modern\" Edge was released at 79.x\nexport const IS_EDGE_LEGACY =\n  typeof navigator !== 'undefined' &&\n  /Edge?\\/(?:[0-6][0-9]|[0-7][0-8])(?:\\.)/i.test(navigator.userAgent)\n\nexport const IS_CHROME = typeof navigator !== 'undefined' && /Chrome/i.test(navigator.userAgent)\n\n// Native `beforeInput` events don't work well with react on Chrome 75\n// and older, Chrome 76+ can use `beforeInput` though.\nexport const IS_CHROME_LEGACY =\n  typeof navigator !== 'undefined' &&\n  /Chrome?\\/(?:[0-7][0-5]|[0-6][0-9])(?:\\.)/i.test(navigator.userAgent)\n\n// Firefox did not support `beforeInput` until `v87`.\nexport const IS_FIREFOX_LEGACY =\n  typeof navigator !== 'undefined' &&\n  /^(?!.*Seamonkey)(?=.*Firefox\\/(?:[0-7][0-9]|[0-8][0-6])(?:\\.)).*/i.test(navigator.userAgent)\n\n// qq browser\nexport const IS_QQBROWSER =\n  typeof navigator !== 'undefined' && /.*QQBrowser/.test(navigator.userAgent)\n\n// UC mobile browser\nexport const IS_UC_MOBILE =\n  typeof navigator !== 'undefined' && /.*UCBrowser/.test(navigator.userAgent)\n\n// Wechat browser\nexport const IS_WECHATBROWSER =\n  typeof navigator !== 'undefined' && /.*Wechat/.test(navigator.userAgent)\n\n// Check if DOM is available as React does internally.\n// https://github.com/facebook/react/blob/master/packages/shared/ExecutionEnvironment.js\nexport const CAN_USE_DOM = !!(\n  typeof window !== 'undefined' &&\n  typeof window.document !== 'undefined' &&\n  typeof window.document.createElement !== 'undefined'\n)\n\n// COMPAT: Firefox/Edge Legacy don't support the `beforeinput` event\n// Chrome Legacy doesn't support `beforeinput` correctly\nexport const HAS_BEFORE_INPUT_SUPPORT =\n  !IS_CHROME_LEGACY &&\n  !IS_EDGE_LEGACY &&\n  // globalThis is undefined in older browsers\n  typeof globalThis !== 'undefined' &&\n  globalThis.InputEvent &&\n  // @ts-ignore The `getTargetRanges` property isn't recognized.\n  typeof globalThis.InputEvent.prototype.getTargetRanges === 'function'\n\n/**\n * Touch devices\n */\nexport const isTouchDevice = CAN_USE_DOM && 'ontouchstart' in document.documentElement\n","interface NearbyNode {\n  node: Element\n  rect: DOMRect\n}\n\n/**\n * 是否在一个节点前面\n * @param rect\n * @param node\n * @param otherNode\n * @returns\n */\nexport const isPrecedingY = (rect: DOMRect, node: Node, other: NearbyNode) => {\n  return (\n    rect.bottom > other.rect.bottom ||\n    (rect.top === other.rect.bottom &&\n      node.compareDocumentPosition(other.node) === Node.DOCUMENT_POSITION_PRECEDING)\n  )\n}\n\nexport const isFollowingY = (rect: DOMRect, node: Node, other: NearbyNode) => {\n  return (\n    rect.top < other.rect.top ||\n    (rect.top === other.rect.top &&\n      node.compareDocumentPosition(other.node) === Node.DOCUMENT_POSITION_FOLLOWING)\n  )\n}\n\nexport const isPrecedingX = (rect: DOMRect, node: Node, other: NearbyNode) => {\n  return (\n    rect.right > other.rect.right ||\n    (rect.right === other.rect.right &&\n      node.compareDocumentPosition(other.node) === Node.DOCUMENT_POSITION_PRECEDING)\n  )\n}\n\nexport const isFollowingX = (rect: DOMRect, node: Node, other: NearbyNode) => {\n  return (\n    rect.left < other.rect.left ||\n    (rect.left === other.rect.left &&\n      node.compareDocumentPosition(other.node) === Node.DOCUMENT_POSITION_FOLLOWING)\n  )\n}\n\n/**\n * 是否垂直对齐\n * @param rect\n * @param other\n * @param scale\n * @returns\n */\nexport const isAlignY = (rect: DOMRect, other: DOMRect, scale = 0.4) => {\n  if (rect.bottom === other.bottom) return true\n  // 未在水平上\n  if (rect.top > other.bottom || other.top > rect.bottom) return false\n  const minHeight = Math.min(other.height, rect.height)\n  const innerHeight = Math.min(rect.bottom, other.bottom) - Math.max(rect.top, other.top)\n  // 超过多少比例在水平上\n  return 0 === minHeight || innerHeight / minHeight > scale\n}\n\n/**\n * 判断 x 在 rect 中是否处于 left 与 right 之间\n * @param x\n * @param rect\n * @returns\n */\nexport const isBetweenX = (x: number, rect: DOMRect) => {\n  return x >= rect.left && x <= rect.right\n}\n\n/**\n * 判断 y 在 rect 中是否处于 top 与 bottom 之间\n * @param y\n * @param rect\n * @returns\n */\nexport const isBetweenY = (y: number, rect: DOMRect) => {\n  return y >= rect.top && y <= rect.bottom\n}\n\n/**\n * 获取 x 在 rect 中 left 与 right 之间最小的距离\n * @param x\n * @param rect\n * @returns\n */\nexport const getMinXInRect = (x: number, rect: DOMRect) => {\n  return Math.min(Math.abs(x - rect.left), Math.abs(x - rect.right))\n}\n\nexport const onNearbyY = (\n  x: number,\n  rect: DOMRect,\n  node: Node,\n  nearbyNode: NearbyNode,\n  preceding = true,\n) => {\n  if (isAlignY(rect, nearbyNode.rect)) {\n    const topBetween = isBetweenX(x, nearbyNode.rect)\n    const isBetween = isBetweenX(x, rect)\n    const topMin = getMinXInRect(x, nearbyNode.rect)\n    const min = getMinXInRect(x, rect)\n    if (!topBetween && (isBetween || min < topMin)) {\n      return true\n    }\n    return false\n  } else if (preceding) {\n    return isPrecedingY(rect, node, nearbyNode)\n  } else {\n    return isFollowingY(rect, node, nearbyNode)\n  }\n}\n\ntype NearbyNodes = {\n  top: NearbyNode | null\n  below: NearbyNode | null\n  left: NearbyNode | null\n  right: NearbyNode | null\n}\n\n/**\n * 查找附近的节点\n * @param nodes\n * @param x\n * @param y\n * @returns\n */\nconst findNearbyNodes = (nodes: Element[], x: number, y: number): Element | NearbyNodes | null => {\n  const closerNode: NearbyNodes = {\n    top: null,\n    below: null,\n    left: null,\n    right: null,\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    const child = nodes[i]\n    const rects = child.getClientRects()\n    for (let r = 0; r < rects.length; r++) {\n      const rect = rects[r]\n      // 刚好在区域内\n      if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {\n        return child\n      }\n      // 点击位置在区域 top上方\n      else if (y < rect.top) {\n        if (!closerNode.below || onNearbyY(x, rect, child, closerNode.below, false)) {\n          closerNode.below = {\n            rect,\n            node: child,\n          }\n        }\n      }\n      // 点击区域在 bottom 上方\n      else if (y > rect.bottom) {\n        if (!closerNode.top || onNearbyY(x, rect, child, closerNode.top)) {\n          closerNode.top = {\n            rect,\n            node: child,\n          }\n        }\n        if (closerNode.left && isPrecedingX(rect, child, closerNode.left)) {\n          closerNode.left = {\n            rect,\n            node: child,\n          }\n        }\n      } else if (\n        isBetweenY(y, rect) &&\n        x > rect.left &&\n        (!closerNode.left || isPrecedingX(rect, child, closerNode.left))\n      ) {\n        closerNode.left = {\n          rect,\n          node: child,\n        }\n      } else if (\n        isBetweenY(y, rect) &&\n        x < rect.right &&\n        (!closerNode.right || isFollowingX(rect, child, closerNode.right))\n      ) {\n        closerNode.right = {\n          rect,\n          node: child,\n        }\n      }\n    }\n  }\n  return closerNode\n}\n\nexport default findNearbyNodes\n","import { nextBreak, previousBreak } from '@editablejs/breaker'\n\n/**\n * @zh-CN 获取字符串索引处的向前或向后字符\n * @param text 文本\n * @param offset 索引\n * @param backward 是否取向后的字符，默认 false\n * @returns 字符串索引处的上或下个字符\n */\nexport const getCharFromGraphemeBreaker = (text: string, offset: number, backward = false) => {\n  if (offset < 0 || offset > text.length) {\n    return ''\n  }\n  let value\n  if (backward) {\n    value = previousBreak(text, offset)\n    return text.substring(value, offset)\n  } else {\n    value = nextBreak(text, offset)\n    return text.substring(offset, value)\n  }\n}\n\n/**\n * 获取字符串索引处的向后的字符索引\n * @param text 文本\n * @param offset 索引\n * @returns 向后的字符索引\n */\nexport const getCharOffsetBackward = (text: string, offset: number) => {\n  return getCharFromGraphemeBreaker(text, offset, true).length || 1\n}\n\n/**\n * 获取字符串索引处的向前的字符索引\n * @param text 文本\n * @param offset 索引\n * @returns 向前的字符索引\n */\nexport const getCharOffsetForward = (text: string, offset: number) => {\n  return getCharFromGraphemeBreaker(text, offset).length || 1\n}\n\n/**\n * 字形断路器\n * 获取字符串中的字符范围，Unicode字符范围不确定（高代理、低代理、私有代理字符存在）\n * @param text 文本\n * @param offset 当前索引\n * @returns [start, end]\n */\nexport const getCharRange = (text: string, offset: number) => {\n  let i = 0\n  for (; i <= offset; ) {\n    const end = i + getCharOffsetForward(text, i)\n    if (end > offset) return [i, end]\n    i = end\n  }\n  return [i, i + Math.min(text.length, 1)]\n}\n\nconst isSpace = (char: string) => /\\s/.test(char)\n// http://www.unicode.org/charts/\nconst isIdeograph = (char: string) =>\n  /[\\u3040-\\u30ff\\u3400-\\u4dbf\\u4e00-\\u9fff\\uf900-\\ufaff\\uff66-\\uff9f\\u3131-\\uD79D]/.test(char)\n// http://www.unicode.org/charts/\n// https://zh.wikipedia.org/zh-cn/Unicode%E5%AD%97%E7%AC%A6%E5%88%97%E8%A1%A8\nconst isSpecialCharacters = (char: string) =>\n  /[\\u0021-\\u002F\\u003A-\\u0040\\u005B-\\u0060\\u007B-\\u007E\\u00A1-\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65\\uFFE5]/.test(\n    char,\n  )\n\nconst equalOfCharacterType = (char: string, other: string) => {\n  return (\n    !!char &&\n    !!other &&\n    !isSpace(char) &&\n    !isSpecialCharacters(char) &&\n    !isSpace(other) &&\n    !isSpecialCharacters(other) &&\n    isIdeograph(char) === isIdeograph(other)\n  )\n}\n\ninterface Segment {\n  segment: string\n  index: number\n  input: string\n  isWordLike: boolean\n}\n\ndeclare global {\n  interface Window {\n    Intl: {\n      Segmenter?: new (\n        locale?: string,\n        options?: { granularity: 'word' | 'sentence' | 'line' },\n      ) => {\n        segment: (text: string) => Iterable<Segment>\n      }\n    }\n  }\n}\n\nexport const splitTextOfWord = (text: string, callback?: (segments: Segment[]) => Segment) => {\n  // split word\n  const Segmenter = window.Intl.Segmenter\n  if (Segmenter && isIdeograph(text)) {\n    const segments: Segment[] = Array.from(\n      new Segmenter(undefined, { granularity: 'word' }).segment(text),\n    )\n    if (segments.length > 0) {\n      const { segment, index } = callback ? callback(segments) : segments[segments.length - 1]\n      return { text: segment, offset: index }\n    }\n  }\n  return { text, offset: 0 }\n}\n\nexport const getWordBackward = (text: string, offset: number) => {\n  let currentChar = getCharFromGraphemeBreaker(text, offset, true)\n  let backwardOffset = offset - 1\n  for (; backwardOffset >= 0; ) {\n    const backwardChar = getCharFromGraphemeBreaker(text, backwardOffset, true)\n    if (equalOfCharacterType(currentChar, backwardChar)) {\n      backwardOffset -= backwardChar.length\n    } else break\n  }\n  if (offset - backwardOffset > 1) {\n    const wordText = text.substring(backwardOffset, offset)\n    const { offset: wordOffset } = splitTextOfWord(wordText)\n    backwardOffset += wordOffset\n  }\n  return text.substring(backwardOffset < 0 ? 0 : backwardOffset, offset)\n}\n\nexport const getWordOffsetBackward = (text: string, offset: number) => {\n  return offset - getWordBackward(text, offset).length\n}\n\nexport const getWordForward = (text: string, offset: number) => {\n  let currentChar = getCharFromGraphemeBreaker(text, offset)\n  let forwardOffset = offset + 1\n  for (; forwardOffset < text.length; ) {\n    const forwardChar = getCharFromGraphemeBreaker(text, forwardOffset)\n    if (equalOfCharacterType(currentChar, forwardChar)) {\n      forwardOffset += forwardChar.length\n    } else break\n  }\n  if (forwardOffset - offset > 1) {\n    const newText = text.substring(offset, forwardOffset)\n    const { text: wordText, offset: wordOffset } = splitTextOfWord(newText, segments => segments[0])\n    forwardOffset = offset + wordOffset + wordText.length\n  }\n  return text.substring(offset, forwardOffset > text.length ? text.length : forwardOffset)\n}\n\nexport const getWordOffsetForward = (text: string, offset: number) => {\n  return offset + getWordForward(text, offset).length\n}\n\nexport const getWordRange = (text: string, offset: number) => {\n  if (!text) return [0, 0]\n  offset = Math.min(offset, text.length)\n\n  let previousChar = getCharFromGraphemeBreaker(text, offset, true)\n  let nextChar = getCharFromGraphemeBreaker(text, offset)\n\n  let backwardOffset = offset - 1\n  let forwardOffset = offset + 1\n  if (!nextChar) {\n    return [offset, offset]\n  }\n  if (previousChar && equalOfCharacterType(previousChar, nextChar)) {\n    for (; backwardOffset >= 0; ) {\n      const backwardChar = getCharFromGraphemeBreaker(text, backwardOffset, true)\n      if (equalOfCharacterType(previousChar, backwardChar)) {\n        backwardOffset -= backwardChar.length\n      } else break\n    }\n  } else {\n    backwardOffset = offset\n  }\n\n  for (; forwardOffset < text.length; ) {\n    const forwardChar = getCharFromGraphemeBreaker(text, forwardOffset)\n    if (equalOfCharacterType(nextChar, forwardChar)) {\n      forwardOffset += forwardChar.length\n    } else break\n  }\n  // split word\n  if (forwardOffset - backwardOffset > 1) {\n    const newText = text.substring(backwardOffset, forwardOffset)\n    const { text: wordText, offset: wordOffset } = splitTextOfWord(newText, segments => {\n      for (let i = segments.length - 1; i >= 0; i--) {\n        const segment = segments[i]\n        const wordStart = segment.index + backwardOffset\n        if (offset >= wordStart && offset < wordStart + segment.segment.length) {\n          return segment\n        }\n      }\n      return segments[0]\n    })\n    backwardOffset += wordOffset\n    forwardOffset = wordText.length + backwardOffset\n  }\n  return [backwardOffset, forwardOffset]\n}\n\n/**\n * @zh-CN 获取在Text节点处鼠标点击坐标时的字符索引\n * @param node Text Node\n * @param x\n * @param y\n * @param start\n * @param end\n * @param length\n * @returns\n *\n */\nexport const getTextOffset = (\n  node: Text,\n  x: number,\n  y: number,\n  start: number,\n  end: number,\n  length: number,\n): number => {\n  const range = document.createRange()\n  if (end - start > 1) {\n    const mid = Math.floor((start + end) / 2)\n    try {\n      range.setStart(node, mid)\n      range.setEnd(node, Math.max(Math.min(mid, length), 0))\n    } catch (e) {\n      return start\n    }\n    const rects = range.getClientRects()\n    if (rects.length === 0) {\n      return start\n    }\n    for (const rect of rects) {\n      if (y < rect.top) {\n        return getTextOffset(node, x, y, start, mid, length)\n      } else if (y > rect.bottom) {\n        return getTextOffset(node, x, y, mid, end, length)\n      } else if (x <= rect.left + rect.width) {\n        return getTextOffset(node, x, y, start, mid, length)\n      }\n    }\n    return getTextOffset(node, x, y, mid, end, length)\n  }\n  const [rStart, rEnd] = getCharRange(node.textContent || '', start)\n  try {\n    range.setStart(node, rStart)\n    range.setEnd(node, Math.max(Math.min(rEnd, length), 0))\n  } catch (err) {\n    return rStart\n  }\n  const rects = range.getClientRects()\n  if (rects.length === 0) return rStart\n\n  for (const rect of rects) {\n    if (rect.width === 0) continue\n    if (y < rect.top) {\n      return rStart\n    } else if (y > rect.bottom) {\n      return rEnd\n    } else if (x <= rect.left + rect.width / 2) {\n      return rStart\n    }\n  }\n  return rEnd\n}\n","import {\n  Editor,\n  Node,\n  Range,\n  Element,\n  NodeEntry,\n  Path,\n  DOMElement,\n  DOMRange,\n  isDOMElement,\n} from '@editablejs/models'\nimport { Editable } from '../plugin/editable'\nimport {\n  DATA_EDITABLE_COMPOSITION,\n  DATA_EDITABLE_NODE,\n  DATA_EDITABLE_STRING,\n  DATA_EDITABLE_ZERO_WIDTH,\n} from './constants'\n\ninterface LineRectangle {\n  top: number\n  height: number\n  bottom: number\n  left: number\n  right: number\n}\n\n/**\n * Splits the rectangles into lines based on their positions.\n * @param rects\n */\nconst splitRectsIntoLines = (rects: DOMRect[] | DOMRectList) => {\n  const lines: Map<LineRectangle, DOMRect[]> = new Map()\n  if (rects.length === 0) return lines\n\n  const lineKeys: LineRectangle[] = []\n\n  /**\n   * Finds the line that the rectangle belongs to.\n   * @param rect\n   */\n  const findLineKey = (rect: DOMRect) => {\n    for (const lineKey of lineKeys) {\n      const { right } = lineKey\n      const previousRects = lines.get(lineKey)\n      const lastRect = previousRects\n        ? previousRects\n            .concat()\n            .reverse()\n            .find(p => p.width > 0) ?? previousRects[previousRects.length - 1]\n        : null\n      if (isRectInLine(rect, lineKey) && rect.left <= (lastRect ? lastRect.right : right) + 1) {\n        return lineKey\n      }\n    }\n    return null\n  }\n\n  // Loop through each rectangle and find its line\n  for (let r = 0; r < rects.length; r++) {\n    const rect = rects[r]\n    const key = findLineKey(rect)\n    if (key) {\n      lines.get(key)?.push(rect)\n    } else {\n      const lineRect = {\n        top: rect.top,\n        height: rect.height,\n        bottom: rect.bottom,\n        left: rect.left,\n        right: rect.right,\n      }\n      lines.set(lineRect, [rect])\n      lineKeys.push(lineRect)\n    }\n  }\n\n  // Find the minimum top, maximum bottom, and maximum right for each line\n  for (const [line, rects] of lines) {\n    // If there's only one rectangle in the line, skip\n    if (rects.length === 1) continue\n\n    let minTop = line.top,\n      maxBottom = line.bottom,\n      maxRight = line.right\n\n    // Compare each rectangle\n    for (const rect of rects) {\n      const { top, bottom, right } = rect\n      if (top < minTop) minTop = top\n      if (bottom > maxBottom) maxBottom = bottom\n      if (right > maxRight && rect.width > 0) maxRight = right\n    }\n    line.top = minTop\n    line.bottom = maxBottom\n    line.right = maxRight\n  }\n  return lines\n}\n\n/**\n * Calculates the height of a node based on line height and font size\n * @param el The DOM element to calculate height for\n * @returns The calculated height\n */\nconst calculateElementHeight = (el: DOMElement) => {\n  const { lineHeight, fontSize } = window.getComputedStyle(el)\n\n  // TODO: Handle pt, em, rem units\n\n  let height = 0\n  // Ends with px\n  if (lineHeight.endsWith('px')) {\n    height = parseFloat(lineHeight)\n    return height\n  }\n  // Ends with %\n  else if (lineHeight.endsWith('%')) {\n    height = parseInt(lineHeight, 10) / 100\n  }\n  // Number\n  else if (/^\\d+(\\.\\d+)?$/.test(lineHeight)) {\n    height = parseFloat(lineHeight)\n  } else {\n    return el.getBoundingClientRect().height\n  }\n\n  let size = 0\n  if (fontSize.endsWith('px')) {\n    size = parseInt(fontSize, 10)\n  }\n\n  return height * size\n}\n\n/**\n * Resets the DOMRect of an element to the specified height\n * @param rect The DOMRect to reset\n * @param height The new height for the rect\n * @returns The reset DOMRect\n */\nconst resetElementRect = (rect: DOMRect, height: number) => {\n  const oldHeight = rect.height\n  if (oldHeight >= height) return rect\n  const top = rect.top + (oldHeight - height) / 2\n  return new DOMRect(rect.left, top, rect.width, height)\n}\n\n/**\n * Check if a given DOMRect intersects with a given line defined by its top, bottom, and height values\n * @param {DOMRect} rect - The DOMRect to check\n * @param {Object} line - An object with top, bottom, and height properties representing the line\n * @return {Boolean} - True if the rect intersects with the line, false otherwise\n */\nconst isRectInLine = (rect: DOMRect, line: Record<'top' | 'bottom' | 'height', number>) => {\n  const deltaEdge = rect.height / 3\n  return (\n    // Check if the rect is fully contained within the line\n    (rect.top >= line.top &&\n      (rect.bottom <= line.bottom ||\n        // Check if the top of the rect is in the line and the overflow of the bottom is within 2/3\n        rect.top + deltaEdge < line.bottom ||\n        // Check if the bottom of the rect is within 2/3 from the top of the line and the top of the rect is above the bottom of the line\n        (rect.top <= line.top + line.height / 3 && rect.bottom > line.top))) ||\n    // Check if the rect covers the height of the line and the line is within the top and bottom of the rect\n    (rect.top <= line.top &&\n      (rect.bottom >= line.bottom ||\n        // Check if the top of the rect is above or equal to the top of the line and the bottom of the rect is within 2/3 of the line\n        rect.bottom - deltaEdge > line.top)) ||\n    // Check if the bottom of the rect is within 2/3 from the bottom of the line and the top of the rect is above the bottom of the line\n    (rect.bottom <= line.bottom &&\n      rect.bottom >= line.bottom - line.height / 3 &&\n      rect.top < line.bottom)\n  )\n}\n/**\n * Find the maximum position in the line of the top position in the el node\n * @param editor - The Editor instance\n * @param element - The DOM element\n * @param top - The top position\n * @param bottom - The bottom position\n * @returns - Object containing the line rect information\n */\nconst matchHighest = (editor: Editor, element: DOMElement, top: number, bottom: number) => {\n  const lineRect = {\n    top,\n    height: bottom - top,\n    bottom,\n  }\n\n  /**\n   * Compare the height of the current rect with the line rect\n   * and update the line rect with the highest values\n   * @param rect - The current rect\n   */\n  const compareHeight = (rect: DOMRect) => {\n    if (isRectInLine(rect, lineRect)) {\n      const newTop = lineRect.top < rect.top ? lineRect.top : rect.top\n      const newBottom = lineRect.bottom > rect.bottom ? lineRect.bottom : rect.bottom\n      lineRect.height = newBottom - newTop\n      lineRect.top = newTop\n      lineRect.bottom = newBottom\n    }\n  }\n\n  /**\n   * Recursively find the child nodes of the element and compare their rects\n   * @param element - The DOM element\n   */\n  const match = (element: DOMElement) => {\n    for (const child of element.childNodes) {\n      if (isDOMElement(child)) {\n        const hasNode = child.hasAttribute(DATA_EDITABLE_NODE)\n        const node = hasNode ? Editable.toEditorNode(editor, child) : null\n        if (node) {\n          if (Element.isElement(node)) {\n            if (editor.isVoid(node)) {\n              const rect = resetElementRect(\n                child.getBoundingClientRect(),\n                calculateElementHeight(child),\n              )\n              compareHeight(rect)\n            } else if (editor.isInline(node)) {\n              const height = calculateElementHeight(child)\n              const rects = child.getClientRects()\n              for (let r = 0; r < rects.length; r++) {\n                const rect = resetElementRect(rects[r], height)\n                compareHeight(rect)\n              }\n            } else {\n              match(child)\n            }\n          } else {\n            const nodes = child.querySelectorAll(\n              `[${DATA_EDITABLE_STRING}], [${DATA_EDITABLE_COMPOSITION}], [${DATA_EDITABLE_ZERO_WIDTH}]`,\n            )\n            nodes.forEach(node => {\n              const height = calculateElementHeight(node)\n              const rects = node.getClientRects()\n              for (let r = 0; r < rects.length; r++) {\n                const rect = resetElementRect(rects[r], height)\n                compareHeight(rect)\n              }\n            })\n          }\n        } else {\n          match(child)\n        }\n      }\n    }\n  }\n\n  match(element)\n  return lineRect\n}\n/**\n * Get the line rectangles of a given node in an editor.\n * @param editor The editor instance.\n * @param node The node to get line rectangles of.\n * @param minWidth The minimum width of the line rectangles. Default value is 4.\n * @returns An array of DOMRect objects representing the line rectangles.\n */\nexport const getLineRectsByNode = (editor: Editor, node: Node, minWidth = 4) => {\n  const path = Editable.findPath(editor, node)\n  const block: NodeEntry | undefined =\n    Editor.isBlock(editor, node) && path.length === 1\n      ? [node, path]\n      : Editor.above<Element>(editor, {\n          at: path,\n          match: n => Editor.isBlock(editor, n),\n          mode: 'highest',\n        })\n  if (!block) return []\n  const domEl = Editable.toDOMNode(editor, block[0])\n  const domRect = domEl.getBoundingClientRect()\n  const range = document.createRange()\n  range.selectNodeContents(Editable.toDOMNode(editor, node))\n  const lines = splitRectsIntoLines(range.getClientRects())\n  const lineRects: DOMRect[] = []\n  for (const [line, rects] of lines) {\n    let width = line.right - line.left\n    const lineRect = matchHighest(editor, domEl, line.top, line.bottom)\n    line.top = lineRect.top\n    line.height = lineRect.height\n    line.bottom = lineRect.bottom\n    // 空节点的宽度给个最小值\n    if (width < 1 && domRect.left === rects[0].left) {\n      width = minWidth\n    }\n    lineRects.push(new DOMRect(rects[0].left, line.top, width, line.height))\n  }\n  return lineRects\n}\n\n/**\n * Get DOMRect objects split by line within range\n * @param editor\n * @param range\n * @param minWidth minimum width of empty node, default to 4\n * @returns array of DOMRect objects\n */\nexport const getLineRectsByRange = (editor: Editor, range: Range, minWidth = 4) => {\n  const anchor = Range.start(range)\n  const focus = Range.end(range)\n  // 开始位置的 block节点\n  const anchorEntry = Editor.above<Element>(editor, {\n    at: anchor,\n    match: n => Editor.isBlock(editor, n),\n    mode: 'lowest',\n  })\n  // 结束位置的 block 节点\n  const focusEntry = Editor.above<Element>(editor, {\n    at: focus,\n    match: n => Editor.isBlock(editor, n),\n    mode: 'lowest',\n  })\n  if (!anchorEntry || !focusEntry) return []\n\n  const blockRects: DOMRect[] = []\n  const rectMap: Map<\n    DOMRect,\n    {\n      dom: DOMElement\n      element: Element\n    }\n  > = new Map()\n\n  let [startBlock, startPath] = anchorEntry\n  let [_, endPath] = focusEntry\n  const ranges: DOMRange[] = []\n  let isStart = true\n  let next: NodeEntry<Element> | undefined = anchorEntry\n  while (next) {\n    const [nextBlock, nextPath] = next as NodeEntry<Element>\n    const element = Editable.toDOMNode(editor, nextBlock)\n    const rect = element.getBoundingClientRect()\n    rectMap.set(rect, {\n      dom: element,\n      element: nextBlock,\n    })\n    blockRects.push(rect)\n\n    if (Path.equals(nextPath, endPath)) break\n    if (!isStart) {\n      const range = document.createRange()\n      range.selectNodeContents(element)\n      ranges.push(range)\n    } else {\n      isStart = false\n    }\n    next = Editor.next<Element>(editor, {\n      at: nextPath,\n      match: n => Editor.isBlock(editor, n),\n    })\n  }\n  if (Path.equals(startPath, endPath)) {\n    ranges.unshift(Editable.toDOMRange(editor, range))\n  } else {\n    ranges.unshift(\n      Editable.toDOMRange(editor, {\n        anchor,\n        focus: Editor.end(editor, {\n          path: startPath,\n          offset: startBlock.children.length,\n        }),\n      }),\n    )\n    ranges.push(\n      Editable.toDOMRange(editor, {\n        anchor: Editor.start(editor, {\n          path: endPath,\n          offset: 0,\n        }),\n        focus,\n      }),\n    )\n  }\n\n  // 拆分的行\n  const rects: DOMRect[] = []\n  for (const range of ranges) {\n    rects.push(...range.getClientRects())\n  }\n  const lines = splitRectsIntoLines(rects)\n  const lineRects: DOMRect[] = []\n  let prevLineRect: DOMRect | null = null\n  for (const [line, rects] of lines) {\n    // 找到对应行所在的 element\n    const blockRect = blockRects.find(\n      r =>\n        isRectInLine(r, line) &&\n        (line.left >= r.left || Math.abs(line.left - r.left) < 1) &&\n        (line.right <= r.right || Math.abs(line.right - r.right) < 1),\n    )\n    const block = blockRect ? rectMap.get(blockRect) : null\n\n    let width = line.right - line.left\n    if (block) {\n      const { dom, element } = block\n      const lineRect = matchHighest(editor, dom, line.top, line.bottom)\n      line.top = lineRect.top\n      line.height = lineRect.height\n      // 空节点的宽度给个最小值\n      if (\n        dom &&\n        Editor.isEmpty(editor, element) &&\n        width < 1 &&\n        dom.getBoundingClientRect().left === line.left\n      ) {\n        width = minWidth\n      }\n    }\n    // 去除行与行直接多余覆盖部分\n    if (prevLineRect && prevLineRect.bottom > line.top) {\n      const diffVal = prevLineRect.bottom - line.top\n      line.top += diffVal\n      line.height -= diffVal\n    }\n    const lineRect = new DOMRect(rects[0].left, line.top, width, line.height)\n\n    prevLineRect = lineRect\n    lineRects.push(lineRect)\n  }\n  return lineRects\n}\n","import { Editor } from '@editablejs/models'\nimport create, { StoreApi, UseBoundStore, useStore } from 'zustand'\nimport { Editable } from '../plugin/editable'\nimport { useEditableStatic } from './use-editable'\n\ninterface FocusedStore {\n  isFocused: boolean\n}\n\nconst EDITABLE_TO_FOCUSED_STORE = new WeakMap<Editor, UseBoundStore<StoreApi<FocusedStore>>>()\n\nconst getStore = (editor: Editor) => {\n  let store = EDITABLE_TO_FOCUSED_STORE.get(editor)\n  if (!store) {\n    store = create<FocusedStore>(() => ({\n      isFocused: false,\n    }))\n    EDITABLE_TO_FOCUSED_STORE.set(editor, store)\n    store.subscribe(({ isFocused }) => {\n      if (!Editable.isEditor(editor)) return\n\n      if (isFocused) {\n        editor.onFocus()\n      } else {\n        editor.onBlur()\n      }\n    })\n  }\n\n  return store\n}\n\nexport const useFocused = (): [boolean, (isFocused: boolean) => void] => {\n  const editor = useEditableStatic()\n  const store = getStore(editor)\n  const isFocused = useStore(store, state => state.isFocused)\n\n  return [\n    isFocused,\n    (isFocused: boolean) => {\n      store.setState({ isFocused })\n    },\n  ]\n}\n\nexport const Focused = {\n  is: (editor: Editor) => {\n    const store = getStore(editor)\n    return store.getState().isFocused\n  },\n}\n","export const composeEventHandlers = <E>(\n  originalEventHandler?: (event: E) => void,\n  ourEventHandler?: (event: E) => void,\n  { checkForDefaultPrevented = true } = {},\n) => {\n  return function handleEvent(event: E) {\n    originalEventHandler?.(event)\n\n    if (checkForDefaultPrevented === false || !(event as unknown as Event).defaultPrevented) {\n      return ourEventHandler?.(event)\n    }\n  }\n}\n\nexport const isTouchEvent = (event: any): event is TouchEvent => {\n  return typeof window.TouchEvent !== 'undefined' && event instanceof TouchEvent\n}\n\nexport const isTouch = (event: any): event is Touch => {\n  return typeof window.Touch !== 'undefined' && event instanceof Touch\n}\n\nexport const isMouseEvent = (event: any): event is MouseEvent => {\n  return event instanceof MouseEvent\n}\n\nexport const getNativeEvent = (event: any) => {\n  const { nativeEvent } = event\n  event = nativeEvent ?? event\n  if (isTouchEvent(event)) {\n    return event.touches[0] || event.changedTouches[0]\n  }\n  return event\n}\n","import { Editor } from '@editablejs/models'\nimport create, { StoreApi, UseBoundStore, useStore } from 'zustand'\nimport { useEditableStatic } from './use-editable'\n\ninterface ReadOnlyStore {\n  isReadOnly: boolean\n}\n\nconst EDITABLE_TO_FOCUSED_STORE = new WeakMap<Editor, UseBoundStore<StoreApi<ReadOnlyStore>>>()\n\nconst getStore = (editor: Editor) => {\n  let store = EDITABLE_TO_FOCUSED_STORE.get(editor)\n  if (!store) {\n    store = create<ReadOnlyStore>(() => ({\n      isReadOnly: false,\n    }))\n    EDITABLE_TO_FOCUSED_STORE.set(editor, store)\n  }\n\n  return store\n}\n\nexport const useReadOnly = (): [boolean, (isReadOnly: boolean) => void] => {\n  const editor = useEditableStatic()\n  const store = getStore(editor)\n  const isReadOnly = useStore(store, state => state.isReadOnly)\n\n  return [\n    isReadOnly,\n    (isReadOnly: boolean) => {\n      store.setState({ isReadOnly })\n    },\n  ]\n}\n\nexport const ReadOnly = {\n  is: (editor: Editor) => {\n    const store = getStore(editor)\n    return store.getState().isReadOnly\n  },\n}\n","import * as React from 'react'\nimport { CAN_USE_DOM } from '../utils/environment'\n\n/**\n * Prevent warning on SSR by falling back to useEffect when DOM isn't available\n */\n\nexport const useIsomorphicLayoutEffect = CAN_USE_DOM ? React.useLayoutEffect : React.useEffect\n","import * as React from 'react'\nimport { Text, Path, Range, Element } from '@editablejs/models'\nimport { useStore } from 'zustand'\nimport { Decorate, ElementDecorate, getDecorateStore, TextDecorate } from '../plugin/decorate'\nimport { useEditableStatic } from './use-editable'\n\nexport const useDecorateStore = () => {\n  const editor = useEditableStatic()\n  return React.useMemo(() => {\n    return getDecorateStore(editor)\n  }, [editor])\n}\n\nexport const useTextDecorations = (text: Text, path: Path) => {\n  const store = useDecorateStore()\n  const decorations = useStore(store, state => state.decorations)\n  return React.useMemo(() => {\n    return decorations.reduce<{ decorate: TextDecorate; ranges: Range[] }[]>((acc, decorate) => {\n      if (!Decorate.isTextDecorate(decorate)) return acc\n      const ranges = decorate.match(text, path)\n      if (ranges.length > 0) {\n        acc.push({ decorate, ranges })\n      }\n      return acc\n    }, [])\n  }, [decorations, text, path])\n}\n\nexport const useElementDecorations = (element: Element, path: Path) => {\n  const store = useDecorateStore()\n  const decorations = useStore(store, state => state.decorations)\n  return React.useMemo(() => {\n    return decorations.reduce<ElementDecorate[]>((acc, decorate) => {\n      if (Decorate.isTextDecorate(decorate)) return acc\n      if (decorate.match(element, path)) {\n        acc.push(decorate)\n      }\n      return acc\n    }, [])\n  }, [decorations, element, path])\n}\n","// Import necessary dependencies and models from @editablejs\nimport * as React from 'react'\nimport { Editor, Range, Node, Path, Text, Element } from '@editablejs/models'\n\n// Import the create and StoreApi from zustand\nimport create, { StoreApi, UseBoundStore } from 'zustand'\n\n// Define interface for properties passed to the render function of a text decoration\nexport interface DecorateRenderProps<T = Node> {\n  node: T\n  path: Path\n  children: React.ReactElement\n}\n\n// Define BaseDecorate interface with a key property that is optional\nexport interface BaseDecorate {\n  key?: string\n}\n\n// Define TextDecorate interface with match and renderText functions\nexport interface TextDecorate extends BaseDecorate {\n  match: (node: Text, path: Path) => Range[]\n  renderText: (props: DecorateRenderProps<Text>) => React.ReactElement\n}\n\n// Define ElementDecorate interface with match and renderElement functions\nexport interface ElementDecorate extends BaseDecorate {\n  match: (node: Element, path: Path) => boolean\n  renderElement: (props: DecorateRenderProps<Element>) => React.ReactElement\n}\n\n// Define a type for decorations which can either be a TextDecorate or an ElementDecorate\nexport type Decorate = TextDecorate | ElementDecorate\n\n// Define DecorateStore interface with decorations property\nexport interface DecorateStore {\n  decorations: Decorate[]\n}\n\n// Define a WeakMap to store Editor instances and their associated decoration stores\nconst EDITOR_TO_DECORATE_STORE = new WeakMap<Editor, UseBoundStore<StoreApi<DecorateStore>>>()\n\n// Function to retrieve the decoration store for a given Editor instance\nexport const getDecorateStore = (editor: Editor) => {\n  let store = EDITOR_TO_DECORATE_STORE.get(editor)\n  if (!store) {\n    store = create<DecorateStore>(() => ({\n      decorations: [],\n    }))\n    EDITOR_TO_DECORATE_STORE.set(editor, store)\n  }\n  return store\n}\n\n// Helper function to determine if a decoration is specified by its key or by its reference\nconst predicate = (decorate: Decorate | string) => {\n  const isKey = typeof decorate === 'string'\n  return (d: Decorate) => {\n    return isKey ? d.key === decorate : d === decorate\n  }\n}\n\n// Object to handle adding, removing, and checking the presence of decorations in a given Editor instance\nexport const Decorate = {\n  // Check if a given value is a TextDecorate\n  isTextDecorate: (value: any): value is TextDecorate => {\n    return value && typeof value.match === 'function' && typeof value.renderText === 'function'\n  },\n\n  // Add a decoration to the decorations array of a given Editor instance\n  create: (editor: Editor, decorate: Decorate) => {\n    const store = getDecorateStore(editor)\n    store.setState(state => ({\n      decorations: [...state.decorations, decorate],\n    }))\n  },\n\n  // Remove\n  remove: (editor: Editor, decorate: Decorate | string) => {\n    const store = getDecorateStore(editor)\n    store.setState(state => ({\n      decorations: state.decorations.filter(d => !predicate(decorate)(d)),\n    }))\n  },\n\n  has: (editor: Editor, decorate: Decorate | string) => {\n    const store = getDecorateStore(editor)\n    return store.getState().decorations.some(predicate(decorate))\n  },\n}\n","import * as React from 'react'\nimport { Editor, Node } from '@editablejs/models'\nimport { useStore } from 'zustand'\nimport { Placeholder } from '../plugin/placeholder'\nimport { useEditableStatic } from './use-editable'\nimport { useIsomorphicLayoutEffect } from './use-isomorphic-layout-effect'\nimport { Editable } from '../plugin/editable'\n\nexport const usePlaceholderStore = () => {\n  const editor = useEditableStatic()\n  return React.useMemo(() => {\n    return Placeholder.getStore(editor)\n  }, [editor])\n}\n\nexport const usePlaceholders = () => {\n  const store = usePlaceholderStore()\n  const placeholders = useStore(store, state => state.placeholders)\n  return placeholders\n}\n\nexport const usePlaceholder = (node: Node) => {\n  const editor = useEditableStatic()\n  const store = usePlaceholderStore()\n  const actives = useStore(store, state => state.actives)\n  useIsomorphicLayoutEffect(() => {\n    if (Editor.isEmpty(editor, node)) {\n      Placeholder.update(editor, [node, Editable.findPath(editor, node)])\n      return () => {\n        store.setState(({ actives }) => {\n          return {\n            actives: actives.filter(d => d.entry[0] !== node),\n          }\n        })\n      }\n    }\n  }, [store, node, editor])\n\n  return React.useMemo(() => {\n    return actives.find(d => d.entry[0] === node)?.render\n  }, [actives, node])\n}\n","import * as React from 'react'\nimport { Editor, Node, NodeEntry, Range } from '@editablejs/models'\nimport create, { UseBoundStore, StoreApi } from 'zustand'\nimport { Editable } from './editable'\n\nexport interface RenderPlaceholderProps {\n  node: Node\n}\nexport type PlaceholderRender = (props: RenderPlaceholderProps) => React.ReactNode\n\nexport type PlaceholderSubscribe = (entry: NodeEntry) => PlaceholderRender | void\n\nconst PLACEHOLDER_IS_ALONE = new WeakMap<PlaceholderSubscribe, boolean>()\nexport interface ActivePlaceholder {\n  entry: NodeEntry\n  alone: boolean\n  render: PlaceholderRender\n  placeholder: PlaceholderSubscribe\n}\n\nexport interface PlaceholderStore {\n  placeholders: PlaceholderSubscribe[]\n  actives: ActivePlaceholder[]\n}\n\nconst EDITOR_TO_PLACEHOLDER_STORE = new WeakMap<\n  Editable,\n  UseBoundStore<StoreApi<PlaceholderStore>>\n>()\n\nconst getPlaceholderStore = (editor: Editable) => {\n  let store = EDITOR_TO_PLACEHOLDER_STORE.get(editor)\n  if (!store) {\n    store = create<PlaceholderStore>(() => ({\n      placeholders: [],\n      actives: [],\n    }))\n    EDITOR_TO_PLACEHOLDER_STORE.set(editor, store)\n  }\n  return store\n}\n\nexport const Placeholder = {\n  getStore: getPlaceholderStore,\n\n  isAlone: (fn: PlaceholderSubscribe) => {\n    return PLACEHOLDER_IS_ALONE.get(fn) ?? false\n  },\n\n  subscribe: (editor: Editable, fn: PlaceholderSubscribe, alone = false) => {\n    const store = getPlaceholderStore(editor)\n    PLACEHOLDER_IS_ALONE.set(fn, alone)\n\n    store.setState(state => ({\n      placeholders: [...state.placeholders.filter(d => d !== fn), fn],\n    }))\n\n    return () => {\n      store.setState(state => ({\n        placeholders: state.placeholders.filter(d => d !== fn),\n      }))\n      PLACEHOLDER_IS_ALONE.delete(fn)\n    }\n  },\n\n  update: (editor: Editable, entry: NodeEntry) => {\n    const store = getPlaceholderStore(editor)\n    const state = store.getState()\n    let render: PlaceholderRender | null = null\n    let placeholder: PlaceholderSubscribe | null = null\n    const aloneActive = state.actives.find(d => d.alone && d.entry[0] === entry[0])\n    if (aloneActive) {\n      const r = aloneActive.placeholder(entry)\n      if (r) {\n        render = r\n        placeholder = aloneActive.placeholder\n      }\n    }\n    // 没有以编辑器为placeholder的情况下，才会去找其他的placeholder\n    else {\n      const hasEditorPlaceholder = state.actives.some(d => d.entry[0] === editor)\n      const placeholders = state.placeholders.sort(a => (Placeholder.isAlone(a) ? 1 : 0))\n      for (let i = placeholders.length - 1; i >= 0; i--) {\n        placeholder = placeholders[i]\n        if (!Placeholder.isAlone(placeholder) && hasEditorPlaceholder) continue\n        const r = placeholder(entry)\n        if (r) {\n          render = r\n          break\n        }\n      }\n    }\n\n    const actives = state.actives.filter(d => {\n      if (!d.alone || (d.entry[0] === entry[0] && render)) return false\n      return Editor.isEmpty(editor, d.entry[0])\n    })\n\n    if (render && placeholder) {\n      actives.push({\n        entry,\n        alone: Placeholder.isAlone(placeholder),\n        render,\n        placeholder,\n      })\n    }\n    store.setState({ actives })\n    return render\n  },\n\n  refresh: (editor: Editable) => {\n    const isReadOnly = Editable.isReadOnly(editor)\n    const store = getPlaceholderStore(editor)\n    if (isReadOnly) {\n      store.setState({ actives: [] })\n    } else if (Editor.isEmpty(editor, editor)) {\n      Placeholder.update(editor, [editor, []])\n    } else if (editor.selection && Range.isCollapsed(editor.selection)) {\n      const nodes = Editor.nodes(editor, {\n        at: editor.selection,\n      })\n      for (const entry of nodes) {\n        if (Editor.isEmpty(editor, entry[0])) {\n          return Placeholder.update(editor, entry)\n        }\n      }\n      store.setState(({ actives }) => {\n        return {\n          actives: actives.filter(d => {\n            if (!d.alone) return false\n            return Editor.isEmpty(editor, d.entry[0])\n          }),\n        }\n      })\n    } else {\n      store.setState(({ actives }) => ({\n        actives: actives.filter(d => d.alone),\n      }))\n    }\n  },\n}\n","import * as React from 'react'\n\nexport const NodeSelectedContext = React.createContext<boolean>(false)\n\n/**\n * Get the current `selected` state of an element.\n */\nexport const useNodeSelected = (): boolean => {\n  return React.useContext(NodeSelectedContext)\n}\n","import * as React from 'react'\n\nexport const NodeFocusedContext = React.createContext<boolean>(false)\n\n/**\n * Get the current `focused` state of an element.\n */\nexport const useNodeFocused = (): boolean => {\n  return React.useContext(NodeFocusedContext)\n}\n","import * as React from 'react'\nimport { Grid } from '@editablejs/models'\n\nexport const GridContext = React.createContext<Grid | null>(null)\n\nexport const useGrid = (): Grid | null => {\n  return React.useContext(GridContext)\n}\n","import * as React from 'react'\n\nimport { cancellablePromise, useCancellablePromises } from './use-cancellable-promises'\n\nconst useMultipleClick = (options: {\n  onClick?: (event: React.MouseEvent) => void\n  onMultipleClick: (event: React.MouseEvent, count: number) => boolean | void\n}) => {\n  const { onClick, onMultipleClick } = options\n  const api = useCancellablePromises()\n  const pointRef = React.useRef<{ x: number; y: number }>()\n  const countRef = React.useRef(0)\n\n  const isSamePoint = (event: React.MouseEvent | MouseEvent | Touch) => {\n    const point = pointRef.current\n    return point\n      ? Math.abs(event.clientY - point.y) < 10 && Math.abs(event.clientX - point.x) < 10\n      : false\n  }\n\n  const clear = () => {\n    api.clearPendingPromises()\n    pointRef.current = undefined\n  }\n\n  const handleMultipleClick = (event: React.MouseEvent) => {\n    if (event.button === 2) return\n    const point = pointRef.current\n    if (point) {\n      if (isSamePoint(event)) {\n        api.clearPendingPromises()\n        countRef.current += 1\n        if (onMultipleClick(event, countRef.current) === false) {\n          clear()\n          return\n        }\n      } else {\n        clear()\n      }\n    } else {\n      countRef.current = 1\n      pointRef.current = {\n        x: event.clientX,\n        y: event.clientY,\n      }\n    }\n    if (countRef.current === 1 && onMultipleClick(event, 1) === false) {\n      clear()\n    } else {\n      const waitForClick = cancellablePromise(api.delay(500))\n      api.appendPendingPromise(waitForClick)\n      return waitForClick.promise\n        .then(() => {\n          api.removePendingPromise(waitForClick)\n          if (onClick) onClick(event)\n          pointRef.current = undefined\n        })\n        .catch(errorInfo => {\n          api.removePendingPromise(waitForClick)\n          if (!errorInfo.isCanceled) {\n            throw errorInfo.error\n          }\n        })\n    }\n  }\n\n  return { handleMultipleClick, isSamePoint }\n}\n\nexport { useMultipleClick }\n","import * as React from 'react'\n\nexport interface CellablePromise<T> {\n  promise: Promise<T>\n  cancel: () => void\n}\n\nconst cancellablePromise = <T>(promise: Promise<T>) => {\n  let isCanceled = false\n\n  const wrappedPromise = new Promise((resolve, reject) => {\n    promise.then(\n      value => (isCanceled ? reject({ isCanceled, value }) : resolve(value)),\n      error => reject({ isCanceled, error }),\n    )\n  })\n\n  return {\n    promise: wrappedPromise,\n    cancel: () => (isCanceled = true),\n  }\n}\n\nconst noop = () => {}\n\nconst delay = (n: number) => new Promise(resolve => setTimeout(resolve, n))\n\nconst useCancellablePromises = <T>() => {\n  const pendingPromises = React.useRef<CellablePromise<T>[]>([])\n\n  const appendPendingPromise = (promise: CellablePromise<T>) =>\n    (pendingPromises.current = [...pendingPromises.current, promise])\n\n  const removePendingPromise = (promise: CellablePromise<T>) =>\n    (pendingPromises.current = pendingPromises.current.filter(p => p !== promise))\n\n  const clearPendingPromises = () => pendingPromises.current.map(p => p.cancel())\n\n  const api = {\n    pendingPromises,\n    appendPendingPromise,\n    removePendingPromise,\n    clearPendingPromises,\n    delay,\n    noop,\n  }\n\n  return api\n}\n\nexport { useCancellablePromises, cancellablePromise }\n","import * as React from 'react'\nimport ReactDOM from 'react-dom'\nimport { useIsomorphicLayoutEffect } from '../hooks/use-isomorphic-layout-effect'\n\nexport interface ShadowRect {\n  left: number\n  top: number\n  width: number\n  height: number\n  color?: string\n  style?: React.CSSProperties\n}\n\ntype ShadowBlockProps = {\n  rect: ShadowRect\n} & React.HTMLAttributes<HTMLDivElement>\n\nexport const ShadowBlockDefault: React.FC<ShadowBlockProps & React.RefAttributes<HTMLDivElement>> =\n  React.forwardRef<HTMLDivElement, ShadowBlockProps>(({ children, rect, style, ...props }, ref) => (\n    <div\n      ref={ref}\n      style={{\n        position: 'absolute',\n        top: rect.top,\n        left: rect.left,\n        width: rect.width,\n        height: rect.height,\n        // 数值为单数的情况下，两组重合位置会有阴影\n        // transform: `translateX(${rect.left || 0}px) translateY(${rect.top || 0}px)`,\n        opacity: 1,\n        backgroundColor: `${rect.color || 'transparent'}`,\n        zIndex: 1,\n        ...style,\n      }}\n      {...props}\n    >\n      {children}\n    </div>\n  ))\n\nShadowBlockDefault.displayName = 'ShadowBlock'\n\nexport const ShadowBlock = React.memo(ShadowBlockDefault, (prev, next) => {\n  return (\n    prev.rect.left === next.rect.left &&\n    prev.rect.top === next.rect.top &&\n    prev.rect.width === next.rect.width &&\n    prev.rect.height === next.rect.height &&\n    prev.rect.color === next.rect.color &&\n    prev.children === next.children\n  )\n})\n\ninterface ShadowContainerProps {\n  children?: React.ReactNode\n}\n\nconst ShadowContainer: React.FC<ShadowContainerProps & React.RefAttributes<ShadowRoot>> =\n  React.forwardRef<ShadowRoot, ShadowContainerProps>(({ children }, ref) => {\n    const [root, setRoot] = React.useState<ShadowRoot>()\n    const containerRef = React.useRef<HTMLDivElement>(null)\n\n    useIsomorphicLayoutEffect(() => {\n      if (!containerRef.current || containerRef.current.shadowRoot) return\n      const root = containerRef.current.attachShadow({ mode: 'open' })\n      setRoot(root)\n    }, [])\n\n    React.useImperativeHandle(ref, () => root!, [root])\n\n    return (\n      <div ref={containerRef} style={{ position: 'absolute', zIndex: 2, top: 0, left: 0 }}>\n        {root &&\n          ReactDOM.createPortal(<div style={{ pointerEvents: 'none' }}>{children}</div>, root)}\n      </div>\n    )\n  })\n\nShadowContainer.displayName = 'Shadow'\n\nexport default ShadowContainer\n","import * as React from 'react'\nimport { Range } from '@editablejs/models'\nimport { useEditableStatic } from '../hooks/use-editable'\nimport { useFocused } from '../hooks/use-focused'\nimport { useIsomorphicLayoutEffect } from '../hooks/use-isomorphic-layout-effect'\nimport { IS_MOUSEDOWN } from '../utils/weak-maps'\nimport {\n  useSelectionDrawingEnabled,\n  useSelectionDrawingRects,\n  useSelectionDrawingSelection,\n  useSelectionDrawingStyle,\n} from '../hooks/use-selection-drawing'\nimport { isTouchDevice } from '../utils/environment'\nimport { useReadOnly } from '../hooks/use-read-only'\nimport { ShadowBlock } from './shadow'\n\ninterface CaretProps {\n  timeout?: number | false\n}\n\nconst CaretComponent: React.FC<CaretProps> = React.memo(({ timeout = 530 }) => {\n  const editor = useEditableStatic()\n\n  const [focused] = useFocused()\n\n  const timer = React.useRef<number>()\n\n  const ref = React.useRef<HTMLDivElement>(null)\n\n  const [readOnly] = useReadOnly()\n\n  const enabled = useSelectionDrawingEnabled()\n  const selection = useSelectionDrawingSelection()\n  const rects = useSelectionDrawingRects()\n  const style = useSelectionDrawingStyle()\n\n  const caretWidth = isTouchDevice ? style.touchWidth : style.caretWidth\n  const caretColor = isTouchDevice ? style.touchColor : style.caretColor\n\n  const rect = React.useMemo(() => {\n    if (!selection || rects.length === 0 || !focused || !Range.isCollapsed(selection)) return null\n    return rects[0].toJSON()\n  }, [focused, rects, selection])\n\n  const clearActive = React.useCallback(() => {\n    clearTimeout(timer.current)\n  }, [])\n\n  const setOpacity = (opacity?: number) => {\n    const elRef = ref.current\n    if (elRef) {\n      elRef.style.opacity =\n        opacity !== undefined ? String(opacity) : elRef.style.opacity === '1' ? '0' : '1'\n    }\n  }\n\n  const active = React.useCallback(\n    (opacity?: number) => {\n      clearActive()\n      if (!rect || timeout === false) return\n      if (IS_MOUSEDOWN.get(editor)) {\n        setOpacity(1)\n      } else {\n        setOpacity(opacity)\n      }\n      timer.current = setTimeout(() => {\n        active()\n      }, timeout)\n    },\n    [clearActive, editor, rect, timeout],\n  )\n\n  useIsomorphicLayoutEffect(() => {\n    if (readOnly) {\n      clearActive()\n    } else active(1)\n    return () => clearActive()\n  }, [editor, readOnly, active, clearActive])\n\n  if (!enabled || readOnly) return null\n\n  return (\n    <ShadowBlock\n      rect={\n        rect\n          ? Object.assign({}, rect, { width: caretWidth, color: caretColor })\n          : { width: 0, height: 0, top: 0, left: 0 }\n      }\n      ref={ref}\n      style={{ willChange: 'opacity, transform', opacity: rect ? 1 : 0 }}\n    />\n  )\n})\nCaretComponent.displayName = 'CaretComponent'\nexport { CaretComponent }\n","import * as React from 'react'\nimport { useStore } from 'zustand'\nimport { SelectionDrawing } from '../plugin/selection-drawing'\nimport { EDITOR_TO_SELECTION_RECTS } from '../utils/weak-maps'\nimport { useEditableStatic } from './use-editable'\nimport { useIsomorphicLayoutEffect } from './use-isomorphic-layout-effect'\n\nexport const useSelectionDrawingStore = () => {\n  const editor = useEditableStatic()\n  return React.useMemo(() => {\n    return SelectionDrawing.getStore(editor)\n  }, [editor])\n}\n\nexport const useSelectionDrawingStyle = () => {\n  const store = useSelectionDrawingStore()\n  return useStore(store, state => state.style)\n}\n\nexport const useSelectionDrawingSelection = () => {\n  const store = useSelectionDrawingStore()\n  return useStore(store, state => state.selection)\n}\n\nexport const useSelectionDrawingRects = () => {\n  const editor = useEditableStatic()\n  const selection = useSelectionDrawingSelection()\n  const [rects, setRects] = React.useState<DOMRect[]>([])\n  useIsomorphicLayoutEffect(() => {\n    const rects = selection ? SelectionDrawing.toRects(editor, selection) : []\n    EDITOR_TO_SELECTION_RECTS.set(editor, rects)\n    setRects(rects)\n  }, [editor, selection])\n\n  return rects\n}\n\nexport const useSelectionDrawingEnabled = () => {\n  const store = useSelectionDrawingStore()\n  return useStore(store, state => state.enabled)\n}\n","import create, { StoreApi, UseBoundStore } from 'zustand'\nimport { Selection, Range, Editor } from '@editablejs/models'\nimport { getLineRectsByRange } from '../utils/selection'\nimport { Editable } from './editable'\n\nexport interface SelectionDrawingStyle {\n  /**\n   * 拖蓝聚焦颜色\n   */\n  focusColor?: string\n  /**\n   * 拖蓝失焦颜色\n   */\n  blurColor?: string\n  /**\n   * 光标颜色\n   */\n  caretColor?: string\n  /**\n   * 光标宽度\n   */\n  caretWidth?: number\n  /**\n   * 拖拽光标的颜色\n   */\n  dragColor?: string\n  /**\n   * 触摸光标的颜色\n   */\n  touchColor?: string\n  /**\n   * 触摸光标的宽度\n   */\n  touchWidth?: number\n}\n\nexport interface SelectionDrawingStore {\n  style: SelectionDrawingStyle\n  selection: Selection | null\n  enabled: boolean\n}\n\nconst EDITOR_TO_SELECTION_DRAWING_STORE = new WeakMap<\n  Editor,\n  UseBoundStore<StoreApi<SelectionDrawingStore>>\n>()\n\nconst getStore = (editor: Editor) => {\n  let store = EDITOR_TO_SELECTION_DRAWING_STORE.get(editor)\n  if (!store) {\n    store = create<SelectionDrawingStore>(() => ({\n      style: {\n        focusColor: 'rgba(0,127,255,0.3)',\n\n        blurColor: 'rgba(136, 136, 136, 0.3)',\n\n        caretColor: '#000',\n\n        caretWidth: 1,\n\n        dragColor: 'rgb(37, 99, 235)',\n\n        touchWidth: 2,\n\n        touchColor: 'rgb(37, 99, 235)',\n      },\n      selection: null,\n      rects: null,\n      enabled: true,\n    }))\n    EDITOR_TO_SELECTION_DRAWING_STORE.set(editor, store)\n  }\n  return store\n}\n\nexport const SelectionDrawing = {\n  getStore,\n\n  setStyle: (editor: Editor, style: Partial<SelectionDrawingStyle>) => {\n    const store = getStore(editor)\n    store.setState(state => ({ ...state, style }))\n  },\n\n  setSelection: (editor: Editor, selection: Selection | null) => {\n    const store = getStore(editor)\n    store.setState(state => ({ ...state, selection }))\n  },\n\n  setEnabled: (editor: Editor, enabled: boolean) => {\n    const store = getStore(editor)\n    store.setState(state => ({ ...state, enabled }))\n  },\n\n  toRects(editor: Editor, range: Range, relative = true) {\n    let rects: DOMRect[] = []\n    if (Range.isCollapsed(range)) {\n      const domRange = Editable.toDOMRange(editor, range)\n      const clientRects = domRange.getClientRects()\n      if (clientRects.length > 1) {\n        rects = [clientRects[clientRects.length - 1]]\n      } else {\n        rects = [domRange.getBoundingClientRect()]\n      }\n    } else {\n      rects = getLineRectsByRange(editor, range)\n    }\n\n    return relative\n      ? rects.map(r => {\n          const [x, y] = Editable.toRelativePosition(editor, r.left, r.top)\n          r.x = x\n          r.y = y\n          return r\n        })\n      : rects\n  },\n}\n","import * as React from 'react'\nimport { Range } from '@editablejs/models'\nimport { useFocused } from '../hooks/use-focused'\nimport {\n  useSelectionDrawingSelection,\n  useSelectionDrawingRects,\n  useSelectionDrawingEnabled,\n  useSelectionDrawingStyle,\n} from '../hooks/use-selection-drawing'\nimport { ShadowBlock } from './shadow'\nimport { isTouchDevice } from '../utils/environment'\n\ninterface SelectionProps {}\n\nconst SelectionComponent: React.FC<SelectionProps> = () => {\n  const selection = useSelectionDrawingSelection()\n  const rects = useSelectionDrawingRects()\n  const enabled = useSelectionDrawingEnabled()\n  const style = useSelectionDrawingStyle()\n  const [focused] = useFocused()\n  if (!enabled || !selection || Range.isCollapsed(selection)) return null\n\n  return (\n    <>\n      {rects.map((rect, index) => {\n        return (\n          <ShadowBlock\n            key={`sel-${index}`}\n            rect={Object.assign({}, rect.toJSON(), {\n              color: isTouchDevice || focused ? style.focusColor : style.blurColor,\n            })}\n          />\n        )\n      })}\n    </>\n  )\n}\n\nexport { SelectionComponent }\n","import { Range } from '@editablejs/models'\nimport * as React from 'react'\nimport { Editable } from '../plugin/editable'\nimport {\n  EDITOR_TO_INPUT,\n  IS_COMPOSING,\n  IS_MOUSEDOWN,\n  IS_PASTE_TEXT,\n  IS_TOUCHING,\n} from '../utils/weak-maps'\nimport { useFocused } from '../hooks/use-focused'\nimport { ShadowBlock, ShadowRect } from './shadow'\nimport { useIsomorphicLayoutEffect } from '../hooks/use-isomorphic-layout-effect'\nimport { useEditableStatic } from '../hooks/use-editable'\nimport {\n  useSelectionDrawingSelection,\n  useSelectionDrawingRects,\n} from '../hooks/use-selection-drawing'\nimport { ReadOnly, useReadOnly } from '../hooks/use-read-only'\nimport { composeEventHandlers } from '../utils/event'\nimport { useEffect } from 'react'\n\ninterface InputProps {\n  autoFocus?: boolean\n}\n\nconst InputComponent: React.FC<InputProps> = ({ autoFocus }) => {\n  const editor = useEditableStatic()\n  const inputRef = React.useRef<HTMLTextAreaElement>(null)\n  const [focused, setFocused] = useFocused()\n  const [readOnly] = useReadOnly()\n\n  const [rect, setRect] = React.useState<ShadowRect | null>(null)\n\n  useIsomorphicLayoutEffect(() => {\n    if (inputRef.current) EDITOR_TO_INPUT.set(editor, inputRef.current)\n    return () => {\n      EDITOR_TO_INPUT.delete(editor)\n    }\n  }, [editor])\n\n  useEffect(() => {\n    if (autoFocus) {\n      editor.focus()\n      Editable.scrollIntoView(editor)\n    }\n  }, [editor, autoFocus])\n\n  const handleKeydown = (event: React.KeyboardEvent) => {\n    const { nativeEvent } = event\n    if (Editable.isComposing(editor) && nativeEvent.isComposing === false) {\n      IS_COMPOSING.set(editor, false)\n    }\n\n    if (event.defaultPrevented || Editable.isComposing(editor)) {\n      return\n    }\n    editor.onKeydown(nativeEvent)\n  }\n\n  const handleKeyup = (event: React.KeyboardEvent) => {\n    const { nativeEvent } = event\n    editor.onKeyup(nativeEvent)\n  }\n\n  const handleBlur = () => {\n    if (!IS_MOUSEDOWN.get(editor) && !IS_TOUCHING.get(editor)) setFocused(false)\n  }\n\n  const handleFocus = () => {\n    setFocused(true)\n  }\n\n  const handleBeforeInput = (event: React.FormEvent<HTMLTextAreaElement>) => {\n    const textarea = event.target\n    if (!(textarea instanceof HTMLTextAreaElement)) return\n    const { value } = textarea\n    editor.onBeforeInput(value)\n  }\n\n  const handleInput = (event: React.FormEvent<HTMLTextAreaElement>) => {\n    const textarea = event.target\n    if (!(textarea instanceof HTMLTextAreaElement)) return\n    const value = textarea.value\n    if (!IS_COMPOSING.get(editor)) {\n      textarea.value = ''\n    }\n    editor.onInput(value)\n  }\n\n  const handleCompositionStart = (ev: React.CompositionEvent) => {\n    const { data } = ev.nativeEvent\n    editor.onCompositionStart(data)\n  }\n\n  const handleCompositionEnd = (event: React.CompositionEvent) => {\n    const textarea = event.target\n    if (!(textarea instanceof HTMLTextAreaElement)) return\n    const value = textarea.value\n    textarea.value = ''\n    editor.onCompositionEnd(value)\n  }\n\n  const handlePaste = (event: React.ClipboardEvent) => {\n    composeEventHandlers(\n      (event: React.ClipboardEvent) => {\n        if (ReadOnly.is(editor)) {\n          event.preventDefault()\n        }\n      },\n      event => {\n        const { nativeEvent } = event\n        const isPasteText = IS_PASTE_TEXT.get(editor)\n        event.preventDefault()\n        const e = new ClipboardEvent(isPasteText ? 'pasteText' : 'paste', nativeEvent)\n        editor.onPaste(e)\n      },\n    )(event)\n  }\n\n  const selection = useSelectionDrawingSelection()\n  const rects = useSelectionDrawingRects()\n\n  useIsomorphicLayoutEffect(() => {\n    if (!selection || !focused || rects.length === 0) return setRect(null)\n    if (Range.isCollapsed(selection)) {\n      setRect(rects[0].toJSON())\n    } else {\n      const rect = rects[rects.length - 1].toJSON()\n      rect.left = rect.left + rect.width\n      return setRect(rect)\n    }\n  }, [focused, rects, selection])\n\n  return (\n    <ShadowBlock\n      rect={Object.assign({}, rect, { color: 'transparent', width: 1 })}\n      style={{ opacity: 0, outline: 'none', caretColor: 'transparent', overflow: 'hidden' }}\n    >\n      <textarea\n        ref={inputRef}\n        rows={1}\n        style={{\n          fontSize: 'inherit',\n          lineHeight: 1,\n          padding: 0,\n          border: 'none',\n          whiteSpace: 'nowrap',\n          width: '1em',\n          overflow: 'auto',\n          resize: 'vertical',\n        }}\n        readOnly={readOnly}\n        onKeyDown={handleKeydown}\n        onKeyUp={handleKeyup}\n        onBeforeInput={handleBeforeInput}\n        onInput={handleInput}\n        onCompositionStart={handleCompositionStart}\n        onCompositionEnd={handleCompositionEnd}\n        onBlur={handleBlur}\n        onFocus={handleFocus}\n        onPaste={handlePaste}\n      />\n    </ShadowBlock>\n  )\n}\n\nexport { InputComponent }\n","import * as React from 'react'\nimport { useEditableStatic } from './use-editable'\nimport { Drag, DragStore } from '../plugin/drag'\nimport { useStore } from 'zustand'\n\nexport const useDragStore = () => {\n  const editor = useEditableStatic()\n  const store = React.useMemo(() => {\n    return Drag.getStore(editor)\n  }, [editor])\n  return store\n}\n\n/**\n * 是否拖拽中\n * @returns\n */\nexport const useDragging = () => {\n  const store = useDragStore()\n\n  const drag = useStore(store, state => state.drag !== null)\n\n  return React.useMemo(() => drag, [drag])\n}\n\nexport const useDragType = () => {\n  const store = useDragStore()\n\n  const type = useStore(store, state => state.drag?.type ?? null)\n\n  return React.useMemo(() => type, [type])\n}\n\n/**\n * 拖拽到的目标\n * @returns\n */\nexport const useDragTo = () => {\n  const store = useDragStore()\n  const drag = useStore(store, state => state.drag)\n\n  return React.useMemo(() => drag?.to ?? null, [drag])\n}\n\n/**\n * 当前拖拽的鼠标位置\n * @returns\n */\nexport const useDragPosition = () => {\n  const store = useDragStore()\n  const drag = useStore(store, state => state.drag)\n\n  return React.useMemo(() => drag?.position ?? null, [drag])\n}\n\n/**\n * 当前拖拽的数据\n * @returns\n */\nexport const useDragData = () => {\n  const store = useDragStore()\n  const drag = useStore(store, state => state.drag)\n\n  return React.useMemo(() => drag?.data ?? 0, [drag])\n}\n\nexport const useDragMethods = () => {\n  const editor = useEditableStatic()\n\n  const setDrag = React.useCallback(\n    (drag: Partial<DragStore['drag']>) => {\n      Drag.setDrag(editor, drag)\n    },\n    [editor],\n  )\n\n  const getDrag = React.useCallback(() => {\n    return Drag.getDrag(editor)\n  }, [editor])\n\n  return React.useMemo(() => ({ setDrag, getDrag }), [setDrag, getDrag])\n}\n","import create, { StoreApi, UseBoundStore } from 'zustand'\nimport { Editor, Range, Element, Path, Selection } from '@editablejs/models'\nimport { Editable } from './editable'\n\nexport interface DragStore {\n  drag: {\n    type: 'block' | 'text'\n    /**\n     * 拖拽的开始位置\n     */\n    from: Range | Path\n    /**\n     * 拖拽到目标位置\n     */\n    to: Selection | Path\n    /**\n     * 拖拽的数据\n     */\n    data: DataTransfer\n    /**\n     * 当前鼠标位置\n     */\n    position: Record<'x' | 'y', number>\n  } | null\n}\n\nconst EDITOR_TO_DRAG_STORE = new WeakMap<Editor, UseBoundStore<StoreApi<DragStore>>>()\n\nconst getDragStore = (editor: Editor) => {\n  let store = EDITOR_TO_DRAG_STORE.get(editor)\n  if (!store) {\n    store = create<DragStore>(() => ({\n      drag: null,\n    }))\n    EDITOR_TO_DRAG_STORE.set(editor, store)\n  }\n  return store\n}\n\n/**\n * 拖拽相关状态操作\n */\nexport const Drag = {\n  getStore: getDragStore,\n\n  getDrag: (editor: Editor) => {\n    const store = getDragStore(editor)\n    const { drag } = store.getState()\n    return drag\n  },\n\n  setDrag: (editor: Editor, drag: Partial<DragStore['drag']>) => {\n    const store = getDragStore(editor)\n    store.setState(state => {\n      return {\n        drag: drag === null ? null : Object.assign({}, state.drag, drag),\n      }\n    })\n  },\n\n  clear: (editor: Editor) => {\n    const store = getDragStore(editor)\n    store.setState({ drag: null })\n  },\n\n  toBlockPath: (editor: Editor) => {\n    const drag = Drag.getDrag(editor)\n    if (!drag || drag.type !== 'block') return\n    const { to, position } = drag\n    if (!to) return\n    const entry = Editor.above(editor, {\n      at: Path.isPath(to) ? to : to.focus,\n      match: n => Element.isElement(n),\n      mode: 'lowest',\n    })\n    if (!entry) return\n    const element = Editable.toDOMNode(editor, entry[0])\n    const rect = element.getBoundingClientRect()\n    const { y, height } = rect\n    const { y: pY } = position\n    if (pY > y + height / 2) {\n      return Path.next(entry[1])\n    } else {\n      return entry[1]\n    }\n  },\n}\n","import * as React from 'react'\nimport { Editor, Element, Path, GridCell } from '@editablejs/models'\nimport { useDragPosition, useDragTo, useDragType } from '../hooks/use-drag'\nimport { useEditableStatic } from '../hooks/use-editable'\nimport { useSelectionDrawingStyle } from '../hooks/use-selection-drawing'\nimport { Editable } from '../plugin/editable'\nimport { SelectionDrawing } from '../plugin/selection-drawing'\nimport { ShadowBlock } from './shadow'\n\nexport const DragCaretComponent = React.memo(() => {\n  const editor = useEditableStatic()\n  const dragTo = useDragTo()\n  const dragType = useDragType()\n  const dragPosition = useDragPosition()\n  const rects = React.useMemo(() => {\n    if (!dragTo || !dragPosition) return null\n    if (dragType === 'block') {\n      const entry = Editor.above(editor, {\n        at: dragTo,\n        match: n => Element.isElement(n),\n        mode: 'lowest',\n      })\n      if (!entry) return null\n      const element = Editable.toDOMNode(editor, entry[0])\n      const rect = element.getBoundingClientRect()\n      let { x, y } = rect\n      const { height, width } = rect\n      const { y: pY } = dragPosition\n      const space = 1\n      // bottom\n      if (pY > y + height / 2) {\n        y += height + space\n      }\n      // find previous sibling\n      else {\n        const previous = Editor.previous(editor, {\n          at: entry[1],\n          match: (n, p) => {\n            if (!Element.isElement(n)) return false\n            const gridCell = GridCell.find(editor, entry[1])\n            if (!gridCell) return true\n            const matchCell = GridCell.find(editor, p)\n            if (!matchCell) return false\n\n            return Path.equals(gridCell[1], matchCell[1])\n          },\n          mode: 'lowest',\n        })\n        if (previous) {\n          const previousElement = Editable.toDOMNode(editor, previous[0])\n          const previousRect = previousElement.getBoundingClientRect()\n          y = previousRect.y + previousRect.height + space\n        } else {\n          y -= space\n        }\n      }\n      const [rx, ry] = Editable.toRelativePosition(editor, x, y)\n      return [new DOMRect(rx, ry, width, 2)]\n    }\n\n    return SelectionDrawing.toRects(editor, Editor.range(editor, dragTo))\n  }, [dragPosition, dragTo, dragType, editor])\n\n  const { dragColor, caretWidth } = useSelectionDrawingStyle()\n  if (!rects || rects.length === 0) return null\n  if (dragType === 'block') {\n    return (\n      <ShadowBlock\n        rect={Object.assign({}, rects[0].toJSON(), {\n          color: dragColor,\n        })}\n      />\n    )\n  }\n  return (\n    <ShadowBlock\n      rect={Object.assign({}, rects[0].toJSON(), {\n        width: caretWidth,\n        color: dragColor,\n      })}\n    />\n  )\n})\n\nDragCaretComponent.displayName = 'DragCaretComponent'\n","import React from 'react'\nimport { useSlotComponents } from '../hooks/use-slot'\n\nexport const Slots = React.memo(() => {\n  const slots = useSlotComponents()\n  return (\n    <>\n      {slots.map(({ component: Component, props }, index) => (\n        <Component key={index} {...props} />\n      ))}\n    </>\n  )\n})\nSlots.displayName = 'Slots'\n","import React from 'react'\nimport { useStore } from 'zustand'\nimport shallow from 'zustand/shallow'\nimport { Slot } from '../plugin/solt'\nimport { useEditableStatic } from './use-editable'\n\nexport const useSlotStore = () => {\n  const editor = useEditableStatic()\n  return React.useMemo(() => Slot.getStore(editor), [editor])\n}\n\nexport const useSlotComponents = () => {\n  const store = useSlotStore()\n  return useStore(store, state => state.components, shallow)\n}\n\nexport const useSlotActive = (component: React.FC) => {\n  const components = useSlotComponents()\n  const editor = useEditableStatic()\n  const slot = components.find(c => c.component === component)\n  return React.useMemo(() => {\n    return [\n      slot?.props.active ?? false,\n      (active: boolean) => {\n        Slot.update(editor, { active }, c => c === component)\n      },\n    ] as const\n  }, [editor, slot, component])\n}\n","import merge from 'lodash.merge'\nimport * as React from 'react'\nimport create, { StoreApi, UseBoundStore } from 'zustand'\nimport { Editor } from '@editablejs/models'\n\nexport interface SlotComponentProps {\n  active?: boolean\n}\n\nexport interface SlotState<T extends SlotComponentProps> {\n  component: React.FC\n  props: T\n}\n\nexport interface SlotStore<T extends SlotComponentProps> {\n  components: SlotState<T>[]\n}\n\nconst EDITOR_TO_SLOTS_STORE = new WeakMap<\n  Editor,\n  UseBoundStore<StoreApi<SlotStore<SlotComponentProps>>>\n>()\n\nconst getStore = (editor: Editor) => {\n  let store = EDITOR_TO_SLOTS_STORE.get(editor)\n  if (!store) {\n    store = create<SlotStore<SlotComponentProps>>(() => ({\n      components: [],\n    }))\n    EDITOR_TO_SLOTS_STORE.set(editor, store)\n  }\n  return store\n}\n\nexport const Slot = {\n  getStore,\n\n  mount<T extends SlotComponentProps>(editor: Editor, component: React.FC<T>, props: T = {} as T) {\n    const store = getStore(editor)\n    store.setState(state => {\n      const { components } = state\n      if (components.some(c => c.component === component)) return state\n      return {\n        components: [...components, { component, props } as SlotState<T>],\n      }\n    })\n  },\n\n  unmount(editor: Editor, component: React.FC) {\n    const store = getStore(editor)\n    store.setState(state => {\n      const { components } = state\n      if (!components.some(c => c.component === component)) return state\n      return {\n        components: components.filter(c => c.component !== component),\n      }\n    })\n  },\n\n  update: <T extends SlotComponentProps>(\n    editor: Editor,\n    props: Partial<T>,\n    predicate: (value: React.FC<T>, index: number) => boolean = () => true,\n  ) => {\n    const store = getStore(editor)\n    store.setState(state => {\n      const { components } = state\n      return {\n        components: components.map((c, index) => {\n          if (!predicate(c.component, index)) return c\n          return { ...c, props: merge(c.props, props) }\n        }),\n      }\n    })\n  },\n}\n","import * as React from 'react'\nimport { Range } from '@editablejs/models'\nimport { useEditableStatic } from '../hooks/use-editable'\nimport { useFocused } from '../hooks/use-focused'\nimport {\n  useSelectionDrawingSelection,\n  useSelectionDrawingRects,\n  useSelectionDrawingEnabled,\n  useSelectionDrawingStyle,\n} from '../hooks/use-selection-drawing'\nimport { isTouchDevice } from '../utils/environment'\nimport { IS_TOUCHING, IS_TOUCHMOVING, IS_TOUCH_HOLD } from '../utils/weak-maps'\nimport { ShadowBlock } from './shadow'\n\ninterface TouchPointProps {\n  onAnchorTouchStart?: (e: React.TouchEvent) => void\n  onFocusTouchStart?: (e: React.TouchEvent) => void\n}\n\nconst TouchPointComponent: React.FC<TouchPointProps> = React.memo(\n  ({ onAnchorTouchStart, onFocusTouchStart }) => {\n    const selection = useSelectionDrawingSelection()\n    const rects = useSelectionDrawingRects()\n    const enabled = useSelectionDrawingEnabled()\n    const style = useSelectionDrawingStyle()\n    const editor = useEditableStatic()\n\n    if (\n      rects.length === 0 ||\n      !isTouchDevice ||\n      !enabled ||\n      !selection ||\n      IS_TOUCHING.get(editor) ||\n      (!IS_TOUCHMOVING.get(editor) && Range.isCollapsed(selection))\n    )\n      return null\n    const anchor = rects[0]\n    const focus = rects[rects.length - 1]\n\n    const baseStyle: React.CSSProperties = {\n      position: 'absolute',\n      width: 12,\n      height: 12,\n      borderRadius: '100%',\n      overscrollBehavior: 'none',\n      background: style.dragColor,\n    }\n\n    return (\n      <>\n        <ShadowBlock\n          rect={Object.assign({}, anchor.toJSON(), {\n            color: style.dragColor,\n            width: 2,\n            left: anchor.left - 1,\n          })}\n          style={{\n            zIndex: 2,\n          }}\n        >\n          <div\n            onTouchStart={onAnchorTouchStart}\n            style={{\n              ...baseStyle,\n              top: -10,\n              left: -5,\n            }}\n          />\n        </ShadowBlock>\n        <ShadowBlock\n          rect={Object.assign({}, focus.toJSON(), {\n            color: style.dragColor,\n            width: 2,\n            left: focus.right - 1,\n          })}\n          style={{\n            zIndex: 2,\n          }}\n        >\n          <div\n            onTouchStart={onFocusTouchStart}\n            style={{\n              ...baseStyle,\n              bottom: -10,\n              right: -5,\n            }}\n          />\n        </ShadowBlock>\n      </>\n    )\n  },\n)\nTouchPointComponent.displayName = 'TouchPointComponent'\nexport { TouchPointComponent }\n","import * as React from 'react'\nimport { Descendant, Node, Editor, Scrubber } from '@editablejs/models'\nimport create, { StoreApi, UseBoundStore } from 'zustand'\nimport { Editable } from '../plugin/editable'\nimport { EditableStore, EditableStoreContext } from '../hooks/use-editable'\nimport { useIsomorphicLayoutEffect } from '../hooks/use-isomorphic-layout-effect'\n\nconst EDITABLE_TO_STORE = new WeakMap<Editable, UseBoundStore<StoreApi<EditableStore>>>()\n\nexport const EditableProvider = (props: {\n  editor: Editable\n  value?: Descendant[]\n  children: React.ReactNode\n  onChange?: (value: Descendant[]) => void\n}) => {\n  const {\n    editor,\n    children,\n    value = [{ type: 'paragraph', children: [{ text: '' }] }],\n    onChange,\n    ...rest\n  } = props\n\n  const store = React.useMemo(() => {\n    const store = EDITABLE_TO_STORE.get(editor)\n    if (store) {\n      return store\n    }\n    if (!Node.isNodeList(value)) {\n      throw new Error(\n        `[Editable] value is invalid! Expected a list of elements` +\n          `but got: ${Scrubber.stringify(value)}`,\n      )\n    }\n    if (!Editor.isEditor(editor)) {\n      throw new Error(`[Editable] editor is invalid! you passed:` + `${Scrubber.stringify(editor)}`)\n    }\n    editor.children = value\n    Object.assign(editor, rest)\n    const newStore = create<EditableStore>(() => ({\n      editor: [editor],\n    }))\n    EDITABLE_TO_STORE.set(editor, newStore)\n    editor.normalizeNode([editor, []])\n    return newStore\n  }, [editor, value, rest])\n\n  useIsomorphicLayoutEffect(() => {\n    const handleChange = () => {\n      if (onChange) {\n        onChange(editor.children)\n      }\n      store.setState({\n        editor: [editor],\n      })\n    }\n    editor.on('change', handleChange)\n    return () => {\n      editor.off('change', handleChange)\n    }\n  }, [editor, onChange])\n\n  return (\n    <EditableStoreContext.Provider\n      value={{\n        store,\n        editor,\n      }}\n    >\n      {children}\n    </EditableStoreContext.Provider>\n  )\n}\n","import * as React from 'react'\nimport { Path, Grid, GridSelection } from '@editablejs/models'\nimport { Editable } from '../plugin/editable'\nimport { useEditableStatic } from './use-editable'\nimport { useGrid } from './use-grid'\nimport { useIsomorphicLayoutEffect } from './use-isomorphic-layout-effect'\nimport { useNodeFocused } from './use-node-focused'\n\nconst useGridSelection = () => {\n  const editor = useEditableStatic()\n  const grid = useGrid()\n  // selection\n  const [selection, setSelection] = React.useState<GridSelection | null>(null)\n  const nodeFocused = useNodeFocused()\n\n  useIsomorphicLayoutEffect(() => {\n    if (grid && nodeFocused) {\n      const selection = Grid.getSelection(editor, [grid, Editable.findPath(editor, grid)])\n      if (selection) {\n        setSelection(prev => {\n          if (\n            !prev ||\n            !Path.equals(prev.start, selection.start) ||\n            !Path.equals(prev.end, selection.end)\n          ) {\n            const path = Editable.findPath(editor, grid)\n            const startPath = path.concat(selection.start)\n            const endPath = path.concat(selection.end)\n            const edgeSelection = Grid.edges(editor, [grid, path], selection)\n            const { start: tableStart, end: tableEnd } = Grid.span(\n              editor,\n              [grid, path],\n              edgeSelection,\n            )\n            const selStart = path.concat(tableStart)\n            const selEnd = path.concat(tableEnd)\n            // 有合并的单元格时选择区域会变大，所以需要重新select\n            if (!Path.equals(startPath, selStart) || !Path.equals(endPath, selEnd)) {\n              Grid.select(editor, [grid, path], edgeSelection)\n              return prev\n            }\n            return selection\n          }\n          return prev\n        })\n        return\n      }\n    }\n    setSelection(null)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [editor, editor.selection, nodeFocused])\n\n  return selection\n}\n\nexport { useGridSelection }\n","import * as React from 'react'\nimport { GridCell, Grid } from '@editablejs/models'\nimport { Editable } from '../plugin/editable'\nimport { useEditableStatic } from './use-editable'\nimport { useGrid } from './use-grid'\nimport { useGridSelection } from './use-grid-selection'\nimport { useIsomorphicLayoutEffect } from './use-isomorphic-layout-effect'\n\nconst useGridSelectionRect = () => {\n  const editor = useEditableStatic()\n\n  const grid = useGrid()\n\n  const selection = useGridSelection()\n\n  const [rect, setRect] = React.useState<DOMRect | null>(null)\n\n  useIsomorphicLayoutEffect(() => {\n    if (!selection || !grid) return setRect(null)\n    const { start, end } = GridCell.edges(selection)\n    if (GridCell.equal(start, end)) return setRect(null)\n    const path = Editable.findPath(editor, grid)\n    const startCell = Grid.getCell(editor, path, start)\n    if (!startCell) return setRect(null)\n    const endCell = Grid.getCell(editor, path, end)\n    if (!endCell) return setRect(null)\n    const startEl = Editable.toDOMNode(editor, startCell[0])\n    const endEl = Editable.toDOMNode(editor, endCell[0])\n    const tableEl = Editable.toDOMNode(editor, grid)\n    const tableRect = tableEl.getBoundingClientRect()\n    const startRect = startEl.getBoundingClientRect()\n    const endRect = endEl.getBoundingClientRect()\n    const width =\n      endRect.left < startRect.left\n        ? startRect.right - endRect.left\n        : endRect.right - startRect.left\n    const height = Math.max(endRect.bottom - startRect.top, startRect.height)\n    const top = startRect.top - tableRect.top\n    const left = Math.min(startRect.left - tableRect.left, endRect.left - tableRect.left)\n    setRect(new DOMRect(left, top, width, height))\n  }, [editor, selection, grid])\n\n  return rect\n}\n\nexport { useGridSelectionRect }\n","import * as React from 'react'\nimport { GridSelected, Grid } from '@editablejs/models'\nimport { Editable } from '../plugin/editable'\nimport { useEditableStatic } from './use-editable'\nimport { useGrid } from './use-grid'\nimport { useGridSelection } from './use-grid-selection'\n\nconst defaultSelected = {\n  rows: [],\n  cols: [],\n  rowFull: false,\n  colFull: false,\n  allFull: false,\n  cells: [],\n  count: 0,\n}\n\nconst useGridSelected = () => {\n  const editor = useEditableStatic()\n\n  const grid = useGrid()\n\n  const selection = useGridSelection()\n\n  const selected: GridSelected = React.useMemo(() => {\n    if (!grid) return defaultSelected\n    const sel = Grid.getSelected(editor, Editable.findPath(editor, grid), selection ?? undefined)\n    return sel ?? defaultSelected\n  }, [editor, selection, grid])\n\n  return selected\n}\n\nexport { useGridSelected }\n","import ReactDOM from 'react-dom'\nimport {\n  Editor,\n  Node,\n  Path,\n  Operation,\n  Transforms,\n  Range,\n  Point,\n  List,\n  Key,\n} from '@editablejs/models'\nimport { Editable, RenderElementProps, RenderLeafProps } from './editable'\nimport {\n  EDITOR_TO_KEY_TO_ELEMENT,\n  NODE_TO_KEY,\n  IS_SHIFT_PRESSED,\n  EDITOR_TO_INPUT,\n  EDITOR_TO_SHADOW,\n} from '../utils/weak-maps'\nimport { findCurrentLineRange } from '../utils/lines'\nimport { EventEmitter } from './event'\nimport { Placeholder } from './placeholder'\nimport { Focused } from '../hooks/use-focused'\nimport { canForceTakeFocus } from '../utils/dom'\nimport { withInput } from './with-input'\nimport { withKeydown } from './with-keydown'\nimport { withNormalizeNode } from './with-normalize-node'\nimport { withDataTransfer } from './with-data-transfer'\nimport { getWordRange } from '../utils/text'\nimport { ReadOnly } from '../hooks/use-read-only'\n\n/**\n * `withEditable` adds React and DOM specific behaviors to the editor.\n *\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\n * this plugin.\n *\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\n */\nexport const withEditable = <T extends Editor>(editor: T) => {\n  const e = editor as T & Editable\n\n  withInput(e)\n\n  withKeydown(e)\n\n  withNormalizeNode(e)\n\n  withDataTransfer(e)\n\n  const { apply, onChange, deleteBackward, deleteForward } = e\n\n  // The WeakMap which maps a key to a specific HTMLElement must be scoped to the editor instance to\n  // avoid collisions between editors in the DOM that share the same value.\n  EDITOR_TO_KEY_TO_ELEMENT.set(e, new WeakMap())\n\n  e.deleteForward = unit => {\n    const { selection } = editor\n\n    if (selection && Range.isCollapsed(selection)) {\n      const [cell] = Editor.nodes(editor, {\n        match: n => e.isGridCell(n),\n      })\n\n      if (cell) {\n        const [, cellPath] = cell\n        const end = Editor.end(editor, cellPath)\n        if (Point.equals(selection.anchor, end)) {\n          return\n        }\n      }\n    }\n    deleteForward(unit)\n  }\n\n  e.deleteBackward = unit => {\n    const { selection } = editor\n\n    if (selection && Range.isCollapsed(selection)) {\n      const [cell] = Editor.nodes(editor, {\n        match: n => e.isGridCell(n),\n      })\n\n      if (cell) {\n        const [, cellPath] = cell\n        const start = Editor.start(editor, cellPath)\n\n        if (Point.equals(selection.anchor, start)) {\n          return\n        }\n      }\n      const list = List.above(e)\n      if (list && Editor.isStart(e, selection.focus, list[1])) {\n        List.unwrapList(e)\n        return\n      }\n    }\n    if (unit !== 'line') {\n      return deleteBackward(unit)\n    }\n\n    if (selection && Range.isCollapsed(selection)) {\n      const parentBlockEntry = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at: selection,\n      })\n\n      if (parentBlockEntry) {\n        const [, parentBlockPath] = parentBlockEntry\n        const parentElementRange = Editor.range(editor, parentBlockPath, selection.anchor)\n\n        const currentLineRange = findCurrentLineRange(e, parentElementRange)\n\n        if (!Range.isCollapsed(currentLineRange)) {\n          Transforms.delete(editor, { at: currentLineRange })\n        }\n      }\n    }\n  }\n\n  // This attempts to reset the NODE_TO_KEY entry to the correct value\n  // as apply() changes the object reference and hence invalidates the NODE_TO_KEY entry\n  e.apply = (op: Operation) => {\n    const matches: [Path, Key][] = []\n\n    switch (op.type) {\n      case 'insert_text':\n      case 'remove_text':\n      case 'set_node':\n      case 'split_node': {\n        matches.push(...getMatches(e, op.path))\n        break\n      }\n\n      case 'set_selection': {\n        break\n      }\n\n      case 'insert_node':\n      case 'remove_node': {\n        matches.push(...getMatches(e, Path.parent(op.path)))\n        break\n      }\n\n      case 'merge_node': {\n        const prevPath = Path.previous(op.path)\n        matches.push(...getMatches(e, prevPath))\n        break\n      }\n\n      case 'move_node': {\n        const commonPath = Path.common(Path.parent(op.path), Path.parent(op.newPath))\n        matches.push(...getMatches(e, commonPath))\n        break\n      }\n    }\n\n    apply(op)\n\n    for (const [path, key] of matches) {\n      const [node] = Editor.node(e, path)\n      NODE_TO_KEY.set(node, key)\n    }\n    if (!Editable.isFocused(e) && canForceTakeFocus()) {\n      e.focus()\n    }\n  }\n\n  e.on = (type, handler, prepend) => {\n    EventEmitter.on(e, type, handler, prepend)\n  }\n\n  e.off = (type, handler) => {\n    EventEmitter.off(e, type, handler)\n  }\n\n  e.once = (type, handler, prepend) => {\n    EventEmitter.on(e, type, handler, prepend)\n  }\n\n  e.emit = (type, ...args) => {\n    EventEmitter.emit(e, type, ...args)\n  }\n\n  let prevSelection: Range | null = null\n  let prevAnchorNode: Node | null = null\n  let prevFocusNode: Node | null = null\n\n  e.onChange = () => {\n    if (\n      ((!prevSelection || !e.selection) && prevSelection !== e.selection) ||\n      (prevSelection &&\n        e.selection &&\n        (!Range.equals(prevSelection, e.selection) ||\n          prevAnchorNode !== Node.get(e, e.selection.anchor.path) ||\n          prevFocusNode !== Node.get(e, e.selection.focus.path)))\n    ) {\n      e.onSelectionChange()\n      prevSelection = e.selection ? Object.assign({}, e.selection) : null\n      prevAnchorNode = e.selection ? Node.get(e, e.selection.anchor.path) : null\n      prevFocusNode = e.selection ? Node.get(e, e.selection.focus.path) : null\n    }\n    Placeholder.refresh(e)\n    onChange()\n    e.emit('change')\n  }\n\n  e.blur = (): void => {\n    const shadow = EDITOR_TO_SHADOW.get(editor)\n    const textarea = EDITOR_TO_INPUT.get(editor)\n    if (textarea && shadow && shadow.activeElement !== textarea) {\n      textarea.blur()\n    }\n  }\n  /**\n   * Focus the editor.\n   */\n  e.focus = (start): void => {\n    if (!editor.selection) {\n      const path = Editable.findPath(e, e)\n      const point = start ? Editor.start(e, path) : Editor.end(e, path)\n      Transforms.select(e, point)\n    } else if (start === true) {\n      const path = Editable.findPath(e, e)\n      Transforms.select(e, Editor.start(e, path))\n    } else if (start === false) {\n      const path = Editable.findPath(e, e)\n      Transforms.select(e, Editor.end(e, path))\n    }\n\n    const shadow = EDITOR_TO_SHADOW.get(editor)\n    const textarea = EDITOR_TO_INPUT.get(editor)\n    if (textarea && shadow && shadow.activeElement !== textarea) {\n      textarea.focus({ preventScroll: true })\n    }\n  }\n\n  e.selectWord = (options = {}) => {\n    const { at, edge = 'focus' } = options\n    if (at) {\n      Transforms.select(e, at)\n    }\n    const { selection } = e\n    if (!selection) return\n    const point = ['focus', 'end'].includes(edge) ? Range.end(selection) : Range.start(selection)\n    const { text, offset } = Editable.findTextOffsetOnLine(e, point)\n    if (text) {\n      const { path } = point\n      const [startOffset, endOffset] = getWordRange(text, offset)\n      Transforms.select(e, {\n        anchor: Editable.findPointOnLine(e, path, startOffset, true),\n        focus: Editable.findPointOnLine(e, path, endOffset),\n      })\n      e.onSelectEnd()\n    }\n  }\n\n  e.selectLine = (options = {}) => {\n    const { at, edge = 'focus' } = options\n    if (at) {\n      Transforms.select(e, at)\n    }\n    const { selection } = e\n    if (!selection) return\n    const point = ['focus', 'end'].includes(edge) ? Range.end(selection) : Range.start(selection)\n    const { path } = point\n    const node = Node.get(e, path)\n    let linePath = path\n    if (!Editor.isBlock(e, node)) {\n      const block = Editor.above(e, {\n        match: n => Editor.isBlock(e, n),\n        at: path,\n      })\n\n      linePath = block?.[1] ?? path.slice(0, 1)\n    }\n\n    const range = Editor.range(e, linePath)\n    Transforms.select(e, range)\n    e.onSelectEnd()\n  }\n\n  e.onKeyup = (event: KeyboardEvent) => {\n    if (event.key.toLowerCase() === 'shift') {\n      IS_SHIFT_PRESSED.set(editor, false)\n    }\n    e.emit('keyup', event)\n  }\n\n  e.onFocus = () => {\n    e.focus()\n    Placeholder.refresh(e)\n    e.emit('focus')\n  }\n\n  e.onBlur = () => {\n    Placeholder.refresh(e)\n    e.emit('blur')\n  }\n\n  e.onSelectStart = () => {\n    e.emit('selectstart')\n  }\n\n  e.onSelecting = () => {\n    e.emit('selecting')\n  }\n\n  e.onSelectEnd = () => {\n    e.emit('selectend')\n  }\n\n  e.onSelectionChange = () => {\n    e.emit('selectionchange')\n  }\n\n  e.onTouchHold = event => {\n    e.emit('touchhold', event)\n  }\n\n  e.onTouchTrack = () => {\n    e.emit('touchtrack')\n  }\n\n  e.onContextMenu = event => {\n    e.emit('contextmenu', event)\n  }\n\n  e.onDestory = () => {\n    e.emit('destory')\n  }\n\n  e.renderElementAttributes = ({ attributes }) => {\n    return attributes\n  }\n\n  e.renderLeafAttributes = ({ attributes }) => {\n    return attributes\n  }\n\n  e.renderElement = (props: RenderElementProps) => {\n    const { attributes, children, element } = props\n    const Tag = e.isInline(element) ? 'span' : 'div'\n    return <Tag {...attributes}>{children}</Tag>\n  }\n\n  e.renderLeaf = (props: RenderLeafProps) => {\n    const { attributes, children } = props\n    return <span {...attributes}>{children}</span>\n  }\n\n  e.renderPlaceholder = ({ attributes, children }) => {\n    return (\n      <span\n        style={{\n          pointerEvents: 'none',\n          userSelect: 'none',\n          width: '100%',\n        }}\n      >\n        <span\n          style={{\n            position: 'absolute',\n            opacity: '0.333',\n            width: 'fit-content',\n            whiteSpace: 'nowrap',\n            textIndent: 'initial',\n            textOverflow: 'ellipsis',\n            maxWidth: '100%',\n            overflow: 'hidden',\n          }}\n          {...attributes}\n        >\n          {children}\n        </span>\n      </span>\n    )\n  }\n\n  const { insertBreak } = e\n\n  e.insertBreak = () => {\n    const { selection } = editor\n\n    if (!Editable.isEditor(editor) || !selection || Range.isExpanded(selection)) {\n      insertBreak()\n      return\n    }\n    const entrie = List.above(editor)\n    if (!entrie) {\n      insertBreak()\n      return\n    }\n    List.splitList(editor)\n  }\n\n  e.insertFile = (_, range) => {\n    if (range) {\n      Transforms.select(e, range)\n    }\n  }\n\n  return e\n}\n\nconst getMatches = (e: Editable, path: Path) => {\n  const matches: [Path, Key][] = []\n  for (const [n, p] of Editor.levels(e, { at: path })) {\n    const key = Editable.findKey(e, n)\n    matches.push([p, key])\n  }\n  return matches\n}\n","/**\n * Utilities for single-line deletion\n */\n\nimport { Range, Editor } from '@editablejs/models'\nimport { Editable } from '../plugin/editable'\n\nconst doRectsIntersect = (rect: DOMRect, compareRect: DOMRect) => {\n  const middle = (compareRect.top + compareRect.bottom) / 2\n\n  return rect.top <= middle && rect.bottom >= middle\n}\n\nconst areRangesSameLine = (editor: Editable, range1: Range, range2: Range) => {\n  const rect1 = Editable.toDOMRange(editor, range1).getBoundingClientRect()\n  const rect2 = Editable.toDOMRange(editor, range2).getBoundingClientRect()\n\n  return doRectsIntersect(rect1, rect2) && doRectsIntersect(rect2, rect1)\n}\n\n/**\n * A helper utility that returns the end portion of a `Range`\n * which is located on a single line.\n *\n * @param {Editor} editor The editor object to compare against\n * @param {Range} parentRange The parent range to compare against\n * @returns {Range} A valid portion of the parentRange which is one a single line\n */\nexport const findCurrentLineRange = (editor: Editable, parentRange: Range): Range => {\n  const parentRangeBoundary = Editor.range(editor, Range.end(parentRange))\n  const positions = Array.from(Editor.positions(editor, { at: parentRange }))\n\n  let left = 0\n  let right = positions.length\n  let middle = Math.floor(right / 2)\n\n  if (areRangesSameLine(editor, Editor.range(editor, positions[left]), parentRangeBoundary)) {\n    return Editor.range(editor, positions[left], parentRangeBoundary)\n  }\n\n  if (positions.length < 2) {\n    return Editor.range(editor, positions[positions.length - 1], parentRangeBoundary)\n  }\n\n  while (middle !== positions.length && middle !== left) {\n    if (areRangesSameLine(editor, Editor.range(editor, positions[middle]), parentRangeBoundary)) {\n      right = middle\n    } else {\n      left = middle\n    }\n\n    middle = Math.floor((left + right) / 2)\n  }\n\n  return Editor.range(editor, positions[right], parentRangeBoundary)\n}\n","export type Listener = (...args: any[]) => void\n\nexport class Emitter {\n  static listenerCount(emitter: Emitter, type: string | number): number {\n    return emitter.listenerCount(type)\n  }\n\n  static defaultMaxListeners: number = 10\n\n  events: Record<string | number, Listener | Listener[]> = {}\n\n  maxListeners: number | undefined = undefined\n\n  eventsCount = 0\n\n  listenerCount(type: string | number): number {\n    const evlistener = this.events[type]\n\n    if (typeof evlistener === 'function') {\n      return 1\n    } else if (evlistener !== undefined) {\n      return evlistener.length\n    }\n\n    return 0\n  }\n\n  eventNames(): Array<string | number> {\n    return Object.keys(this.events)\n  }\n\n  setMaxListeners(count: number): this {\n    this.maxListeners = count\n    return this\n  }\n\n  getMaxListeners(): number {\n    return this.maxListeners ?? Emitter.defaultMaxListeners\n  }\n\n  emit(type: string | number, ...args: any[]): boolean {\n    const handler = this.events[type]\n\n    if (handler === undefined) return false\n\n    if (typeof handler === 'function') {\n      handler(...args)\n    } else {\n      const len = handler.length\n      for (let i = 0; i < len; ++i) handler[i](...args)\n    }\n\n    return true\n  }\n\n  on(type: string | number, listener: Listener, prepend = false): this {\n    let existing = this.events[type]\n    if (existing === undefined) {\n      // Optimize the case of one listener. Don't need the extra array object.\n      this.events[type] = listener\n      ++this.eventsCount\n    } else {\n      if (typeof existing === 'function') {\n        // Adding the second element, need to change to array.\n        existing = this.events[type] = prepend ? [listener, existing] : [existing, listener]\n        // If we've already got an array, just append.\n      } else if (prepend) {\n        existing.unshift(listener)\n      } else {\n        existing.push(listener)\n      }\n\n      // Check for listener leak\n      const maxCount = this.getMaxListeners()\n      if (maxCount > 0 && existing.length > maxCount) {\n        // No error code for this since it is a Warning\n        // eslint-disable-next-line no-restricted-syntax\n        const e = new Error(\n          'Possible EventEmitter memory leak detected. ' +\n            existing.length +\n            ' ' +\n            String(type) +\n            ' listeners ' +\n            'added. Use emitter.setMaxListeners() to ' +\n            'increase limit',\n        )\n        console.warn(e)\n      }\n    }\n\n    return this\n  }\n\n  off(type: string | number, listener: Listener): this {\n    const list = this.events[type]\n    if (list === undefined) return this\n\n    if (list === listener) {\n      if (--this.eventsCount === 0) this.events = {}\n      else {\n        delete this.events[type]\n      }\n    } else if (typeof list !== 'function') {\n      let position = -1\n\n      for (let i = list.length - 1; i >= 0; i--) {\n        if (list[i] === listener) {\n          position = i\n          break\n        }\n      }\n\n      if (position < 0) return this\n\n      if (position === 0) list.shift()\n      else {\n        list.splice(position, 1)\n      }\n\n      if (list.length === 1) this.events[type] = list[0]\n    }\n\n    return this\n  }\n\n  once(type: string | number, listener: Listener, prepend = false): this {\n    const wrapper = (...args: any[]) => {\n      this.off(type, wrapper)\n      listener(...args)\n    }\n    return this.on(type, wrapper, prepend)\n  }\n}\n","import { Editable } from './editable'\nimport { Emitter } from './emitter'\n\nconst EDITOR_TO_EVENT: WeakMap<Editable, Emitter> = new WeakMap()\n\ntype EventEndingKey<\n  Set,\n  Needle extends string,\n  Key extends keyof Set = keyof Set,\n> = Key extends `${Needle}${infer _X}` ? (_X extends `` ? never : _X) : never\n\ntype EndingKey = EventEndingKey<Editable, 'on'>\n\nexport type EventType = Lowercase<EndingKey>\n\nexport type EventHandler<\n  T extends EventType,\n  Key extends EndingKey = EndingKey,\n> = Key extends `${Lowercase<Key>}`\n  ? never\n  : T extends Lowercase<Key>\n  ? Editable[`on${Key}`]\n  : never\n\nexport const EventEmitter = {\n  get: (editor: Editable) => {\n    let event = EDITOR_TO_EVENT.get(editor)\n    if (!event) {\n      event = new Emitter()\n      EDITOR_TO_EVENT.set(editor, event)\n    }\n    return event\n  },\n  on: <T extends EventType>(\n    editor: Editable,\n    type: T,\n    handler: EventHandler<T>,\n    prepend = false,\n  ) => {\n    EventEmitter.get(editor).on(type, handler, prepend)\n  },\n\n  off: <T extends EventType>(editor: Editable, type: T, handler: EventHandler<T>) => {\n    EventEmitter.get(editor).off(type, handler)\n  },\n\n  once: <T extends EventType>(\n    editor: Editable,\n    type: T,\n    handler: EventHandler<T>,\n    prepend = false,\n  ) => {\n    EventEmitter.get(editor).once(type, handler, prepend)\n  },\n\n  emit: <T extends EventType>(editor: Editable, type: T, ...args: Parameters<EventHandler<T>>) => {\n    EventEmitter.get(editor).emit(type, ...args)\n  },\n}\n","import { CompositionText, Editor, Transforms, Range, Text } from '@editablejs/models'\nimport { IS_COMPOSING } from '../utils/weak-maps'\nimport { Editable } from './editable'\n\nexport const withInput = <T extends Editor>(editor: T) => {\n  const e = editor as T & Editable\n\n  e.onInput = (value: string) => {\n    if (!editor.selection) return\n    if (Editable.isComposing(editor)) {\n      const { selection, marks } = editor\n      let [node, path] = Editor.node(editor, selection)\n      if (marks) {\n        // 使用零宽字符绕过slate里面不能插入空字符的问题。组合输入法完成后会删除掉\n        const compositionText: CompositionText = {\n          text: '\\u200b',\n          ...marks,\n          composition: {\n            text: value,\n            offset: 0,\n            isEmpty: true,\n          },\n        }\n        Transforms.insertNodes(editor, compositionText)\n        e.marks = null\n      } else if (Text.isText(node)) {\n        const composition = CompositionText.isCompositionText(node) ? node.composition : null\n        const offset = composition?.offset ?? Range.start(selection).offset\n\n        Transforms.setNodes<CompositionText>(\n          editor,\n          {\n            composition: {\n              ...composition,\n              text: value,\n              offset,\n            },\n          },\n          { at: path },\n        )\n        const point = { path, offset: offset + value.length }\n        Transforms.select(editor, {\n          anchor: point,\n          focus: point,\n        })\n      }\n    } else {\n      editor.insertText(value)\n    }\n    e.emit('input', value)\n  }\n\n  e.onBeforeInput = value => {\n    e.emit('beforeinput', value)\n  }\n\n  e.onCompositionStart = data => {\n    if (editor.selection && Range.isExpanded(editor.selection)) {\n      Editor.deleteFragment(editor)\n    }\n    IS_COMPOSING.set(editor, true)\n    e.emit('compositionstart', data)\n  }\n\n  e.onCompositionEnd = (value: string) => {\n    const { selection } = editor\n    if (!selection) return\n    const [node, path] = Editor.node(editor, selection)\n    if (Text.isText(node)) {\n      const composition = CompositionText.isCompositionText(node) ? node.composition : null\n      Transforms.setNodes<CompositionText>(\n        editor,\n        {\n          composition: undefined,\n        },\n        { at: path },\n      )\n      const point = { path, offset: composition?.offset ?? selection.anchor.offset }\n      const range = composition?.isEmpty\n        ? {\n            anchor: { path, offset: 0 },\n            focus: { path, offset: 1 },\n          }\n        : point\n      Transforms.select(editor, range)\n\n      IS_COMPOSING.set(editor, false)\n      Transforms.insertText(editor, value)\n    }\n    e.emit('compositionend', value)\n  }\n\n  return e\n}\n","import { Editor, Transforms, Node, Range } from '@editablejs/models'\nimport getDirection from 'direction'\nimport Hotkeys from '../utils/hotkeys'\nimport { getWordOffsetBackward, getWordOffsetForward } from '../utils/text'\nimport { IS_PASTE_TEXT, IS_SHIFT_PRESSED } from '../utils/weak-maps'\nimport { Editable } from './editable'\n\nexport const withKeydown = <T extends Editor>(editor: T) => {\n  const e = editor as T & Editable\n\n  e.onKeydown = (event: KeyboardEvent) => {\n    e.emit('keydown', event)\n    if (event.defaultPrevented) return\n    const { selection } = editor\n    const element = editor.children[selection !== null ? selection.focus.path[0] : 0]\n    const isRTL = getDirection(Node.string(element)) === 'rtl'\n\n    if (Hotkeys.isShift(event)) {\n      IS_SHIFT_PRESSED.set(e, true)\n    }\n\n    if (Hotkeys.isSelectAll(event)) {\n      event.preventDefault()\n      Transforms.select(e, Editor.range(e, []))\n      return\n    }\n\n    if (Hotkeys.isCut(event)) {\n      event.preventDefault()\n      e.cut()\n      return\n    }\n\n    if (Hotkeys.isCopy(event)) {\n      event.preventDefault()\n      e.copy()\n      return\n    }\n\n    if (Hotkeys.isPaste(event)) {\n      IS_PASTE_TEXT.set(e, false)\n      return\n    }\n\n    if (Hotkeys.isPasteText(event)) {\n      IS_PASTE_TEXT.set(e, true)\n      return\n    }\n\n    if (Hotkeys.isExtendForward(event)) {\n      event.preventDefault()\n      Transforms.move(e, { edge: 'focus' })\n      return\n    }\n\n    if (Hotkeys.isExtendBackward(event)) {\n      event.preventDefault()\n      Transforms.move(e, { edge: 'focus', reverse: true })\n      return\n    }\n\n    if (Hotkeys.isExtendUp(event)) {\n      event.preventDefault()\n      const point = Editable.findPreviousLinePoint(e)\n      if (point && selection)\n        Transforms.select(editor, {\n          anchor: selection.anchor,\n          focus: point,\n        })\n      return\n    }\n\n    if (Hotkeys.isExtendDown(event)) {\n      event.preventDefault()\n      const point = Editable.findNextLinePoint(e)\n      if (point && selection)\n        Transforms.select(editor, {\n          anchor: selection.anchor,\n          focus: point,\n        })\n      return\n    }\n\n    if (Hotkeys.isMoveUp(event)) {\n      event.preventDefault()\n      const point = Editable.findPreviousLinePoint(e)\n      if (point) Transforms.select(editor, point)\n      return\n    }\n\n    if (Hotkeys.isMoveDown(event)) {\n      event.preventDefault()\n      const point = Editable.findNextLinePoint(e)\n      if (point) Transforms.select(editor, point)\n      return\n    }\n\n    if (Hotkeys.isExtendLineBackward(event)) {\n      event.preventDefault()\n      Transforms.move(e, {\n        unit: 'line',\n        edge: 'focus',\n        reverse: true,\n      })\n      return\n    }\n\n    if (Hotkeys.isExtendLineForward(event)) {\n      event.preventDefault()\n      Transforms.move(e, { unit: 'line', edge: 'focus' })\n      return\n    }\n\n    if (Hotkeys.isMoveWordBackward(event)) {\n      event.preventDefault()\n\n      if (selection && Range.isExpanded(selection)) {\n        Transforms.collapse(editor, { edge: 'focus' })\n      }\n      if (selection) {\n        const { focus } = selection\n        const { path: focusPath } = focus\n        if (Editor.isStart(editor, focus, focusPath)) {\n          Transforms.move(e, { reverse: !isRTL })\n          return\n        }\n        const { text, offset } = Editable.findTextOffsetOnLine(e, focus)\n        if (text) {\n          const wordOffset = getWordOffsetBackward(text, offset)\n          const newPoint = Editable.findPointOnLine(e, focusPath, wordOffset)\n          Transforms.select(editor, newPoint)\n          return\n        }\n      }\n      Transforms.move(e, { unit: 'word', reverse: !isRTL })\n      return\n    }\n\n    if (Hotkeys.isMoveWordForward(event)) {\n      event.preventDefault()\n\n      if (selection && Range.isExpanded(selection)) {\n        Transforms.collapse(editor, { edge: 'focus' })\n      }\n      if (selection) {\n        const { focus } = selection\n        const { path: focusPath } = focus\n        if (Editor.isEnd(editor, focus, focusPath)) {\n          Transforms.move(e, { reverse: isRTL })\n          return\n        }\n        const { text, offset } = Editable.findTextOffsetOnLine(e, focus)\n        if (text) {\n          const wordOffset = getWordOffsetForward(text, offset)\n          Transforms.select(editor, Editable.findPointOnLine(e, focusPath, wordOffset))\n          return\n        }\n      }\n      Transforms.move(e, { unit: 'word', reverse: isRTL })\n      return\n    }\n\n    if (Hotkeys.isMoveBackward(event)) {\n      event.preventDefault()\n\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms.move(e, { reverse: !isRTL })\n      } else {\n        Transforms.collapse(editor, { edge: 'start' })\n      }\n\n      return\n    }\n\n    if (Hotkeys.isMoveForward(event)) {\n      event.preventDefault()\n\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms.move(e, { reverse: isRTL })\n      } else {\n        Transforms.collapse(editor, { edge: 'end' })\n      }\n\n      return\n    }\n\n    if (Hotkeys.isMoveLineStart(event)) {\n      event.preventDefault()\n\n      const point = Editable.findLineEdgePoint(e)\n      if (point) {\n        Transforms.select(editor, point)\n      }\n\n      return\n    }\n\n    if (Hotkeys.isMoveLineEnd(event)) {\n      event.preventDefault()\n\n      const point = Editable.findLineEdgePoint(e, { edge: 'end' })\n      if (point) {\n        Transforms.select(editor, point)\n      }\n\n      return\n    }\n\n    if (Hotkeys.isMoveEditorStart(event)) {\n      event.preventDefault()\n\n      e.focus(true)\n\n      return\n    }\n\n    if (Hotkeys.isMoveEditorEnd(event)) {\n      event.preventDefault()\n\n      e.focus(false)\n\n      return\n    }\n\n    if (Hotkeys.isSoftBreak(event)) {\n      event.preventDefault()\n      Editor.insertSoftBreak(editor)\n      return\n    }\n\n    if (Hotkeys.isSplitBlock(event)) {\n      event.preventDefault()\n      Editor.insertBreak(editor)\n      return\n    }\n\n    if (Hotkeys.isDeleteBackward(event)) {\n      event.preventDefault()\n      if (selection && Range.isExpanded(selection)) {\n        Editor.deleteFragment(editor)\n      } else {\n        Editor.deleteBackward(editor)\n      }\n      return\n    }\n\n    if (Hotkeys.isDeleteForward(event)) {\n      event.preventDefault()\n\n      if (selection && Range.isExpanded(selection)) {\n        Editor.deleteFragment(editor, { direction: 'forward' })\n      } else {\n        Editor.deleteForward(editor)\n      }\n\n      return\n    }\n\n    if (Hotkeys.isDeleteLineBackward(event)) {\n      event.preventDefault()\n\n      if (selection && Range.isExpanded(selection)) {\n        Editor.deleteFragment(editor, { direction: 'backward' })\n      } else {\n        Editor.deleteBackward(editor, { unit: 'line' })\n      }\n\n      return\n    }\n\n    if (Hotkeys.isDeleteLineForward(event)) {\n      event.preventDefault()\n\n      if (selection && Range.isExpanded(selection)) {\n        Editor.deleteFragment(editor, { direction: 'forward' })\n      } else {\n        Editor.deleteForward(editor, { unit: 'line' })\n      }\n\n      return\n    }\n\n    if (Hotkeys.isDeleteWordBackward(event)) {\n      event.preventDefault()\n\n      if (selection && Range.isExpanded(selection)) {\n        Editor.deleteFragment(editor, { direction: 'backward' })\n      } else {\n        Editor.deleteBackward(editor, { unit: 'word' })\n      }\n\n      return\n    }\n\n    if (Hotkeys.isDeleteWordForward(event)) {\n      event.preventDefault()\n\n      if (selection && Range.isExpanded(selection)) {\n        Editor.deleteFragment(editor, { direction: 'forward' })\n      } else {\n        Editor.deleteForward(editor, { unit: 'word' })\n      }\n\n      return\n    }\n  }\n}\n","import { isHotkey, isCodeHotkey, isKeyHotkey } from 'is-hotkey'\nimport { IS_APPLE } from './environment'\n\n/**\n * Hotkey mappings for each platform.\n */\n\nconst HOTKEYS: Record<string, string | string[]> = {\n  compose: ['down', 'left', 'right', 'up', 'backspace', 'enter'],\n  selectAll: 'mod+a',\n  cut: 'mod+x',\n  copy: 'mod+c',\n  paste: 'mod+v',\n  pasteText: 'mod+shift+v',\n  moveUp: 'up',\n  moveDown: 'down',\n  moveBackward: 'left',\n  moveForward: 'right',\n  shift: 'shift',\n  moveWordBackward: 'ctrl+left',\n  moveWordForward: 'ctrl+right',\n  extendUp: 'shift+up',\n  extendDown: 'shift+down',\n  deleteBackward: 'shift?+backspace',\n  deleteForward: 'shift?+delete',\n  extendBackward: 'shift+left',\n  extendForward: 'shift+right',\n  insertSoftBreak: 'shift+enter',\n  splitBlock: 'enter',\n  undo: 'mod+z',\n}\n\nconst APPLE_HOTKEYS: Record<string, string | string[]> = {\n  moveLineBackward: 'opt+up',\n  moveLineForward: 'opt+down',\n  moveWordBackward: 'opt+left',\n  moveWordForward: 'opt+right',\n  moveLineStart: 'cmd+left',\n  moveLineEnd: 'cmd+right',\n  moveEditorStart: 'cmd+up',\n  moveEditorEnd: 'cmd+down',\n  deleteBackward: ['ctrl+backspace', 'ctrl+h'],\n  deleteForward: ['ctrl+delete', 'ctrl+d'],\n  deleteLineBackward: 'cmd+shift?+backspace',\n  deleteLineForward: ['cmd+shift?+delete', 'ctrl+k'],\n  deleteWordBackward: 'opt+shift?+backspace',\n  deleteWordForward: 'opt+shift?+delete',\n  extendLineBackward: 'opt+shift+up',\n  extendLineForward: 'opt+shift+down',\n  redo: 'cmd+shift+z',\n  transposeCharacter: 'ctrl+t',\n}\n\nconst WINDOWS_HOTKEYS: Record<string, string | string[]> = {\n  deleteWordBackward: 'ctrl+shift?+backspace',\n  deleteWordForward: 'ctrl+shift?+delete',\n  redo: ['ctrl+y', 'ctrl+shift+z'],\n}\n\n/**\n * Create a platform-aware hotkey checker.\n */\n\nconst create = (key: string) => {\n  const generic = HOTKEYS[key]\n  const apple = APPLE_HOTKEYS[key]\n  const windows = WINDOWS_HOTKEYS[key]\n  const isGeneric = generic && isKeyHotkey(generic)\n  const isApple = apple && isKeyHotkey(apple)\n  const isWindows = windows && isKeyHotkey(windows)\n\n  return (event: KeyboardEvent) => {\n    if (isGeneric && isGeneric(event)) return true\n    if (IS_APPLE && isApple && isApple(event)) return true\n    if (!IS_APPLE && isWindows && isWindows(event)) return true\n    return false\n  }\n}\n\n/**\n * Hotkeys.\n */\n\nconst Hotkeys = {\n  isSelectAll: create('selectAll'),\n  isCut: create('cut'),\n  isCopy: create('copy'),\n  isPaste: create('paste'),\n  isPasteText: create('pasteText'),\n  isMoveUp: create('moveUp'),\n  isMoveDown: create('moveDown'),\n  isCompose: create('compose'),\n  isMoveBackward: create('moveBackward'),\n  isMoveForward: create('moveForward'),\n  isDeleteBackward: create('deleteBackward'),\n  isDeleteForward: create('deleteForward'),\n  isDeleteLineBackward: create('deleteLineBackward'),\n  isDeleteLineForward: create('deleteLineForward'),\n  isDeleteWordBackward: create('deleteWordBackward'),\n  isDeleteWordForward: create('deleteWordForward'),\n  isExtendUp: create('extendUp'),\n  isExtendDown: create('extendDown'),\n  isExtendBackward: create('extendBackward'),\n  isExtendForward: create('extendForward'),\n  isExtendLineBackward: create('extendLineBackward'),\n  isExtendLineForward: create('extendLineForward'),\n  isMoveLineBackward: create('moveLineBackward'),\n  isMoveLineForward: create('moveLineForward'),\n  isMoveWordBackward: create('moveWordBackward'),\n  isMoveWordForward: create('moveWordForward'),\n  isMoveLineStart: create('moveLineStart'),\n  isMoveLineEnd: create('moveLineEnd'),\n  isMoveEditorStart: create('moveEditorStart'),\n  isMoveEditorEnd: create('moveEditorEnd'),\n  isShift: create('shift'),\n  isRedo: create('redo'),\n  isSoftBreak: create('insertSoftBreak'),\n  isSplitBlock: create('splitBlock'),\n  isTransposeCharacter: create('transposeCharacter'),\n  isUndo: create('undo'),\n}\n\nexport default Hotkeys\n\nfunction match(\n  keys: string | string[] | ((e: KeyboardEvent) => boolean),\n  event: KeyboardEvent,\n): boolean\nfunction match<T extends string = string>(\n  keys: Record<T, string | string[] | ((e: KeyboardEvent) => boolean)>,\n  event: KeyboardEvent,\n): T | false\nfunction match<T extends string = string>(\n  keys:\n    | string\n    | string[]\n    | ((e: KeyboardEvent) => boolean)\n    | Record<T, string | string[] | ((e: KeyboardEvent) => boolean)>,\n  event: KeyboardEvent,\n): T | boolean {\n  if (typeof keys === 'string' || Array.isArray(keys)) {\n    return isHotkey(keys, event)\n  } else if (typeof keys === 'function') {\n    return keys(event)\n  } else {\n    for (const key in keys) {\n      const value = keys[key]\n      if (match(value, event)) {\n        return key\n      }\n    }\n  }\n  return false\n}\nexport const Hotkey = {\n  isCode: isCodeHotkey,\n  isKey: isKeyHotkey,\n  format: (key: string, char = '+') => {\n    let keys = key.toLowerCase().split('+')\n    keys = keys.map(key => {\n      if (key === 'mod') {\n        return IS_APPLE ? '⌘' : 'Ctrl'\n      } else if (key === 'opt') {\n        return IS_APPLE ? 'Option' : 'Alt'\n      } else if (key.length > 1) {\n        return key.substring(0, 1).toUpperCase() + key.substring(1).toLowerCase()\n      }\n      return key.toUpperCase()\n    })\n    return keys.join(char)\n  },\n  match,\n}\n","import { Editor, Transforms, Node, Path } from '@editablejs/models'\nimport { Editable } from './editable'\n\nexport const withNormalizeNode = <T extends Editor>(editor: T) => {\n  const e = editor as T & Editable\n\n  const { normalizeNode } = editor\n\n  e.normalizeNode = entry => {\n    const [node, path] = entry\n    if (Editor.isBlock(e, node)) {\n      const { type, ...attributes } = node\n      let isUnwrap = false\n      const isParagraph = !type || type === 'paragraph'\n      // 相同type类的block不嵌套，paragraph 下不能嵌套block节点\n      for (const [child, childPath] of Node.children(editor, path)) {\n        if (Editor.isBlock(e, child)) {\n          if (!isUnwrap && !isParagraph && child.type === type) {\n            Transforms.unwrapNodes(editor, { at: childPath })\n            return\n          } else if (isParagraph) {\n            Transforms.setNodes(editor, attributes, { at: childPath })\n            isUnwrap = true\n          }\n        }\n      }\n      if (isUnwrap) {\n        Transforms.unwrapNodes(editor, { at: path })\n        return\n      }\n    }\n    normalizeNode(entry)\n  }\n\n  return e\n}\n","import { HTMLDeserializer } from '@editablejs/deserializer/html'\nimport { Editor, Transforms, Range, Node } from '@editablejs/models'\nimport { HTMLSerializer } from '@editablejs/serializer/html'\nimport { TextSerializer } from '@editablejs/serializer/text'\nimport { readClipboardData, writeClipboardData } from '../utils/clipboard'\nimport {\n  APPLICATION_FRAGMENT_TYPE,\n  DATA_EDITABLE_FRAGMENT,\n  TEXT_HTML,\n  TEXT_PLAIN,\n} from '../utils/constants'\nimport { fragmentToString, parseDataTransfer } from '../utils/data-transfer'\nimport { IS_PASTE_TEXT } from '../utils/weak-maps'\nimport { Editable } from './editable'\n\nexport const withDataTransfer = <T extends Editor>(editor: T) => {\n  const e = editor as T & Editable\n\n  e.toDataTransfer = range => {\n    const fragment = e.getFragment(range)\n    const fragmentString = fragmentToString(fragment)\n\n    const text = fragment.map(node => TextSerializer.transformWithEditor(e, node)).join('\\n')\n\n    let html = fragment.map(node => HTMLSerializer.transformWithEditor(e, node)).join('')\n    html = `<div ${DATA_EDITABLE_FRAGMENT}=\"${fragmentString}\">${html}</div>`\n    html = `<html><head><meta name=\"source\" content=\"${DATA_EDITABLE_FRAGMENT}\" /></head><body>${html}</body></html>`\n    const dataTransfer = new DataTransfer()\n    dataTransfer.setData(TEXT_PLAIN, text)\n    dataTransfer.setData(TEXT_HTML, html)\n    dataTransfer.setData(APPLICATION_FRAGMENT_TYPE, fragmentString)\n    return dataTransfer\n  }\n\n  e.onCut = event => {\n    if (event.defaultPrevented) return\n    const { selection } = e\n    const { clipboardData } = event\n    if (clipboardData) writeClipboardData(clipboardData)\n    if (selection) {\n      if (Range.isExpanded(selection)) {\n        Editor.deleteFragment(e)\n      } else {\n        const node = Node.parent(e, selection.anchor.path)\n        if (Editor.isVoid(e, node)) {\n          Transforms.delete(e)\n        }\n      }\n    }\n    e.emit('cut', event)\n  }\n\n  e.onCopy = event => {\n    if (event.defaultPrevented) return\n    const { clipboardData } = event\n    if (clipboardData) writeClipboardData(clipboardData)\n    e.emit('copy', event)\n  }\n\n  e.onPaste = event => {\n    if (event.defaultPrevented) return\n    const { clipboardData } = event\n    if (!clipboardData) return\n    event.preventDefault()\n    const { text, fragment, html, files } = parseDataTransfer(clipboardData)\n    const isPasteText = event.type === 'pasteText'\n    if (!isPasteText && fragment.length > 0) {\n      e.insertFragment(fragment)\n    } else if (!isPasteText && html) {\n      const document = new DOMParser().parseFromString(html, TEXT_HTML)\n      const fragment = HTMLDeserializer.transformWithEditor(e, document.body)\n      e.insertFragment(fragment)\n    } else {\n      const lines = text.split(/\\r\\n|\\r|\\n/)\n      let split = false\n\n      for (const line of lines) {\n        if (split) {\n          Transforms.splitNodes(e, { always: true })\n        }\n        e.normalizeSelection(selection => {\n          if (selection !== e.selection) e.selection = selection\n          e.insertText(line)\n        })\n        split = true\n      }\n    }\n    for (const file of files) {\n      e.insertFile(file)\n    }\n    e.emit('paste', event)\n  }\n\n  e.copy = range => {\n    const data = e.toDataTransfer(range)\n    const event = new ClipboardEvent('copy', { clipboardData: data })\n    e.onCopy(event)\n  }\n\n  e.cut = range => {\n    const data = e.toDataTransfer(range)\n    const event = new ClipboardEvent('copy', { clipboardData: data })\n    if (range) {\n      Transforms.select(e, range)\n    }\n    e.onCut(event)\n  }\n\n  e.insertFromClipboard = range => {\n    if (range) {\n      Transforms.select(e, range)\n    }\n    readClipboardData().then(data => {\n      const event = new ClipboardEvent('paste', { clipboardData: data })\n      e.onPaste(event)\n    })\n  }\n\n  e.insertTextFromClipboard = range => {\n    if (range) {\n      Transforms.select(e, range)\n    }\n    readClipboardData().then(data => {\n      IS_PASTE_TEXT.set(e, true)\n      const event = new ClipboardEvent('pasteText', { clipboardData: data })\n      e.onPaste(event)\n    })\n  }\n\n  return e\n}\n","import { APPLICATION_FRAGMENT_TYPE, TEXT_HTML, TEXT_PLAIN } from './constants'\nimport { matchFragmentStringFromHTML, parseDataTransferFiles } from './data-transfer'\nimport { isDOMHTMLElement } from '@editablejs/models'\n\nconst deselectCurrent = () => {\n  const selection = document.getSelection()\n  if (!selection?.rangeCount) {\n    return function () {}\n  }\n  let active: HTMLElement | null = null\n  let activeElement = document.activeElement\n  if (activeElement && activeElement.shadowRoot) {\n    activeElement = activeElement.shadowRoot.activeElement\n  }\n  if (isDOMHTMLElement(activeElement)) {\n    active = activeElement\n  }\n  const ranges: Range[] = []\n  for (var i = 0; i < selection.rangeCount; i++) {\n    ranges.push(selection.getRangeAt(i))\n  }\n  switch (\n    active?.tagName.toUpperCase() // .toUpperCase handles XHTML\n  ) {\n    case 'INPUT':\n    case 'TEXTAREA':\n      active.blur()\n      break\n\n    default:\n      active = null\n      break\n  }\n\n  selection.removeAllRanges()\n  return () => {\n    if (selection.type === 'Caret') {\n      selection.removeAllRanges()\n    }\n\n    if (!selection.rangeCount) {\n      ranges.forEach(range => {\n        selection.addRange(range)\n      })\n    }\n    if (active) {\n      active.focus()\n    }\n  }\n}\n\nexport const readClipboardDataByCommand = () => {\n  return new Promise<DataTransfer | null>((resolve, reject) => {\n    let textarea: HTMLTextAreaElement | null = null\n    let reselectPrevious: (() => void) | null = null\n\n    let selection: Selection | null = null\n    try {\n      reselectPrevious = deselectCurrent()\n\n      selection = document.getSelection()\n\n      textarea = document.createElement('textarea')\n      textarea.style.cssText = 'position: fixed; top: -9999; left: -9999; opacity: 0;'\n\n      textarea.addEventListener('paste', e => {\n        e.preventDefault()\n        e.stopPropagation()\n        resolve(e.clipboardData)\n      })\n\n      document.body.appendChild(textarea)\n\n      textarea.focus()\n\n      const successful = document.execCommand('paste')\n      if (!successful) throw new Error('paste failed')\n    } catch (error) {\n      reject(error)\n    } finally {\n      if (selection) {\n        selection.removeAllRanges()\n      }\n      if (textarea) document.body.removeChild(textarea)\n      if (reselectPrevious) reselectPrevious()\n    }\n  })\n}\n\nexport const readClipboardData = async () => {\n  let text = ''\n  let html = ''\n  let fragment = ''\n  const dataTransfer = new DataTransfer()\n  try {\n    const items = await navigator.clipboard.read()\n    for (const item of items) {\n      try {\n        text += await (await item.getType(TEXT_PLAIN)).text()\n      } catch {}\n      try {\n        html += await (await item.getType(TEXT_HTML)).text()\n      } catch {}\n      if (!fragment) {\n        try {\n          fragment = await (await item.getType(APPLICATION_FRAGMENT_TYPE)).text()\n        } catch (error) {\n          fragment = matchFragmentStringFromHTML(html)\n        }\n      }\n\n      for (const type of item.types) {\n        if (~[APPLICATION_FRAGMENT_TYPE, TEXT_PLAIN, TEXT_HTML].indexOf(type)) continue\n        const blob = await item.getType(type)\n        const file = new File([blob], 'unknow', {\n          type,\n        })\n        dataTransfer.items.add(file)\n      }\n    }\n  } catch (error) {\n    try {\n      const data = await readClipboardDataByCommand()\n      if (data) return data\n    } catch (error) {\n      console.error(error)\n    }\n  }\n  dataTransfer.setData(TEXT_PLAIN, text)\n  dataTransfer.setData(TEXT_HTML, html)\n  dataTransfer.setData(APPLICATION_FRAGMENT_TYPE, fragment)\n  return dataTransfer\n}\n\nexport const writeClipboardDataByCommand = (data: DataTransfer) => {\n  return new Promise<boolean>((resolve, reject) => {\n    let mark: HTMLElement | null = null\n    let reselectPrevious: (() => void) | null = null\n    let selection: Selection | null = null\n    let range: Range | null = null\n    try {\n      reselectPrevious = deselectCurrent()\n\n      range = document.createRange()\n      selection = document.getSelection()\n\n      mark = document.createElement('span')\n      mark.style.cssText = 'position: fixed; top: -9999;'\n      mark.ariaHidden = 'true'\n      mark.textContent = 'copy content'\n      mark.style.userSelect = 'text'\n      mark.addEventListener('copy', e => {\n        e.stopPropagation()\n        const { clipboardData } = e\n        if (clipboardData) {\n          e.preventDefault()\n          clipboardData.clearData()\n          clipboardData.setData(TEXT_PLAIN, data.getData(TEXT_PLAIN))\n          clipboardData.setData(TEXT_HTML, data.getData(TEXT_HTML))\n          clipboardData.setData(APPLICATION_FRAGMENT_TYPE, data.getData(APPLICATION_FRAGMENT_TYPE))\n          const files = parseDataTransferFiles(data)\n          for (const file of files) {\n            clipboardData.items.add(file)\n          }\n          resolve(true)\n        } else {\n          resolve(false)\n        }\n      })\n      document.body.appendChild(mark)\n\n      range.selectNodeContents(mark)\n      selection?.addRange(range)\n\n      const successful = document.execCommand('copy')\n      if (!successful) throw new Error('copy failed')\n    } catch (error) {\n      reject(error)\n    } finally {\n      if (selection) {\n        if (range && typeof selection.removeRange == 'function') {\n          selection.removeRange(range)\n        } else {\n          selection.removeAllRanges()\n        }\n      }\n      if (mark) document.body.removeChild(mark)\n      if (reselectPrevious) reselectPrevious()\n    }\n  })\n}\n\nexport const writeClipboardData = (data: DataTransfer) => {\n  try {\n    const files = parseDataTransferFiles(data)\n\n    navigator.clipboard.write([\n      new ClipboardItem({\n        [TEXT_PLAIN]: new Blob([data.getData(TEXT_PLAIN)], { type: TEXT_PLAIN }),\n        [TEXT_HTML]: new Blob([data.getData(TEXT_HTML)], { type: TEXT_HTML }),\n        // 当前不支持自定义类型\n        // https://github.com/w3c/editing/blob/gh-pages/docs/clipboard-pickling/explainer.md\n        // [APPLICATION_FRAGMENT_TYPE]: data.getData(APPLICATION_FRAGMENT_TYPE),\n        ...files.reduce((acc, file) => ({ ...acc, [file.type]: file }), {}),\n      }),\n    ])\n  } catch (error) {\n    try {\n      writeClipboardDataByCommand(data)\n    } catch (error) {\n      console.error(error)\n    }\n  }\n}\n"],"mappings":"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","names":["React","import_zustand","create","merge","import_zustand","match","key","React","import_models","import_models","React","import_models","React","import_models","React","import_models","import_models","React","rects","import_models","rects","match","element","node","range","lineRect","import_zustand","getStore","create","isFocused","import_zustand","EDITABLE_TO_FOCUSED_STORE","getStore","create","isReadOnly","match","n","window","node","nodes","textNode","block","path","scrollIntoView","String","import_jsx_runtime","React","React","import_zustand","import_zustand","create","import_jsx_runtime","Text","ranges","key","SlateText","React","import_models","import_zustand","import_models","import_zustand","create","actives","import_jsx_runtime","Element","getDirection","children","React","React","React","import_jsx_runtime","React","React","React","import_jsx_runtime","root","ReactDOM","React","import_models","React","import_zustand","import_zustand","import_models","getStore","create","rects","import_jsx_runtime","import_models","import_jsx_runtime","import_models","React","import_jsx_runtime","event","rect","React","import_zustand","import_models","create","import_zustand","React","import_models","import_jsx_runtime","import_react","import_react","import_zustand","import_lodash","import_zustand","getStore","create","predicate","merge","React","shallow","import_jsx_runtime","React","React","import_models","import_jsx_runtime","import_jsx_runtime","window","React","import_models","import_zustand","import_jsx_runtime","store","create","React","import_models","selection","React","import_models","React","import_models","import_models","import_models","import_models","import_models","import_direction","create","key","getDirection","import_models","import_models","import_html","import_text","import_models","error","document","fragment","import_jsx_runtime"]}
\ No newline at end of file
+{"version":3,"sources":["../src/index.ts","../src/utils/constants.ts","../src/utils/data-transfer.ts","../src/hooks/use-locale.ts","../src/plugin/locale.ts","../src/hooks/use-editable.tsx","../src/components/content.tsx","../src/hooks/use-children.tsx","../src/components/element.tsx","../src/components/text.tsx","../src/components/leaf.tsx","../src/components/string.tsx","../src/plugin/editable.ts","../src/utils/weak-maps.ts","../src/utils/dom.ts","../src/utils/environment.ts","../src/utils/nearby.ts","../src/utils/text.ts","../src/utils/selection.ts","../src/hooks/use-focused.ts","../src/utils/event.ts","../src/hooks/use-read-only.ts","../src/hooks/use-isomorphic-layout-effect.ts","../src/hooks/use-decorate.ts","../src/plugin/decorate.ts","../src/hooks/use-placeholder.ts","../src/plugin/placeholder.ts","../src/hooks/use-node-selected.ts","../src/hooks/use-node-focused.ts","../src/hooks/use-grid.ts","../src/hooks/use-multiple-click.ts","../src/hooks/use-cancellable-promises.ts","../src/components/shadow.tsx","../src/components/caret.tsx","../src/hooks/use-selection-drawing.ts","../src/plugin/selection-drawing.ts","../src/components/selection.tsx","../src/components/input.tsx","../src/hooks/use-drag.ts","../src/plugin/drag.ts","../src/components/drag-caret.tsx","../src/components/slot.tsx","../src/hooks/use-slot.ts","../src/plugin/solt.ts","../src/components/touch-point.tsx","../src/components/editable.tsx","../src/hooks/use-grid-selection.ts","../src/hooks/use-grid-selection-rect.ts","../src/hooks/use-grid-selected.ts","../src/plugin/with-editable.tsx","../src/utils/lines.ts","../src/plugin/emitter.ts","../src/plugin/event.ts","../src/plugin/with-input.ts","../src/plugin/with-keydown.ts","../src/utils/hotkeys.ts","../src/plugin/with-normalize-node.ts","../src/plugin/with-data-transfer.ts","../src/utils/clipboard.ts"],"sourcesContent":["// Constants\nexport * from './utils/constants'\n\n// FormatData\nexport * as FormatData from './utils/data-transfer'\n\n// Locale\nexport * from './hooks/use-locale'\n\n// Component\nexport { ContentEditable } from './components/content'\nexport { EditableProvider } from './components/editable'\n\n// Hooks\nexport { useIsomorphicLayoutEffect } from './hooks/use-isomorphic-layout-effect'\nexport { useEditableStatic, useEditable, useEditableStore } from './hooks/use-editable'\nexport { useFocused } from './hooks/use-focused'\nexport { useReadOnly } from './hooks/use-read-only'\nexport { useNodeSelected } from './hooks/use-node-selected'\nexport { useNodeFocused } from './hooks/use-node-focused'\nexport * from './hooks/use-drag'\nexport * from './hooks/use-selection-drawing'\nexport * from './hooks/use-slot'\n\n// Grid Hooks\nexport { useGrid } from './hooks/use-grid'\nexport { useGridSelection } from './hooks/use-grid-selection'\nexport { useGridSelectionRect } from './hooks/use-grid-selection-rect'\nexport { useGridSelected } from './hooks/use-grid-selected'\n\n// Plugin\nexport { Editable } from './plugin/editable'\nexport { withEditable } from './plugin/with-editable'\nexport * from './plugin/event'\nexport * from './plugin/drag'\nexport * from './plugin/solt'\nexport * from './plugin/locale'\nexport * from './plugin/decorate'\nexport * from './plugin/placeholder'\nexport * from './plugin/selection-drawing'\n\n// Environment\nexport * from './utils/environment'\n// Dom\nexport * from './utils/dom'\n// DataTransfer\nexport * from './utils/data-transfer'\n// Clipboard\nexport * from './utils/clipboard'\n\nexport type {\n  RenderElementProps,\n  RenderLeafProps,\n  RenderElementAttributes,\n  RenderLeafAttributes,\n  ElementAttributes,\n  NodeAttributes,\n  TextAttributes,\n  PlaceholderAttributes,\n} from './plugin/editable'\n\nexport { useCancellablePromises, cancellablePromise } from './hooks/use-cancellable-promises'\n\nexport { Hotkey } from './utils/hotkeys'\n","export const APPLICATION_FRAGMENT_TYPE = 'application/x-editable-fragment'\nexport const TEXT_HTML = 'text/html'\nexport const TEXT_PLAIN = 'text/plain'\nexport const DATA_EDITABLE_FRAGMENT = `data-ea-fragment`\nexport const DATA_EDITABLE_NODE = `data-ea-node`\nexport const DATA_EDITABLE_INLINE = `data-ea-inline`\nexport const DATA_EDITABLE_STRING = `data-ea-string`\nexport const DATA_EDITABLE_COMPOSITION = `data-ea-composition`\nexport const DATA_EDITABLE_ZERO_WIDTH = `data-ea-zero-width`\nexport const DATA_EDITABLE_LENGTH = `data-ea-length`\nexport const DATA_EDITABLE_VOID = `data-ea-void`\nexport const DATA_EDITABLE_PLACEHOLDER = `data-ea-placeholder`\nexport const DATA_EDITABLE_LEAF = `data-ea-leaf`\n\nexport const Constants = {\n  applicationType: APPLICATION_FRAGMENT_TYPE,\n  htmlType: TEXT_HTML,\n  plainType: TEXT_PLAIN,\n  dataFragment: DATA_EDITABLE_FRAGMENT,\n  dataNode: DATA_EDITABLE_NODE,\n  dataInline: DATA_EDITABLE_INLINE,\n  dataString: DATA_EDITABLE_STRING,\n  dataComposition: DATA_EDITABLE_COMPOSITION,\n  dataZeroWidth: DATA_EDITABLE_ZERO_WIDTH,\n  dataLength: DATA_EDITABLE_LENGTH,\n  dataVoid: DATA_EDITABLE_VOID,\n  dataPlaceholder: DATA_EDITABLE_PLACEHOLDER,\n  dataLeaf: DATA_EDITABLE_LEAF,\n}\n","import { Descendant } from '@editablejs/models'\nimport {\n  APPLICATION_FRAGMENT_TYPE,\n  DATA_EDITABLE_FRAGMENT,\n  TEXT_HTML,\n  TEXT_PLAIN,\n} from './constants'\n\ninterface DataTransferFormatData {\n  html: string\n  text: string\n  fragment: Descendant[]\n  files: File[]\n}\n\n/**\n * Convert fragment to string\n * @param fragment\n * @returns string representation of the fragment\n **/\nexport const fragmentToString = (fragment: Descendant[]) => {\n  const string = JSON.stringify(fragment)\n  return window.btoa(encodeURIComponent(string))\n}\n\n/**\n * Parse fragment from string\n * @param fragment string representation of the fragment\n * @returns fragment\n **/\nexport const parseFragmentFromString = (fragment: string): Descendant[] => {\n  const string = decodeURIComponent(window.atob(fragment))\n  try {\n    return JSON.parse(string)\n  } catch (error) {\n    return []\n  }\n}\n\n/**\n * Match fragment string from HTML\n * @param html\n * @returns string representation of the fragment\n **/\nexport const matchFragmentStringFromHTML = (html: string) => {\n  const reg = new RegExp(`${DATA_EDITABLE_FRAGMENT}=\"(.+?)\"`)\n  return html.match(reg)?.[1] ?? ''\n}\n\n/**\n * Parse files from DataTransfer object\n * @param dataTransfer\n * @returns array of files\n **/\nexport const parseDataTransferFiles = (dataTransfer: DataTransfer) => {\n  let files: File[] = []\n\n  try {\n    if (dataTransfer.items && dataTransfer.items.length > 0) {\n      for (const item of dataTransfer.items) {\n        let file = item.kind === 'file' ? item.getAsFile() : null\n        if (file !== null) {\n          if (file.type && file.type.indexOf('image/png') > -1 && !file.lastModified) {\n            file = new File([file], 'image.png', {\n              type: file.type,\n            })\n          }\n        }\n        if (file) files.push(file)\n      }\n    } else if (dataTransfer.files && dataTransfer.files.length > 0) {\n      files = Array.from(dataTransfer.files)\n    }\n  } catch (err) {\n    if (dataTransfer.files && dataTransfer.files.length > 0) {\n      files = Array.from(dataTransfer.files)\n    }\n  }\n  return files\n}\n\n/**\n * Parse Data from DataTransfer\n * @param dataTransfer\n * @returns DataTransferFormatData\n **/\nexport const parseDataTransfer = (dataTransfer: DataTransfer): DataTransferFormatData => {\n  const text = dataTransfer.getData(TEXT_PLAIN)\n  const html = dataTransfer.getData(TEXT_HTML)\n  let fragment = dataTransfer.getData(APPLICATION_FRAGMENT_TYPE)\n  if (!fragment) fragment = matchFragmentStringFromHTML(html)\n  return {\n    text,\n    html,\n    fragment: fragment ? parseFragmentFromString(fragment) : [],\n    files: parseDataTransferFiles(dataTransfer),\n  }\n}\n\n/**\n * Set Data to DataTransfer\n * @param dataTransfer\n * @param data\n **/\nexport const setDataTransfer = (\n  dataTransfer: DataTransfer,\n  data: Partial<DataTransferFormatData>,\n) => {\n  const { text, html, fragment, files } = data\n  if (text) dataTransfer.setData(TEXT_PLAIN, text)\n  if (html) dataTransfer.setData(TEXT_HTML, html)\n  if (fragment) dataTransfer.setData(APPLICATION_FRAGMENT_TYPE, fragmentToString(fragment))\n  if (files) {\n    for (const file of files) {\n      dataTransfer.items.add(file)\n    }\n  }\n}\n","import * as React from 'react'\nimport { useStore } from 'zustand'\nimport { Editable } from '../plugin/editable'\nimport { Locale, LocaleComponentName } from '../plugin/locale'\nimport { useEditableStatic } from './use-editable'\n\nexport const useLocaleStore = (editor: Editable) => {\n  return React.useMemo(() => {\n    return Locale.getStore(editor)\n  }, [editor])\n}\n\nexport const useLang = (editor: Editable): string => {\n  const store = useLocaleStore(editor)\n  return useStore(store, state => state.lang)\n}\n\nexport const useLocale = <\n  L extends Locale,\n  T extends LocaleComponentName<L> = LocaleComponentName<L>,\n>(\n  componentName: T,\n  defaultLocale?: L[T] | (() => L[T]),\n): L[T] => {\n  const editor = useEditableStatic()\n  const lang = useLang(editor)\n  const localeContext = useLocales<L>(editor, lang)\n  const componentLocaleContext = localeContext[componentName]\n\n  const componentLocale = React.useMemo(() => {\n    const locale = componentLocaleContext || defaultLocale\n    return {\n      ...(locale instanceof Function ? locale() : locale),\n    } as L[T]\n  }, [defaultLocale, componentLocaleContext])\n\n  return componentLocale\n}\n\nexport const useLocales = <T extends Locale>(editor: Editable, lang: string): T => {\n  const store = useLocaleStore(editor)\n\n  const locales = useStore(store, state => state.locales[lang] ?? state.locales['en-US'])\n  return locales as T\n}\n\nexport const useLocaleFormat = <\n  L extends Locale,\n  T extends LocaleComponentName<L> = LocaleComponentName<L>,\n>(\n  componentName: T,\n) => {\n  const locale = useLocale<L>(componentName)\n  return {\n    format: (key: keyof typeof locale, options?: Record<string, string | number>) => {\n      const value = locale[key]\n      if (typeof value === 'string') {\n        if (!options) return value\n        return value.replace(/{(\\w+)}/g, (match, key) => String(options[key]) || match)\n      }\n      return ''\n    },\n  }\n}\n","import merge from 'lodash.merge'\nimport create, { StoreApi, UseBoundStore } from 'zustand'\nimport { Editor } from '@editablejs/models'\nexport interface Locale {\n  locale: string\n}\n\nexport interface LocaleState {\n  lang: string\n  locales: Record<string, Locale>\n}\n\nconst EDITOR_TO_LOCALE_STORE: WeakMap<Editor, UseBoundStore<StoreApi<LocaleState>>> = new WeakMap()\n\nconst getStore = (editor: Editor) => {\n  let store = EDITOR_TO_LOCALE_STORE.get(editor)\n  if (!store) {\n    store = create<LocaleState>(() => ({\n      lang: 'en-US',\n      locales: {},\n    }))\n    EDITOR_TO_LOCALE_STORE.set(editor, store)\n  }\n  return store\n}\n\nexport const Locale = {\n  getStore,\n\n  setLocale: <T extends Locale>(editor: Editor, ...locales: Record<string, T>[]) => {\n    const store = getStore(editor)\n    store.setState(state => {\n      const { lang, locales: prevLocales } = state\n      const newLocales = Object.assign({}, prevLocales)\n      for (const locale of locales) {\n        for (const key in locale) {\n          newLocales[key] = merge(newLocales[key], locale[key])\n        }\n      }\n      return {\n        lang,\n        locales: newLocales,\n      }\n    })\n  },\n\n  getLang: (editor: Editor) => {\n    const state = getStore(editor).getState()\n    return state.lang\n  },\n\n  setLang: (editor: Editor, lang: string) => {\n    const store = getStore(editor)\n    store.setState(state => {\n      return {\n        lang,\n        locales: state.locales,\n      }\n    })\n  },\n\n  getLocale: <T extends Locale>(editor: Editor): T => {\n    const lang = Locale.getLang(editor)\n    const locales = Locale.getLocales(editor)\n    return (locales[lang] ?? locales['en-US']) as any\n  },\n\n  getLocales: (editor: Editor): Record<string, Locale> => {\n    const state = getStore(editor).getState()\n    return state.locales\n  },\n}\n\nexport type LocaleComponentName<T extends Locale> = Exclude<keyof T, 'locale'>\n","import * as React from 'react'\nimport { StoreApi, UseBoundStore, useStore } from 'zustand'\nimport { Editable } from '../plugin/editable'\n\nexport interface EditableStore {\n  editor: [Editable]\n}\n\nexport const useEditableStore = () => {\n  const contenxt = React.useContext(EditableStoreContext)\n  if (!contenxt) {\n    throw new Error(\n      `The \\`useEditableStore\\` hook must be used inside the <EditableProvider> component's context.`,\n    )\n  }\n\n  return contenxt.store\n}\n\nexport interface EditableStoreContext {\n  store: UseBoundStore<StoreApi<EditableStore>>\n  editor: Editable\n}\n\nexport const EditableStoreContext = React.createContext<EditableStoreContext | null>(null)\n\n/**\n * 静态的编辑器对象\n * @returns\n */\nexport const useEditableStatic = (): Editable => {\n  const contenxt = React.useContext(EditableStoreContext)\n\n  if (!contenxt) {\n    throw new Error(\n      `The \\`useEditableStatic\\` hook must be used inside the <EditableProvider> component's context.`,\n    )\n  }\n\n  return contenxt.editor\n}\n\n/**\n * 实时变化的编辑器对象\n * @returns\n */\nexport const useEditable = (): Editable => {\n  const store = useEditableStore()\n\n  return useStore(store, state => {\n    return state.editor\n  })[0]\n}\n","import * as React from 'react'\nimport {\n  Editor,\n  Range,\n  Transforms,\n  Point,\n  Path,\n  Element,\n  DOMNode,\n  getDefaultView,\n  isDOMNode,\n} from '@editablejs/models'\n\nimport useChildren from '../hooks/use-children'\nimport { useEditable, useEditableStatic } from '../hooks/use-editable'\nimport { Editable } from '../plugin/editable'\nimport { useReadOnly } from '../hooks/use-read-only'\nimport { useIsomorphicLayoutEffect } from '../hooks/use-isomorphic-layout-effect'\nimport { inAbsoluteDOMElement } from '../utils/dom'\nimport {\n  EDITOR_TO_ELEMENT,\n  ELEMENT_TO_NODE,\n  NODE_TO_ELEMENT,\n  EDITOR_TO_WINDOW,\n  IS_SHIFT_PRESSED,\n  EDITOR_TO_SHADOW,\n  IS_MOUSEDOWN,\n  IS_TOUCHMOVING,\n  IS_TOUCHING,\n  IS_TOUCH_HOLD,\n} from '../utils/weak-maps'\nimport { useMultipleClick } from '../hooks/use-multiple-click'\nimport { Focused, useFocused } from '../hooks/use-focused'\nimport ShadowContainer from './shadow'\nimport { CaretComponent } from './caret'\nimport { SelectionComponent } from './selection'\nimport { InputComponent } from './input'\nimport { useDragging, useDragMethods, useDragTo } from '../hooks/use-drag'\nimport { SelectionDrawing, SelectionDrawingStyle } from '../plugin/selection-drawing'\nimport { APPLICATION_FRAGMENT_TYPE, DATA_EDITABLE_NODE } from '../utils/constants'\nimport { DragCaretComponent } from './drag-caret'\nimport { parseFragmentFromString, setDataTransfer } from '../utils/data-transfer'\nimport { Slots } from './slot'\nimport { Drag } from '../plugin/drag'\nimport { Placeholder } from '../plugin/placeholder'\nimport { usePlaceholder } from '../hooks/use-placeholder'\nimport { isTouchDevice } from '../utils/environment'\nimport { TouchPointComponent } from './touch-point'\nimport { getNativeEvent, isMouseEvent, isTouchEvent } from '../utils/event'\nimport { canForceTakeFocus, isEditableDOMElement } from '../utils/dom'\nimport { Locale } from '../plugin/locale'\n\nconst Children = (props: Omit<Parameters<typeof useChildren>[0], 'node' | 'selection'>) => {\n  const editor = useEditable()\n  return (\n    <React.Fragment>\n      {useChildren({ ...props, node: editor, selection: editor.selection })}\n    </React.Fragment>\n  )\n}\n\n/**\n * `EditableProps` are passed to the `<Editable>` component.\n */\nexport type EditableProps = {\n  readOnly?: boolean\n  lang?: string\n  autoFocus?: boolean\n  placeholder?: React.ReactNode\n  role?: string\n  style?: React.CSSProperties\n  as?: React.ElementType\n  className?: string\n  selectionDrawingStyle?: SelectionDrawingStyle\n}\n\n/**\n * ContentEditable.\n */\nexport const ContentEditable = (props: EditableProps) => {\n  const {\n    autoFocus = true,\n    placeholder,\n    readOnly: readOnlyProp = false,\n    lang,\n    style = {},\n    as: Component = 'div',\n    selectionDrawingStyle: selectionDrawingStyleProp,\n    ...attributes\n  } = props\n  const editor = useEditableStatic()\n\n  const ref = React.useRef<HTMLDivElement>(null)\n  const [readOnly, setReadOnly] = useReadOnly()\n  // 标记是否是刚拖拽完毕\n  const isDragEnded = React.useRef(false)\n  const dragTo = useDragTo()\n  const dragging = useDragging()\n  const { getDrag, setDrag } = useDragMethods()\n\n  const [rendered, setRendered] = React.useState(false)\n\n  // Touch hold timer\n  const touchHoldTimer = React.useRef<number | null>(null)\n\n  React.useEffect(() => {\n    if (placeholder && !readOnly) {\n      const unsubscribe = Placeholder.subscribe(\n        editor,\n        ([node]) => {\n          if (Editable.isEditor(node) && !node.children.some(n => Editor.isList(editor, n)))\n            return () => placeholder\n        },\n        true,\n      )\n\n      return () => {\n        unsubscribe()\n      }\n    }\n  }, [editor, placeholder, readOnly])\n\n  useIsomorphicLayoutEffect(() => {\n    setReadOnly(readOnlyProp)\n  }, [readOnlyProp])\n\n  useIsomorphicLayoutEffect(() => {\n    Locale.setLang(editor, props.lang || 'en-US')\n  }, [editor, lang])\n\n  useIsomorphicLayoutEffect(() => {\n    if (selectionDrawingStyleProp) SelectionDrawing.setStyle(editor, selectionDrawingStyleProp)\n  }, [editor, selectionDrawingStyleProp])\n\n  const [focused, setFocused] = useFocused()\n\n  const startPointRef = React.useRef<Point | null>(null)\n  const isContextMenu = React.useRef(false)\n\n  const clearTouchHoldTimer = () => {\n    if (touchHoldTimer.current) clearTimeout(touchHoldTimer.current)\n  }\n\n  const handleDocumentMouseDown = (event: MouseEvent | TouchEvent) => {\n    const isMouseDown = IS_MOUSEDOWN.get(editor)\n    const isTouching = IS_TOUCHING.get(editor)\n    if (!isMouseDown && !isTouching && !event.defaultPrevented) setFocused(false)\n  }\n\n  const handleSelecting = (point: Point | null, rest = true, forceFocus = true) => {\n    if (!point) return\n    const { selection } = editor\n    if (!rest && selection && Range.includes(selection, point)) {\n      return\n    }\n    let anchor: Point | null = null\n\n    if (IS_TOUCHING.get(editor)) {\n      anchor = point\n    } else {\n      anchor = IS_SHIFT_PRESSED.get(editor) && selection ? selection.anchor : startPointRef.current\n    }\n    if (!anchor) return\n    const range: Range = { anchor, focus: point }\n    if (selection && forceFocus && Range.equals(range, selection)) {\n      editor.focus()\n      setFocused(true)\n      return true\n    }\n    Transforms.select(editor, range)\n    return range\n  }\n\n  const handleDocumentTouchEnd = (event: TouchEvent) => {\n    if (event.defaultPrevented) return\n    clearTouchHoldTimer()\n    // touch move 之后不会触发 mouse up 事件，所以需要在 touch end 时触发\n    if (IS_TOUCHMOVING.get(editor)) {\n      handleDocumentMouseUp(event)\n      IS_TOUCHING.set(editor, false)\n    } else if (IS_TOUCH_HOLD.get(editor)) {\n      IS_TOUCHING.set(editor, false)\n      IS_MOUSEDOWN.set(editor, false)\n      IS_TOUCH_HOLD.set(editor, false)\n      event.preventDefault()\n      editor.onTouchHold(event)\n    }\n  }\n\n  const handleDocumentMouseUp = (event: MouseEvent | TouchEvent) => {\n    const drag = getDrag()\n    const isMouseDown = IS_MOUSEDOWN.get(editor)\n    if (\n      drag ||\n      (IS_TOUCHING.get(editor) && !IS_TOUCH_HOLD.get(editor)) ||\n      (isMouseDown &&\n        (!event.defaultPrevented || (event instanceof MouseEvent && event.button === 2)))\n    ) {\n      if (focused && !isEditableDOMElement(event.target) && canForceTakeFocus()) {\n        editor.focus()\n      }\n      const point = Editable.findEventPoint(editor, event)\n      let isSelectedSame = false\n      if (point && drag) {\n        const { from, data, type = 'text' } = drag\n        const fromRange = Editor.range(editor, from)\n        if (!Range.includes(fromRange, point)) {\n          const fragment = parseFragmentFromString(data.getData(APPLICATION_FRAGMENT_TYPE))\n          if (type === 'block') {\n            const path = Drag.toBlockPath(editor)\n            if (path && fragment.length > 0) {\n              const rangeRef = Editor.rangeRef(editor, {\n                anchor: {\n                  path,\n                  offset: 0,\n                },\n                focus: {\n                  path,\n                  offset: 0,\n                },\n              })\n              Transforms.removeNodes(editor, { at: from })\n              const at = rangeRef.unref()\n              Transforms.insertNodes(editor, fragment, {\n                at: at?.anchor.path ?? path,\n                select: true,\n              })\n            }\n          } else {\n            const deleteAfterRange = Editor.rangeRef(editor, Editor.range(editor, point))\n            Transforms.delete(editor, {\n              at: from,\n              unit: 'line',\n              hanging: true,\n            })\n            const anchorRange = deleteAfterRange.unref()\n            Transforms.select(editor, anchorRange ?? point)\n            Transforms.insertFragment(editor, fragment)\n            const focus = editor.selection?.focus\n            if (anchorRange && focus) {\n              let anchor = anchorRange.anchor\n              const anchorElement = Editor.above(editor, {\n                at: anchorRange,\n                match: node => Element.isElement(node),\n                voids: true,\n              })\n\n              const nextPath = Path.next(anchor.path)\n\n              if (anchorElement && Editor.hasPath(editor, nextPath)) {\n                const nextRange = Editor.range(editor, nextPath)\n                const element = Editor.above(editor, {\n                  at: nextRange,\n                  match: node => Element.isElement(node),\n                  voids: true,\n                })\n                if (element && anchorElement[0] !== element[0]) {\n                  anchor = nextRange.anchor\n                }\n              }\n              Transforms.select(editor, {\n                anchor,\n                focus,\n              })\n            }\n          }\n\n          isDragEnded.current = true\n        } else {\n          Transforms.select(editor, point)\n        }\n      } else {\n        const { selection } = editor\n        if (\n          IS_TOUCHING.get(editor) &&\n          point &&\n          selection &&\n          isSelectedOnCurrentSelection(editor, selection, point)\n        ) {\n          isSelectedSame = true\n        } else {\n          // 是否选中在同一个位置\n          isSelectedSame =\n            handleSelecting(point, !isContextMenu.current, !isEditableDOMElement(event.target)) ===\n            true\n        }\n      }\n      // 修复 touch 时，触发了 mouse up 事件，导致无法触发 onSelectStart\n      if (IS_TOUCHING.get(editor) && !IS_TOUCH_HOLD.get(editor)) {\n        // touch 在同一个位置，触发 onTouchTrack\n        if (isSelectedSame) editor.onTouchTrack()\n        else editor.onSelectStart()\n      }\n      setDrag(null)\n      if (!isDragEnded.current && (!IS_TOUCHING.get(editor) || !isSelectedSame))\n        editor.onSelectEnd()\n    }\n\n    isContextMenu.current = false\n    startPointRef.current = null\n    IS_TOUCHMOVING.set(editor, false)\n    IS_TOUCHING.set(editor, false)\n    IS_MOUSEDOWN.set(editor, false)\n  }\n\n  const handleDocumentMouseMove = (event: MouseEvent | TouchEvent) => {\n    const darg = getDrag()\n    const isMouseDown = IS_MOUSEDOWN.get(editor)\n    // 未长按不触发 move 事件\n    if (IS_TOUCHING.get(editor) && !IS_TOUCH_HOLD.get(editor)) {\n      clearTouchHoldTimer()\n      return\n    }\n    const isTouchMoving = isTouchEvent(event)\n    IS_TOUCHMOVING.set(editor, isTouchMoving)\n\n    if (\n      !isTouchMoving &&\n      !darg &&\n      ((isMouseEvent(event) && event.button !== 0) ||\n        !isMouseDown ||\n        event.defaultPrevented ||\n        isContextMenu.current)\n    )\n      return\n    const point = event.defaultPrevented ? null : Editable.findEventPoint(editor, event)\n    if (point && dragging && isMouseEvent(event)) {\n      setDrag({\n        to: {\n          anchor: point,\n          focus: point,\n        },\n        position: {\n          x: event.clientX,\n          y: event.clientY,\n        },\n      })\n      return\n    }\n    // 阻止 touchmove 时页面滚动\n    if (isTouchMoving) event.preventDefault()\n    const range = handleSelecting(point)\n    if (range) editor.onSelecting()\n  }\n\n  const handleRootTouchStart = (event: React.TouchEvent) => {\n    if (event.defaultPrevented) return\n    if (\n      !event.target ||\n      !ref.current?.contains(event.target as DOMNode) ||\n      isEditableDOMElement(event.target) ||\n      inAbsoluteDOMElement(event.target)\n    )\n      return\n\n    const { selection } = editor\n\n    IS_TOUCHING.set(editor, true)\n    IS_TOUCH_HOLD.set(editor, false)\n    clearTouchHoldTimer()\n    // touch hold\n    touchHoldTimer.current = setTimeout(() => {\n      IS_TOUCH_HOLD.set(editor, true)\n\n      if (Focused.is(editor)) {\n        handleRootMouseDown(event)\n      } else if (!selection || Range.isCollapsed(selection)) {\n        IS_TOUCHING.set(editor, false)\n        const point = Editable.findEventPoint(editor, event)\n        if (point)\n          editor.selectWord({\n            at: {\n              anchor: point,\n              focus: point,\n            },\n          })\n      }\n    }, 530)\n  }\n\n  const handleRootMouseDown = (e: React.MouseEvent | React.TouchEvent) => {\n    const event = getNativeEvent(e)\n    if (e.defaultPrevented && isMouseEvent(event) && event.button !== 2) return\n    if (\n      !event.target ||\n      !ref.current?.contains(event.target as DOMNode) ||\n      isEditableDOMElement(event.target) ||\n      inAbsoluteDOMElement(event.target)\n    )\n      return\n\n    IS_MOUSEDOWN.set(editor, true)\n    if (isDoubleClickRef.current) {\n      if (isSamePoint(event)) {\n        return\n      } else {\n        isDoubleClickRef.current = false\n      }\n    }\n    setFocused(true)\n    const point = Editable.findEventPoint(editor, event)\n    if (point) {\n      const isShift = IS_SHIFT_PRESSED.get(editor)\n      if (!isShift) {\n        const { selection } = editor\n        if (event instanceof MouseEvent && event.button === 2) {\n          isContextMenu.current = true\n        }\n        // Perform drag on existing selection while selected.\n        else if (\n          selection &&\n          focused &&\n          isSelectedOnCurrentSelection(editor, selection, point, isTouchDevice)\n        ) {\n          // Drag not performed on touch devices.\n          if (!isTouchDevice) {\n            const dataTransfer = new DataTransfer()\n            setDataTransfer(dataTransfer, {\n              fragment: editor.getFragment(selection),\n            })\n            setDrag({\n              from: selection,\n              data: dataTransfer,\n              position: {\n                x: event.clientX,\n                y: event.clientY,\n              },\n            })\n            editor.onSelectStart()\n          }\n          return\n        }\n        startPointRef.current = point\n      }\n      const range = handleSelecting(\n        point,\n        !isContextMenu.current,\n        !isEditableDOMElement(event.target),\n      )\n      if (range) editor.onSelectStart()\n    } else startPointRef.current = null\n  }\n\n  const handleRootMouseUp = () => {\n    startPointRef.current = null\n  }\n\n  const isDoubleClickRef = React.useRef(false)\n  const isDoubleClickTimerRef = React.useRef<number>()\n  const { handleMultipleClick, isSamePoint } = useMultipleClick({\n    onClick: () => {\n      isDoubleClickRef.current = false\n    },\n    onMultipleClick: (event, count) => {\n      const { selection } = editor\n      if (!selection || event.defaultPrevented) return\n      event.preventDefault()\n      const container = Editable.toDOMNode(editor, editor)\n      if (isDOMNode(event.target) && !container.contains(event.target)) return\n      const isCollapsed = Range.isCollapsed(selection)\n      if (count === 1 && !isCollapsed) {\n        return false\n      } else if (count === 2) {\n        editor.selectWord()\n        isDoubleClickRef.current = true\n        if (isDoubleClickTimerRef.current) clearTimeout(isDoubleClickTimerRef.current)\n        isDoubleClickTimerRef.current = setTimeout(() => {\n          isDoubleClickRef.current = false\n        }, 500)\n        return\n      } else if (count === 3) {\n        editor.selectLine()\n        isDoubleClickRef.current = false\n        return false\n      }\n    },\n  })\n\n  const [awaitUpdateDrawingSelection, setAwaitUpdateDrawingSelection] = React.useState(\n    editor.selection,\n  )\n\n  useIsomorphicLayoutEffect(() => {\n    const handleChange = () => {\n      const { selection } = editor\n      setAwaitUpdateDrawingSelection(selection ? Object.assign({}, selection) : null)\n    }\n    editor.on('change', handleChange)\n\n    const handleShift = (event: KeyboardEvent) => {\n      if (event.key.toLowerCase() === 'shift') {\n        IS_SHIFT_PRESSED.set(editor, false)\n      }\n    }\n\n    let window: Window | null = null\n    if (ref.current && (window = getDefaultView(ref.current))) {\n      EDITOR_TO_WINDOW.set(editor, window)\n      EDITOR_TO_ELEMENT.set(editor, ref.current)\n      NODE_TO_ELEMENT.set(editor, ref.current)\n      ELEMENT_TO_NODE.set(ref.current, editor)\n      setRendered(true)\n\n      window.addEventListener('keyup', handleShift)\n      window.addEventListener('mousedown', handleDocumentMouseDown)\n      window.addEventListener('mouseup', handleDocumentMouseUp)\n      if (isTouchDevice) {\n        window.addEventListener('touchend', handleDocumentTouchEnd)\n        window.addEventListener('touchmove', handleDocumentMouseMove, { passive: false })\n      } else {\n        window.addEventListener('mousemove', handleDocumentMouseMove)\n      }\n    } else {\n      NODE_TO_ELEMENT.delete(editor)\n    }\n\n    return () => {\n      editor.off('change', handleChange)\n      window?.removeEventListener('keyup', handleShift)\n      window?.removeEventListener('mousedown', handleDocumentMouseDown)\n      window?.removeEventListener('mouseup', handleDocumentMouseUp)\n      if (isTouchDevice) {\n        window?.removeEventListener('touchend', handleDocumentTouchEnd)\n        window?.removeEventListener('touchmove', handleDocumentMouseMove)\n      } else {\n        window?.removeEventListener('mousemove', handleDocumentMouseMove)\n      }\n    }\n  }, [editor, handleDocumentMouseDown, handleDocumentMouseMove, handleDocumentMouseUp])\n\n  React.useEffect(() => {\n    // 在拖拽完成后触发onSelectEnd，否则内容可能还未渲染完毕\n    if (isDragEnded.current) {\n      editor.onSelectEnd()\n      isDragEnded.current = false\n    }\n  }, [awaitUpdateDrawingSelection, editor])\n\n  useIsomorphicLayoutEffect(() => {\n    SelectionDrawing.setSelection(editor, awaitUpdateDrawingSelection)\n  }, [awaitUpdateDrawingSelection])\n\n  // 处理文件拖拽\n  const handleDragOver = (event: React.DragEvent) => {\n    event.preventDefault()\n    if (readOnly) return\n    const point = Editable.findEventPoint(editor, event)\n    if (point) {\n      const dragRange = {\n        anchor: point,\n        focus: point,\n      }\n      const position = {\n        x: event.clientX,\n        y: event.clientY,\n      }\n      if (!dragging) {\n        setDrag({\n          type: 'text',\n          from: dragRange,\n          data: event.dataTransfer,\n        })\n      }\n      setDrag({\n        position,\n        to: dragRange,\n      })\n    }\n  }\n\n  const handleDrop = (event: React.DragEvent) => {\n    event.preventDefault()\n    event.stopPropagation()\n    setDrag(null)\n    if (readOnly) return\n    const point = Editable.findEventPoint(editor, event)\n    if (point) {\n      Transforms.select(editor, point)\n      const clipboardEvent = new ClipboardEvent('paset', { clipboardData: event.dataTransfer })\n      editor.onPaste(clipboardEvent)\n    }\n  }\n\n  const handleContextMenu = (event: React.MouseEvent) => {\n    if (!isTouchDevice) editor.onContextMenu(event.nativeEvent)\n  }\n\n  const cursor = React.useMemo(() => {\n    if (dragging && dragTo) {\n      return 'default'\n    }\n    return 'text'\n  }, [dragTo, dragging])\n\n  const renderPlaceholder = usePlaceholder(editor)\n\n  const handleAnchorTouchPointStart = React.useCallback(\n    (event: React.TouchEvent) => {\n      event.stopPropagation()\n      const { selection } = editor\n      if (!selection) return\n      startPointRef.current = Range.end(selection)\n      IS_MOUSEDOWN.set(editor, true)\n      editor.onSelectStart()\n    },\n    [editor],\n  )\n\n  const handleFocusTouchPointStart = React.useCallback(\n    (event: React.TouchEvent) => {\n      event.stopPropagation()\n      const { selection } = editor\n      if (!selection) return\n      startPointRef.current = Range.start(selection)\n      IS_MOUSEDOWN.set(editor, true)\n      editor.onSelectStart()\n    },\n    [editor],\n  )\n\n  return (\n    <div\n      style={{\n        ...style,\n        position: 'relative',\n      }}\n    >\n      <Component\n        role={readOnly ? undefined : 'textbox'}\n        {...attributes}\n        {...{ [DATA_EDITABLE_NODE]: 'editor' }}\n        zindex={-1}\n        ref={ref}\n        style={{\n          // Prevent the default outline styles.\n          outline: 'none',\n          // Preserve adjacent whitespace and new lines.\n          whiteSpace: 'pre-wrap',\n          // Allow words to break if they are too long.\n          wordBreak: 'break-word',\n          // Disable the default user-select behavior.\n          userSelect: 'none',\n          // Set cursor to text.\n          cursor,\n          //\n          overflowWrap: 'break-word',\n        }}\n        onTouchStart={isTouchDevice ? handleRootTouchStart : undefined}\n        onMouseDown={isTouchDevice ? undefined : handleRootMouseDown}\n        onMouseUp={handleRootMouseUp}\n        onClick={handleMultipleClick}\n        onDragOver={handleDragOver}\n        onDrop={handleDrop}\n        onContextMenu={handleContextMenu}\n      >\n        <Children renderPlaceholder={renderPlaceholder} />\n      </Component>\n      <ShadowContainer ref={current => EDITOR_TO_SHADOW.set(editor, current)}>\n        <CaretComponent />\n        <DragCaretComponent />\n        <SelectionComponent />\n        <InputComponent autoFocus={autoFocus} />\n      </ShadowContainer>\n      <TouchPointComponent\n        onAnchorTouchStart={handleAnchorTouchPointStart}\n        onFocusTouchStart={handleFocusTouchPointStart}\n      />\n      {rendered && <Slots />}\n    </div>\n  )\n}\n\nconst isSelectedOnCurrentSelection = (\n  editor: Editor,\n  selection: Range,\n  point: Point,\n  compareOnCollapsed = false,\n) => {\n  return (\n    (Range.includes(selection, point) &&\n      ((!Point.equals(Range.end(selection), point) &&\n        !Point.equals(Range.start(selection), point)) ||\n        (Range.isCollapsed(selection) &&\n          !!Editor.above(editor, { match: n => Editor.isVoid(editor, n) })))) ||\n    (compareOnCollapsed &&\n      Range.isCollapsed(selection) &&\n      Point.equals(Range.start(selection), point))\n  )\n}\n","import { Editor, Range, Element, Ancestor, Descendant } from '@editablejs/models'\n\nimport ElementComponent from '../components/element'\nimport TextComponent from '../components/text'\nimport { Editable } from '../plugin/editable'\nimport { useEditableStatic } from './use-editable'\nimport { NODE_TO_INDEX, NODE_TO_PARENT } from '../utils/weak-maps'\nimport { NodeSelectedContext } from './use-node-selected'\nimport { NodeFocusedContext } from './use-node-focused'\nimport { GridContext } from './use-grid'\nimport { PlaceholderRender } from '../plugin/placeholder'\n\n/**\n * Children.\n */\nconst useChildren = (props: {\n  node: Ancestor\n  selection: Range | null\n  renderPlaceholder?: PlaceholderRender\n}) => {\n  const { node, selection, renderPlaceholder } = props\n  const editor = useEditableStatic()\n  const path = Editable.findPath(editor, node)\n  const children = []\n  const isLeafBlock =\n    Element.isElement(node) && !editor.isInline(node) && Editor.hasInlines(editor, node)\n\n  for (let i = 0; i < node.children.length; i++) {\n    const p = path.concat(i)\n    const n = node.children[i] as Descendant\n    const key = Editable.findKey(editor, n)\n    const range = Editor.range(editor, p)\n    const sel = selection && Range.intersection(range, selection)\n    const focused =\n      selection && Range.includes(range, selection.anchor) && Range.includes(range, selection.focus)\n\n    if (Element.isElement(n)) {\n      const element = (\n        <NodeSelectedContext.Provider key={`selected-provider-${key.id}`} value={!!sel}>\n          <NodeFocusedContext.Provider key={`focused-provider-${key.id}`} value={focused ?? false}>\n            <ElementComponent\n              element={n}\n              key={key.id}\n              selection={sel}\n              renderPlaceholder={renderPlaceholder}\n            />\n          </NodeFocusedContext.Provider>\n        </NodeSelectedContext.Provider>\n      )\n      if (Editor.isGrid(editor, n)) {\n        children.push(\n          <GridContext.Provider key={`grid-provider-${key.id}`} value={n}>\n            {element}\n          </GridContext.Provider>,\n        )\n      } else {\n        children.push(element)\n      }\n    } else {\n      children.push(\n        <TextComponent\n          renderPlaceholder={renderPlaceholder}\n          key={key.id}\n          isLast={isLeafBlock && i === node.children.length - 1}\n          parent={node}\n          text={n}\n        />,\n      )\n    }\n\n    NODE_TO_INDEX.set(n, i)\n    NODE_TO_PARENT.set(n, node)\n  }\n\n  return children\n}\n\nexport default useChildren\n","import * as React from 'react'\nimport getDirection from 'direction'\nimport { Editor, Node, Range, Element as SlateElement } from '@editablejs/models'\n\nimport Text from './text'\nimport useChildren from '../hooks/use-children'\nimport { Editable, useEditableStatic, ElementAttributes } from '..'\nimport { useIsomorphicLayoutEffect } from '../hooks/use-isomorphic-layout-effect'\nimport {\n  NODE_TO_ELEMENT,\n  ELEMENT_TO_NODE,\n  NODE_TO_PARENT,\n  NODE_TO_INDEX,\n  EDITOR_TO_KEY_TO_ELEMENT,\n} from '../utils/weak-maps'\nimport { DATA_EDITABLE_INLINE, DATA_EDITABLE_NODE, DATA_EDITABLE_VOID } from '../utils/constants'\nimport { useElementDecorations } from '../hooks/use-decorate'\nimport { PlaceholderRender } from '../plugin/placeholder'\nimport { usePlaceholder } from '../hooks/use-placeholder'\n\n/**\n * Element.\n */\nconst Element = (props: {\n  element: SlateElement\n  selection: Range | null\n  renderPlaceholder?: PlaceholderRender\n}) => {\n  const { element, selection, renderPlaceholder } = props\n  const ref = React.useRef<HTMLElement>(null)\n  const editor = useEditableStatic()\n  const isInline = editor.isInline(element)\n  const key = Editable.findKey(editor, element)\n\n  const currentRenderPlaceholder = usePlaceholder(element)\n  let children: React.ReactNode = useChildren({\n    node: element,\n    selection,\n    renderPlaceholder: Editor.isEmpty(editor, element)\n      ? currentRenderPlaceholder ?? renderPlaceholder\n      : undefined,\n  })\n\n  // Attributes that the developer must mix into the element in their\n  // custom node renderer component.\n  const attributes: ElementAttributes = {\n    [DATA_EDITABLE_NODE]: 'element',\n    ref,\n  }\n\n  if (isInline) {\n    attributes[DATA_EDITABLE_INLINE] = true\n  }\n\n  // If it's a block node with inline children, add the proper `dir` attribute\n  // for text direction.\n  if (!isInline && Editor.hasInlines(editor, element)) {\n    const text = Node.string(element)\n    const dir = getDirection(text)\n\n    if (dir === 'rtl') {\n      attributes.dir = dir\n    }\n  }\n\n  // If it's a void node, wrap the children in extra void-specific elements.\n  if (Editor.isVoid(editor, element)) {\n    attributes[DATA_EDITABLE_VOID] = true\n\n    const Tag = isInline ? 'span' : 'div'\n    const [[text]] = Node.texts(element)\n\n    children = (\n      <Tag\n        style={{\n          height: '0',\n          color: 'transparent',\n          outline: 'none',\n        }}\n      >\n        <Text\n          renderPlaceholder={renderPlaceholder ?? currentRenderPlaceholder}\n          isLast={false}\n          parent={element}\n          text={text}\n        />\n      </Tag>\n    )\n\n    NODE_TO_INDEX.set(text, 0)\n    NODE_TO_PARENT.set(text, element)\n  }\n\n  // Update element-related weak maps with the DOM element ref.\n  useIsomorphicLayoutEffect(() => {\n    const KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor)\n    if (ref.current) {\n      KEY_TO_ELEMENT?.set(key, ref.current)\n      NODE_TO_ELEMENT.set(element, ref.current)\n      ELEMENT_TO_NODE.set(ref.current, element)\n    } else {\n      KEY_TO_ELEMENT?.delete(key)\n      NODE_TO_ELEMENT.delete(element)\n    }\n  })\n  const path = Editable.findPath(editor, element)\n\n  const newAttributes = editor.renderElementAttributes({ attributes, element })\n\n  let content = editor.renderElement({ attributes: newAttributes, children, element })\n\n  const decorates = useElementDecorations(element, path)\n\n  if (decorates.length > 0) {\n    content = decorates.reduceRight((children, decorate) => {\n      return decorate.renderElement({\n        node: element,\n        path,\n        children,\n      })\n    }, content)\n  }\n\n  return content\n}\n\nconst MemoizedElement = React.memo(Element, (prev, next) => {\n  return (\n    prev.element === next.element &&\n    prev.renderPlaceholder === next.renderPlaceholder &&\n    (prev.selection === next.selection ||\n      (!!prev.selection && !!next.selection && Range.equals(prev.selection, next.selection)))\n  )\n})\n\nexport default MemoizedElement\n","import * as React from 'react'\nimport { Element, Text as SlateText } from '@editablejs/models'\n\nimport Leaf from './leaf'\nimport { useIsomorphicLayoutEffect } from '../hooks/use-isomorphic-layout-effect'\nimport { NODE_TO_ELEMENT, ELEMENT_TO_NODE, EDITOR_TO_KEY_TO_ELEMENT } from '../utils/weak-maps'\nimport { useEditableStatic } from '../hooks/use-editable'\nimport { Editable } from '../plugin/editable'\nimport { DATA_EDITABLE_NODE } from '../utils/constants'\nimport { useTextDecorations } from '../hooks/use-decorate'\nimport { PlaceholderRender } from '../plugin/placeholder'\n\n/**\n * Text.\n */\nconst Text = (props: {\n  isLast: boolean\n  parent: Element\n  text: SlateText\n  renderPlaceholder?: PlaceholderRender\n}) => {\n  const { isLast, parent, text, renderPlaceholder } = props\n  const editor = useEditableStatic()\n  const ref = React.useRef<HTMLSpanElement>(null)\n  const key = Editable.findKey(editor, text)\n  const path = Editable.findPath(editor, text)\n  const decorates = useTextDecorations(text, path).map((d, index) => ({\n    ...d,\n    key: `__decorate__${index}`,\n  }))\n\n  const ranges = decorates\n    .map(({ ranges, key }) => ranges.map(range => ({ ...range, [key]: true })))\n    .flat()\n  const leaves = SlateText.decorations(text, ranges)\n\n  const decorateKeys = decorates.map(d => d.key)\n  const children = []\n  for (let i = 0; i < leaves.length; i++) {\n    const leaf = leaves[i]\n    let content = (\n      <Leaf\n        renderPlaceholder={renderPlaceholder}\n        isLast={isLast && i === leaves.length - 1}\n        key={`${key.id}-${i}`}\n        text={text}\n        leaf={leaf}\n        parent={parent}\n      />\n    )\n    for (const key of decorateKeys) {\n      if (key in leaf) {\n        const dec = decorates[decorateKeys.indexOf(key)].decorate.renderText({\n          node: text,\n          path,\n          children: content,\n        })\n        content = React.cloneElement(dec, { key })\n      }\n    }\n    children.push(content)\n  }\n  // Update element-related weak maps with the DOM element ref.\n  useIsomorphicLayoutEffect(() => {\n    const KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor)\n    if (ref.current) {\n      KEY_TO_ELEMENT?.set(key, ref.current)\n      NODE_TO_ELEMENT.set(text, ref.current)\n      ELEMENT_TO_NODE.set(ref.current, text)\n    } else {\n      KEY_TO_ELEMENT?.delete(key)\n      NODE_TO_ELEMENT.delete(text)\n    }\n  })\n\n  return (\n    <span {...{ [DATA_EDITABLE_NODE]: 'text' }} ref={ref}>\n      {children}\n    </span>\n  )\n}\n\nconst MemoizedText = React.memo(Text, (prev, next) => {\n  return (\n    next.parent === prev.parent &&\n    next.isLast === prev.isLast &&\n    next.text === prev.text &&\n    prev.renderPlaceholder === next.renderPlaceholder\n  )\n})\n\nexport default MemoizedText\n","import * as React from 'react'\nimport { Element, Text } from '@editablejs/models'\nimport String from './string'\nimport { useEditableStatic } from '../hooks/use-editable'\nimport { TextAttributes } from '../plugin/editable'\nimport { DATA_EDITABLE_LEAF, DATA_EDITABLE_PLACEHOLDER } from '../utils/constants'\nimport { PlaceholderRender } from '../plugin/placeholder'\n\n/**\n * Individual leaves in a text node with unique formatting.\n */\nconst Leaf = (props: {\n  isLast: boolean\n  parent: Element\n  leaf: Text\n  text: Text\n  renderPlaceholder?: PlaceholderRender\n}) => {\n  const { isLast, text, leaf, parent, renderPlaceholder } = props\n\n  let children = <String isLast={isLast} parent={parent} text={text} leaf={leaf} />\n\n  const editor = useEditableStatic()\n  if (renderPlaceholder) {\n    const placeholderComponent = editor.renderPlaceholder({\n      attributes: { [DATA_EDITABLE_PLACEHOLDER]: true },\n      node: text,\n      children: renderPlaceholder({ node: text }),\n    })\n    if (placeholderComponent)\n      children = (\n        <React.Fragment>\n          {placeholderComponent}\n          {children}\n        </React.Fragment>\n      )\n  }\n\n  // COMPAT: Having the `data-` attributes on these leaf elements ensures that\n  // in certain misbehaving browsers they aren't weirdly cloned/destroyed by\n  // contenteditable behaviors. (2019/05/08)\n  const attributes: TextAttributes = {\n    [DATA_EDITABLE_LEAF]: true,\n  }\n  const newAttributes = editor.renderLeafAttributes({ attributes, text })\n  return editor.renderLeaf({ attributes: newAttributes, children, text })\n}\n\nconst MemoizedLeaf = React.memo(Leaf, (prev, next) => {\n  return (\n    next.parent === prev.parent &&\n    prev.renderPlaceholder === next.renderPlaceholder &&\n    next.isLast === prev.isLast &&\n    next.text === prev.text\n  )\n})\n\nexport default MemoizedLeaf\n","import * as React from 'react'\nimport { Editor, Text, Path, Element, Node, CompositionText } from '@editablejs/models'\n\nimport { Editable } from '../plugin/editable'\nimport { useEditableStatic } from '../hooks/use-editable'\nimport {\n  DATA_EDITABLE_COMPOSITION,\n  DATA_EDITABLE_LENGTH,\n  DATA_EDITABLE_STRING,\n  DATA_EDITABLE_ZERO_WIDTH,\n} from '../utils/constants'\n\n/**\n * Leaf content strings.\n */\nconst String: React.FC<{\n  isLast: boolean\n  parent: Element\n  text: Text\n\n  leaf: Text\n}> = props => {\n  const { isLast, parent, text, leaf } = props\n  const editor = useEditableStatic()\n  const path = Editable.findPath(editor, text)\n  const parentPath = Path.parent(path)\n\n  // COMPAT: Render text inside void nodes with a zero-width space.\n  // So the node can contain selection but the text is not visible.\n  if (editor.isVoid(parent)) {\n    return <ZeroWidthString length={Node.string(parent).length} />\n  }\n\n  if (CompositionText.isCompositionText(text)) {\n    const { offset, text: compositionText } = text.composition\n    const content = text.text\n    const left = content.substring(0, offset)\n    const right = content.substring(offset)\n    return (\n      <>\n        {left && <TextString text={left} />}\n        <CompositionString text={compositionText} />\n        {right && <TextString text={right} />}\n      </>\n    )\n  }\n  // COMPAT: If this is the last text node in an empty block, render a zero-\n  // width space that will convert into a line break when copying and pasting\n  // to support expected plain text.\n  if (\n    leaf.text === '' &&\n    parent.children[parent.children.length - 1] === text &&\n    !editor.isInline(parent) &&\n    Editor.string(editor, parentPath) === ''\n  ) {\n    return <ZeroWidthString isLineBreak />\n  }\n\n  // COMPAT: If the text is empty, it's because it's on the edge of an inline\n  // node, so we render a zero-width space so that the selection can be\n  // inserted next to it still.\n  if (leaf.text === '') {\n    return <ZeroWidthString />\n  }\n\n  // COMPAT: Browsers will collapse trailing new lines at the end of blocks,\n  // so we need to add an extra trailing new lines to prevent that.\n  if (isLast && leaf.text.slice(-1) === '\\n') {\n    return <TextString isTrailing text={leaf.text} />\n  }\n  return <TextString text={leaf.text} />\n}\n\n/**\n * Leaf strings with text in them.\n */\nconst TextString = (props: { text: string; isTrailing?: boolean }) => {\n  const { text, isTrailing = false } = props\n\n  const getTextContent = () => {\n    return `${text ?? ''}${isTrailing ? '\\n' : ''}`\n  }\n\n  return <span {...{ [DATA_EDITABLE_STRING]: true }}>{getTextContent()}</span>\n}\n\nconst CompositionString = (props: { text: string }) => {\n  const { text } = props\n  return <u {...{ [DATA_EDITABLE_COMPOSITION]: true }}>{text}</u>\n}\n\n/**\n * Leaf strings without text, render as zero-width strings.\n */\n\nconst ZeroWidthString = (props: { length?: number; isLineBreak?: boolean }) => {\n  const { length = 0, isLineBreak = false } = props\n  return (\n    <span\n      {...{ [DATA_EDITABLE_ZERO_WIDTH]: isLineBreak ? 'n' : 'z', [DATA_EDITABLE_LENGTH]: length }}\n    >\n      {'\\uFEFF'}\n      {isLineBreak ? <br /> : null}\n    </span>\n  )\n}\n\nexport default String\n","import {\n  Editor,\n  Node,\n  Text,\n  Element,\n  Path,\n  Point,\n  Range,\n  Scrubber,\n  Transforms,\n  SelectionEdge,\n  Key,\n  DOMElement,\n  DOMNode,\n  DOMPoint,\n  DOMRange,\n  DOMSelection,\n  DOMStaticRange,\n  isDOMElement,\n  isDOMSelection,\n  isDOMNode,\n  isDOMText,\n} from '@editablejs/models'\n\nimport {\n  EDITOR_TO_ELEMENT,\n  ELEMENT_TO_NODE,\n  NODE_TO_INDEX,\n  NODE_TO_KEY,\n  NODE_TO_PARENT,\n  EDITOR_TO_WINDOW,\n  EDITOR_TO_KEY_TO_ELEMENT,\n  IS_COMPOSING,\n  NODE_TO_ELEMENT,\n} from '../utils/weak-maps'\nimport { normalizeDOMPoint, hasShadowRoot } from '../utils/dom'\nimport { IS_CHROME, IS_FIREFOX } from '../utils/environment'\nimport findNearbyNodes, { isAlignY } from '../utils/nearby'\nimport { getTextOffset } from '../utils/text'\nimport { getLineRectsByNode, getLineRectsByRange } from '../utils/selection'\nimport { Focused } from '../hooks/use-focused'\nimport { EventHandler, EventType } from './event'\nimport {\n  DATA_EDITABLE_COMPOSITION,\n  DATA_EDITABLE_INLINE,\n  DATA_EDITABLE_LEAF,\n  DATA_EDITABLE_LENGTH,\n  DATA_EDITABLE_NODE,\n  DATA_EDITABLE_PLACEHOLDER,\n  DATA_EDITABLE_STRING,\n  DATA_EDITABLE_VOID,\n  DATA_EDITABLE_ZERO_WIDTH,\n} from '../utils/constants'\nimport { getNativeEvent, isTouch } from '../utils/event'\nimport { ReadOnly } from '../hooks/use-read-only'\nimport scrollIntoView from 'scroll-into-view-if-needed'\n\nexport type BaseAttributes = Omit<React.HTMLAttributes<HTMLElement>, 'children'>\n\nexport interface ElementAttributes<T extends any = any> extends BaseAttributes {\n  [DATA_EDITABLE_NODE]: 'element'\n  [DATA_EDITABLE_INLINE]?: true\n  [DATA_EDITABLE_VOID]?: true\n  dir?: 'rtl'\n  ref: React.MutableRefObject<T>\n}\n\nexport interface TextAttributes extends BaseAttributes {\n  [DATA_EDITABLE_LEAF]?: true\n}\n\nexport type NodeAttributes = ElementAttributes | TextAttributes\n\nexport interface PlaceholderAttributes extends BaseAttributes {\n  [DATA_EDITABLE_PLACEHOLDER]: true\n}\n\nexport interface RenderElementAttributes<T extends Element = Element> {\n  element: T\n  attributes: ElementAttributes\n}\n\nexport interface RenderLeafAttributes<T extends Text = Text> {\n  text: T\n  attributes: TextAttributes\n}\n\n/**\n * `RenderElementProps` are passed to the `renderElement` handler.\n */\nexport interface RenderElementProps<T extends Element = Element, R extends any = any> {\n  children: any\n  element: T\n  attributes: ElementAttributes<R>\n}\n\n/**\n * `RenderLeafProps` are passed to the `renderLeaf` handler.\n */\nexport interface RenderLeafProps<T extends Text = Text> {\n  children: any\n  text: T\n  attributes: TextAttributes\n}\n\nexport interface RenderPlaceholderProps<T extends Node = Node> {\n  children: any\n  attributes: PlaceholderAttributes\n  node: T\n}\n\nexport interface SerializeHtmlOptions {\n  node: Node\n  attributes?: Record<string, any>\n  styles?: Record<string, any>\n}\n\nexport interface DeserializeHtmlOptions {\n  node: DOMNode\n  attributes?: Record<string, any>\n  markAttributes?: Record<string, any>\n  stripBreak?: true | ((text: string) => boolean)\n}\n\nexport interface SelectWordOptions {\n  at?: Range\n  edge?: SelectionEdge\n}\n\n/**\n * A React and DOM-specific version of the `Editor` interface.\n */\nexport interface Editable extends Editor {\n  blur(): void\n  focus(start?: boolean): void\n  copy(range?: Range): void\n  cut(range?: Range): void\n  selectWord: (options?: SelectWordOptions) => void\n  selectLine: (options?: SelectWordOptions) => void\n  insertFromClipboard(at?: Range): void\n  insertTextFromClipboard(at?: Range): void\n  insertFile(file: File, at?: Range): void\n  on: <T extends EventType>(type: T, handler: EventHandler<T>, prepend?: boolean) => void\n  once: <T extends EventType>(type: T, handler: EventHandler<T>, prepend?: boolean) => void\n  off: <T extends EventType>(type: T, handler: EventHandler<T>) => void\n  emit: <T extends EventType>(type: T, ...args: Parameters<EventHandler<T>>) => void\n  onKeydown: (event: KeyboardEvent) => void\n  onKeyup: (event: KeyboardEvent) => void\n  onFocus: () => void\n  onBlur: () => void\n  onPaste: (event: ClipboardEvent) => void\n  onCut: (event: ClipboardEvent) => void\n  onCopy: (event: ClipboardEvent) => void\n  onInput: (value: string) => void\n  onBeforeInput: (value: string) => void\n  onCompositionStart: (value: string) => void\n  onCompositionEnd: (value: string) => void\n  onSelectStart: () => void\n  onSelecting: () => void\n  onSelectEnd: () => void\n  onSelectionChange: () => void\n  onTouchHold: (event: TouchEvent) => void\n  onTouchTrack: () => void\n  onContextMenu: (event: MouseEvent) => void\n  onDestory: () => void\n  renderElementAttributes: (props: RenderElementAttributes) => ElementAttributes\n  renderLeafAttributes: (props: RenderLeafAttributes) => TextAttributes\n  renderElement: (props: RenderElementProps) => JSX.Element\n  renderLeaf: (props: RenderLeafProps) => JSX.Element\n  renderPlaceholder: (props: RenderPlaceholderProps) => JSX.Element | void | null\n  toDataTransfer: (range?: Range) => DataTransfer | null\n}\n\nexport const Editable = {\n  isEditor(value: any): value is Editable {\n    return !!value && Editor.isEditor(value) && 'onSelectionChange' in value\n  },\n  /**\n   * Check if the user is currently composing inside the editor.\n   */\n  isComposing(editor: Editor): boolean {\n    return !!IS_COMPOSING.get(editor)\n  },\n\n  /**\n   * 获取在选区内选中一行内容的节点以及所在行的索引\n   * @param editor\n   * @param options\n   * @returns\n   */\n  getSelectLine(\n    editor: Editor,\n    options: { range?: Range; match?: (element: Element) => boolean } = {},\n  ): [Element, number] | undefined {\n    const { range = editor.selection, match = () => true } = options\n    if (!range || Range.isCollapsed(range)) return\n    const start = Range.start(range)\n    const entry = Editor.above(editor, { at: start, match: n => Editor.isBlock(editor, n) })\n    if (!entry) return\n    const rangeLines = getLineRectsByRange(editor, range)\n    let [block, path] = entry\n    while (block) {\n      if (match(block)) {\n        const elLines = getLineRectsByNode(editor, block)\n        for (const rangeLine of rangeLines) {\n          const index = elLines.findIndex(\n            elLine =>\n              elLine.left === rangeLine.left &&\n              elLine.top === rangeLine.top &&\n              elLine.width === rangeLine.width,\n          )\n          if (~index) {\n            return [block, index]\n          }\n        }\n      }\n      const next = Editor.next(editor, { at: path, match: n => Editor.isBlock(editor, n) })\n      if (!next) return\n      const [n, p] = next\n      block = n as Element\n      path = p\n    }\n    return\n  },\n  /**\n   * 检查选区是否选中在内容一行的开始或者结尾\n   * @param editor\n   * @param options\n   * @returns\n   */\n  isSelectLineEdge(editor: Editor, options: { point?: Point; edge?: SelectionEdge } = {}): boolean {\n    const { point = editor.selection?.focus, edge = 'start' } = options\n    if (!point) return false\n    const entry = Editor.above(editor, { at: point, match: n => Editor.isBlock(editor, n) })\n    if (!entry) return false\n    const [block] = entry\n    const rangeLines = getLineRectsByRange(editor, { anchor: point, focus: point })\n    if (rangeLines.length === 0) return false\n    const rangeLine = rangeLines[0]\n    const lines = getLineRectsByNode(editor, block)\n    for (const line of lines) {\n      if (\n        ~['start', 'anchor'].indexOf(edge) &&\n        line.left === rangeLine.left &&\n        line.top === rangeLine.top\n      ) {\n        return true\n      } else if (\n        ~['end', 'focus'].indexOf(edge) &&\n        line.right === rangeLine.right &&\n        line.top === rangeLine.top\n      ) {\n        return true\n      }\n    }\n    return false\n  },\n\n  /**\n   * Return the host window of the current editor.\n   */\n  getWindow(editor: Editor): Window {\n    const window = EDITOR_TO_WINDOW.get(editor)\n    if (!window) {\n      throw new Error('Unable to find a host window element for this editor')\n    }\n    return window\n  },\n\n  /**\n   * Find a key for a Editor node.\n   */\n\n  findKey(editor: Editor, node: Node): Key {\n    let key = NODE_TO_KEY.get(node)\n\n    if (!key) {\n      key = new Key()\n      NODE_TO_KEY.set(node, key)\n    }\n\n    return key\n  },\n\n  /**\n   * Find the path of Editor node.\n   */\n\n  findPath(editor: Editor, node: Node): Path {\n    const path: Path = []\n    let child = node\n\n    while (true) {\n      const parent = NODE_TO_PARENT.get(child)\n\n      if (parent == null) {\n        if (Editor.isEditor(child)) {\n          return path\n        } else {\n          break\n        }\n      }\n\n      const i = NODE_TO_INDEX.get(child)\n\n      if (i == null) {\n        break\n      }\n\n      path.unshift(i)\n      child = parent\n    }\n\n    throw new Error(`Unable to find the path for Editor node: ${Scrubber.stringify(node)}`)\n  },\n\n  /**\n   * Find the DOM node that implements DocumentOrShadowRoot for the editor.\n   */\n\n  findDocumentOrShadowRoot(editor: Editor): Document | ShadowRoot {\n    const el = Editable.toDOMNode(editor, editor)\n    const root = el.getRootNode()\n\n    if (\n      (root instanceof Document || root instanceof ShadowRoot) &&\n      (root as any).getSelection != null\n    ) {\n      return root\n    }\n\n    return el.ownerDocument\n  },\n\n  /**\n   * Check if the editor is focused.\n   */\n  isFocused(editor: Editor): boolean {\n    return Focused.is(editor)\n  },\n\n  /**\n   * Check if the editor is in read-only mode.\n   */\n\n  isReadOnly(editor: Editor): boolean {\n    return ReadOnly.is(editor)\n  },\n\n  /**\n   * Blur the editor.\n   */\n\n  blur(editor: Editable): void {\n    editor.blur()\n  },\n\n  /**\n   * Focus the editor.\n   */\n  focus(editor: Editable): void {\n    editor.focus()\n  },\n\n  deselect(editor: Editor): void {\n    const { selection } = editor\n    if (selection) {\n      Transforms.deselect(editor)\n    }\n  },\n\n  /**\n   * Check if a DOM node is within the editor.\n   */\n  hasDOMNode(editor: Editor, target: DOMNode): boolean {\n    const editorEl = Editable.toDOMNode(editor, editor)\n    let targetEl\n\n    // COMPAT: In Firefox, reading `target.nodeType` will throw an error if\n    // target is originating from an internal \"restricted\" element (e.g. a\n    // stepper arrow on a number input). (2018/05/04)\n    // https://github.com/ianstormtaylor/slate/issues/1819\n    try {\n      targetEl = (isDOMElement(target) ? target : target.parentElement) as HTMLElement\n    } catch (err: any) {\n      if (!err.message.includes('Permission denied to access property \"nodeType\"')) {\n        throw err\n      }\n    }\n\n    if (!targetEl) {\n      return false\n    }\n\n    return targetEl.closest(`[${DATA_EDITABLE_NODE}=\"editor\"]`) === editorEl\n  },\n\n  /**\n   * Find the native DOM element from a Editor node.\n   */\n\n  toDOMNode(editor: Editor, node: Node): HTMLElement {\n    const KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor)\n    const offsetNode = Editor.isEditor(node)\n      ? EDITOR_TO_ELEMENT.get(editor)\n      : KEY_TO_ELEMENT?.get(Editable.findKey(editor, node))\n\n    if (!offsetNode) {\n      throw new Error(`Cannot resolve a DOM node from Editor node: ${Scrubber.stringify(node)}`)\n    }\n\n    return offsetNode\n  },\n\n  /**\n   * Find a native DOM selection point from a Editor point.\n   */\n  toDOMPoint(editor: Editor, point: Point): DOMPoint {\n    const [node] = Editor.node(editor, point.path)\n    const el = Editable.toDOMNode(editor, node)\n    let domPoint: DOMPoint | undefined\n\n    // If we're inside a void node, force the offset to 0, otherwise the zero\n    // width spacing character will result in an incorrect offset of 1\n    if (Editor.void(editor, { at: point })) {\n      point = { path: point.path, offset: 0 }\n    }\n\n    // For each leaf, we need to isolate its content, which means filtering\n    // to its direct text and zero-width spans. (We have to filter out any\n    // other siblings that may have been rendered alongside them.)\n    const selector = `[${DATA_EDITABLE_STRING}], [${DATA_EDITABLE_COMPOSITION}], [${DATA_EDITABLE_ZERO_WIDTH}]`\n    const texts = Array.from(el.querySelectorAll(selector))\n    let start = 0\n\n    for (const text of texts) {\n      const offsetNode = text.childNodes[0] as HTMLElement\n\n      if (offsetNode == null || offsetNode.textContent == null) {\n        continue\n      }\n\n      const { length } = offsetNode.textContent\n      const attr = text.getAttribute(DATA_EDITABLE_LENGTH)\n      const trueLength = attr == null ? length : parseInt(attr, 10)\n      const end = start + trueLength\n\n      if (point.offset <= end) {\n        const offset = Math.min(length, Math.max(0, point.offset - start))\n        domPoint = [offsetNode, offset]\n        break\n      }\n\n      start = end\n    }\n\n    if (!domPoint) {\n      throw new Error(`Cannot resolve a DOM point from Editor point: ${Scrubber.stringify(point)}`)\n    }\n\n    return domPoint\n  },\n\n  /**\n   * Find a native DOM range from a Editor `range`.\n   *\n   * Notice: the returned range will always be ordinal regardless of the direction of Editor `range` due to DOM API limit.\n   *\n   * there is no way to create a reverse DOM Range using Range.setStart/setEnd\n   * according to https://dom.spec.whatwg.org/#concept-range-bp-set.\n   */\n  toDOMRange(editor: Editor, range: Range): DOMRange {\n    const { anchor, focus } = range\n    const isBackward = Range.isBackward(range)\n    const domAnchor = Editable.toDOMPoint(editor, anchor)\n    const domFocus = Range.isCollapsed(range) ? domAnchor : Editable.toDOMPoint(editor, focus)\n\n    const window = Editable.getWindow(editor)\n    const domRange = window.document.createRange()\n    const [startNode, startOffset] = isBackward ? domFocus : domAnchor\n    const [endNode, endOffset] = isBackward ? domAnchor : domFocus\n\n    // A editor Point at zero-width Leaf always has an offset of 0 but a native DOM selection at\n    // zero-width node has an offset of 1 so we have to check if we are in a zero-width node and\n    // adjust the offset accordingly.\n    const startEl = (isDOMElement(startNode) ? startNode : startNode.parentElement) as HTMLElement\n    const isStartAtZeroWidth = !!startEl.getAttribute(DATA_EDITABLE_ZERO_WIDTH)\n    const endEl = (isDOMElement(endNode) ? endNode : endNode.parentElement) as HTMLElement\n    const isEndAtZeroWidth = !!endEl.getAttribute(DATA_EDITABLE_ZERO_WIDTH)\n\n    domRange.setStart(startNode, isStartAtZeroWidth ? 1 : startOffset)\n    domRange.setEnd(endNode, isEndAtZeroWidth ? 1 : endOffset)\n    return domRange\n  },\n\n  /**\n   * Find a Editor node from a native DOM `element`.\n   */\n  toEditorNode(editor: Editor, offsetNode: DOMNode): Node {\n    let domEl = isDOMElement(offsetNode) ? offsetNode : offsetNode.parentElement\n\n    if (domEl && !domEl.hasAttribute(DATA_EDITABLE_NODE)) {\n      domEl = domEl.closest(`[${DATA_EDITABLE_NODE}]`)\n    }\n\n    const node = domEl ? ELEMENT_TO_NODE.get(domEl as HTMLElement) : null\n\n    if (!node) {\n      throw new Error(`Cannot resolve a Editor node from DOM node: ${domEl}`)\n    }\n\n    return node\n  },\n\n  findLowestDOMElements(editor: Editor, node: Node) {\n    const domNode = Editable.toDOMNode(editor, node)\n    if (Editor.isVoid(editor, node)) return [domNode]\n    const nodes = domNode.querySelectorAll(\n      `[${DATA_EDITABLE_STRING}], [${DATA_EDITABLE_COMPOSITION}], [${DATA_EDITABLE_ZERO_WIDTH}]`,\n    )\n    return Array.from(nodes)\n  },\n\n  findClosestPoint(editor: Editor, domNode: DOMNode, x: number, y: number): Point | null {\n    const domEl = isDOMElement(domNode) ? domNode : domNode.parentElement\n    if (!domEl) return null\n    const elements: DOMElement[] = []\n    let element: DOMElement | null = domEl.hasAttribute(DATA_EDITABLE_NODE)\n      ? domEl\n      : domEl.closest(`[${DATA_EDITABLE_NODE}]`)\n\n    const addToElements = (node: Node) => {\n      if (!NODE_TO_ELEMENT.get(node)) return\n      const children = Editable.findLowestDOMElements(editor, node)\n      for (const child of children) {\n        if (~elements.indexOf(child)) continue\n        elements.push(child)\n      }\n    }\n\n    if (!element) {\n      const nodes = Node.nodes(editor)\n      for (const [node] of nodes) {\n        addToElements(node)\n      }\n    } else {\n      const node = Editable.toEditorNode(editor, element)\n      if (Text.isText(node) || Editor.isVoid(editor, node)) {\n        addToElements(node)\n      } else {\n        if (!Editor.isSolidVoid(editor, node)) {\n          const rect = element.getBoundingClientRect()\n          const reverse = x < rect.left + rect.width / 2\n          const adjacent = (reverse ? Editor.previous : Editor.next)(editor, {\n            at: Editable.findPath(editor, node),\n          })\n          if (adjacent) {\n            addToElements(adjacent[0])\n          }\n        } else {\n          const isGrid = Editor.isGrid(editor, node)\n          const nodes = Editor.nodes(editor, {\n            at: Editable.findPath(editor, node),\n            match: n => (isGrid && Editor.isGridCell(editor, n)) || Text.isText(n),\n            mode: 'highest',\n          })\n          for (const [child] of nodes) {\n            if (Editor.isBlock(editor, child)) {\n              elements.push(Editable.toDOMNode(editor, child))\n            } else addToElements(child)\n          }\n        }\n      }\n    }\n    let top = y,\n      left = x\n    const nodes = findNearbyNodes(elements, x, y)\n    if (!nodes) return null\n    let offsetNode: DOMElement | null = null\n    if (isDOMNode(nodes)) {\n      offsetNode = nodes\n    } else {\n      const { top: nearbyTop, left: nearbyLeft, right: nearbyRight, below: nearbyBelow } = nodes\n\n      if (nearbyLeft && nearbyBelow) {\n        if (isAlignY(nearbyBelow.rect, nearbyLeft.rect)) {\n          offsetNode = nearbyBelow.node\n          top = nearbyBelow.rect.top\n        } else {\n          offsetNode = nearbyLeft.node\n          left = nearbyLeft.rect.right\n        }\n      } else if (nearbyRight && nearbyBelow) {\n        if (isAlignY(nearbyBelow.rect, nearbyRight.rect)) {\n          offsetNode = nearbyBelow.node\n          top = nearbyBelow.rect.top\n        } else {\n          offsetNode = nearbyRight.node\n          left = nearbyRight.rect.left\n        }\n      } else if (nearbyLeft) {\n        offsetNode = nearbyLeft.node\n        if (left <= nearbyLeft.rect.left) left = nearbyLeft.rect.left\n        else if (left >= nearbyLeft.rect.right) left = nearbyLeft.rect.right\n        else {\n          top = nearbyLeft.rect.top\n        }\n      } else if (nearbyRight) {\n        offsetNode = nearbyRight.node\n        if (left <= nearbyRight.rect.left) left = nearbyRight.rect.left\n        else if (left >= nearbyRight.rect.right) left = nearbyRight.rect.right\n        else {\n          top = nearbyRight.rect.top\n        }\n      } else if (nearbyBelow) {\n        if (left < nearbyBelow.rect.left) {\n          left = nearbyBelow.rect.left\n        } else if (left > nearbyBelow.rect.right) {\n          left = nearbyBelow.rect.right\n        }\n        top = nearbyBelow.rect.top\n        offsetNode = nearbyBelow.node\n      } else if (nearbyTop) {\n        offsetNode = nearbyTop.node\n        if (left < nearbyTop.rect.left) {\n          left = nearbyTop.rect.left\n        } else if (left > nearbyTop.rect.right) {\n          left = nearbyTop.rect.right\n        }\n        top = nearbyTop.rect.bottom\n      }\n    }\n    if (!offsetNode) return null\n    const node = Editable.toEditorNode(editor, offsetNode)\n    if (Text.isText(node)) {\n      const path = Editable.findPath(editor, node)\n      if (node.text.length === 0) {\n        return {\n          path,\n          offset: 0,\n        }\n      }\n      const textNodes = Editable.findLowestDOMElements(editor, node)\n      let startOffset = 0\n      for (let s = 0; s < textNodes.length; s++) {\n        const textNode = textNodes[s]\n        if (textNode === offsetNode) break\n        startOffset += (textNode.textContent ?? '').length\n      }\n      const textNode = isDOMText(offsetNode) ? offsetNode : offsetNode.firstChild\n      if (!isDOMText(textNode)) return null\n      const content = textNode.textContent ?? ''\n      const offset = getTextOffset(textNode, left, top, 0, content.length, content.length)\n      return {\n        path,\n        offset: startOffset + offset,\n      }\n    } else if (Element.isElement(node)) {\n      const point = Editable.toEditorPoint(editor, [offsetNode, 0], {\n        exactMatch: false,\n        suppressThrow: true,\n      })\n      if (!point) return Editor.start(editor, Editable.findPath(editor, node))\n      return point\n    }\n    return null\n  },\n  /**\n   * Get the target point from a DOM `event`.\n   */\n  findEventPoint(editor: Editor, event: any): Point | null {\n    event = getNativeEvent(event)\n    const { clientX: x, clientY: y } = event\n\n    if (x == null || y == null) {\n      throw new Error(`Cannot resolve a Editor range from a DOM event: ${event}`)\n    }\n    let target = event.target\n    if (isTouch(event)) {\n      target = document.elementFromPoint(event.clientX, event.clientY)\n    }\n    return Editable.findClosestPoint(editor, target, x, y)\n  },\n\n  findPreviousLinePoint(editor: Editor, at?: Range): Point | null {\n    const { selection } = editor\n    if (!at && selection) at = selection\n    if (!at) return null\n    const startPoint = Range.start(at)\n    const endPoint = Range.end(at)\n    const startRange = Editable.toDOMRange(editor, { anchor: startPoint, focus: startPoint })\n    const endRange = Editable.toDOMRange(editor, { anchor: endPoint, focus: endPoint })\n\n    const startRects = startRange.getClientRects()\n    const endRects = endRange.getClientRects()\n\n    const block = Editor.above(editor, {\n      at: at.focus,\n      match: n => Editor.isBlock(editor, n),\n    })\n    let top = endRects[0].top\n    let isFind = false\n\n    let isSameLine = true\n\n    let prevBlock = block\n    let domBlock: DOMElement | null = null\n    while (prevBlock && !isFind) {\n      const [block, path] = prevBlock\n      domBlock = Editable.toDOMNode(editor, block)\n      const lowestElements = Editable.findLowestDOMElements(editor, block)\n      for (let l = lowestElements.length - 1; l >= 0 && !isFind; l--) {\n        const lowestElement = lowestElements[l]\n        const rects = lowestElement.getClientRects()\n        for (let i = 0; i < rects.length; i++) {\n          const rect = rects[i]\n          if (rect.height === 0) continue\n          if (rect.bottom <= top) {\n            isFind = true\n            top = rect.bottom - rect.height / 2\n            break\n          }\n        }\n      }\n      if (!isFind) {\n        isSameLine = false\n        prevBlock = Editor.previous(editor, {\n          at: path,\n          match: n => Editor.isBlock(editor, n),\n        })\n      }\n    }\n    if (!domBlock) return null\n    return Editable.findClosestPoint(\n      editor,\n      domBlock,\n      isFind && !isSameLine ? startRects[0].x : 0,\n      top,\n    )\n  },\n\n  findLineEdgePoint(\n    editor: Editor,\n    { at, edge = 'start' }: { at?: Range; edge?: 'start' | 'end' } = {},\n  ): Point | null {\n    const { selection } = editor\n    if (!at && selection) at = selection\n    if (!at) return null\n    const isStart = edge === 'start'\n    const point = isStart ? Range.start(at) : Range.end(at)\n    const range = Editable.toDOMRange(editor, {\n      anchor: point,\n      focus: point,\n    })\n    range.collapse(isStart)\n    const rects = range.getClientRects()\n    const rect = rects[rects.length - 1]\n    const bottom = rect.top + rect.height / 2\n    const block = Editor.above(editor, {\n      at: point,\n      match: n => Editor.isBlock(editor, n),\n    })\n    if (!block) return null\n    const domBlock = Editable.toDOMNode(editor, block[0])\n    return Editable.findClosestPoint(editor, domBlock, isStart ? -99999 : 99999, bottom)\n  },\n\n  findNextLinePoint(editor: Editor, at?: Range): Point | null {\n    const { selection } = editor\n    if (!at && selection) at = selection\n    if (!at) return null\n    const startPoint = Range.start(at)\n    const endPoint = Range.end(at)\n    const startRange = Editable.toDOMRange(editor, { anchor: startPoint, focus: startPoint })\n    const endRange = Editable.toDOMRange(editor, { anchor: endPoint, focus: endPoint })\n\n    const startRects = startRange.getClientRects()\n    const endRects = endRange.getClientRects()\n\n    let blockEntry = Editor.above(editor, {\n      at: at.focus,\n      match: n => Editor.isBlock(editor, n),\n    })\n    let bottom = endRects[0].bottom\n    let isFind = false\n    let isSameLine = true\n    let domBlock: DOMElement | null = null\n    while (blockEntry && !isFind) {\n      const [block, path] = blockEntry\n      domBlock = Editable.toDOMNode(editor, block)\n      const lowestElements = Editable.findLowestDOMElements(editor, block)\n      for (let l = 0; l < lowestElements.length && !isFind; l++) {\n        const lowestElement = lowestElements[l]\n        const rects = lowestElement.getClientRects()\n        for (let i = 0; i < rects.length; i++) {\n          const rect = rects[i]\n          if (rect.height === 0) continue\n          if (rect.top >= bottom) {\n            isFind = true\n            bottom = rect.top + rect.height / 2\n            break\n          }\n        }\n      }\n      if (!isFind) {\n        blockEntry = Editor.next(editor, {\n          at: path,\n          match: n => Editor.isBlock(editor, n),\n        })\n        isSameLine = false\n      }\n    }\n    if (!domBlock) return null\n\n    return Editable.findClosestPoint(\n      editor,\n      domBlock,\n      isFind && !isSameLine ? startRects[0].x : 99999,\n      bottom,\n    )\n  },\n\n  findTextOffsetOnLine(editor: Editor, point: Point) {\n    const blockEntry = Editor.above(editor, {\n      match: n => Editor.isBlock(editor, n),\n      at: point,\n    })\n    const data = {\n      text: '',\n      offset: 0,\n    }\n    if (!blockEntry) {\n      throw new Error(`Cannot resolve a Editor block from a point: ${point}`)\n    }\n    const textNodes = Node.texts(blockEntry[0])\n    let isFindOffset = false\n    for (const [textNode, textPath] of textNodes) {\n      let { text } = textNode\n      const path = blockEntry[1].concat(textPath)\n      const [parent] = Editor.parent(editor, path)\n      if (parent && Editor.isVoid(editor, parent)) {\n        text = ''\n      }\n      if (Path.equals(path, point.path)) {\n        data.offset += point.offset\n        isFindOffset = true\n      } else if (!isFindOffset) {\n        data.offset += text.length\n      }\n      data.text += text\n    }\n    return data\n  },\n\n  findPointOnLine(editor: Editor, path: Path, offset: number, moveNext: boolean = false) {\n    const blockEntry = Editor.above(editor, {\n      match: n => Editor.isBlock(editor, n),\n      at: path,\n    })\n    if (!blockEntry) {\n      throw new Error(`Cannot resolve a Editor block from a path: ${path}`)\n    }\n    const textNodes = Node.texts(blockEntry[0])\n    let findOffset = 0\n    for (const [textNode, textPath] of textNodes) {\n      let { text } = textNode\n      const path = blockEntry[1].concat(textPath)\n      const [parent, parentPath] = Editor.parent(editor, path)\n      const isVoid = parent && Editor.isVoid(editor, parent)\n      if (isVoid) {\n        text = ' '\n      }\n      const textLength = text.length\n      const totalOffset = findOffset + textLength\n      if (totalOffset >= offset) {\n        if (moveNext && offset > 0 && totalOffset === offset) {\n          const next = Editor.next(editor, {\n            at: isVoid ? parentPath : path,\n          })\n          if (next) {\n            return {\n              path: next[1],\n              offset: 0,\n            }\n          }\n        }\n        return { path, offset: textLength - (totalOffset - offset) }\n      } else {\n        findOffset += textLength\n      }\n    }\n    return { path, offset }\n  },\n\n  /**\n   * Find a Editor point from a DOM selection's `offsetNode` and `domOffset`.\n   */\n  toEditorPoint<T extends boolean>(\n    editor: Editor,\n    domPoint: DOMPoint,\n    options: {\n      exactMatch: T\n      suppressThrow: T\n    },\n  ): T extends true ? Point | null : Point {\n    const { exactMatch, suppressThrow } = options\n    const [nearestNode, nearestOffset] = exactMatch ? domPoint : normalizeDOMPoint(domPoint)\n    const parentNode = nearestNode.parentNode as DOMElement\n    let textNode: DOMElement | null = null\n    let offset = 0\n\n    if (parentNode) {\n      const editorEl = Editable.toDOMNode(editor, editor)\n      const potentialVoidNode = parentNode.closest(`[${DATA_EDITABLE_VOID}]`)\n      // Need to ensure that the closest void node is actually a void node\n      // within this editor, and not a void node within some parent editor. This can happen\n      // if this editor is within a void node of another editor (\"nested editors\", like in\n      // the \"Editable Voids\" example on the docs site).\n      const voidNode =\n        potentialVoidNode && editorEl.contains(potentialVoidNode) ? potentialVoidNode : null\n      let leafNode = parentNode.closest(`[${DATA_EDITABLE_LEAF}]`)\n      let offsetNode: DOMElement | null = null\n\n      // Calculate how far into the text node the `nearestNode` is, so that we\n      // can determine what the offset relative to the text node is.\n      if (leafNode) {\n        textNode = leafNode.closest(`[${DATA_EDITABLE_NODE}=\"text\"]`)\n\n        if (textNode) {\n          const window = Editable.getWindow(editor)\n          const range = window.document.createRange()\n          range.setStart(textNode, 0)\n          range.setEnd(nearestNode, nearestOffset)\n\n          const contents = range.cloneContents()\n          const removals = [\n            ...Array.prototype.slice.call(\n              contents.querySelectorAll(`[${DATA_EDITABLE_ZERO_WIDTH}]`),\n            ),\n          ]\n\n          removals.forEach(el => {\n            el!.parentNode!.removeChild(el)\n          })\n\n          // COMPAT: Edge has a bug where Range.prototype.toString() will\n          // convert \\n into \\r\\n. The bug causes a loop when slate-react\n          // attempts to reposition its cursor to match the native position. Use\n          // textContent.length instead.\n          // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\n          offset = contents.textContent!.length\n          offsetNode = textNode\n        }\n      } else if (voidNode) {\n        // For void nodes, the element with the offset key will be a cousin, not an\n        // ancestor, so find it by going down from the nearest void parent.\n        leafNode = voidNode.querySelector(`[${DATA_EDITABLE_LEAF}]`)!\n\n        // COMPAT: In read-only editors the leaf is not rendered.\n        if (!leafNode) {\n          offset = 1\n        } else {\n          textNode = leafNode.closest(`[${DATA_EDITABLE_NODE}=\"text\"]`)!\n          offsetNode = leafNode\n          offset = offsetNode.textContent!.length\n          offsetNode.querySelectorAll(`[${DATA_EDITABLE_ZERO_WIDTH}]`).forEach(el => {\n            offset -= el.textContent!.length\n          })\n        }\n      }\n\n      if (\n        offsetNode &&\n        offset === offsetNode.textContent!.length &&\n        // COMPAT: If the parent node is a Editor zero-width space, editor is\n        // because the text node should have no characters. However, during IME\n        // composition the ASCII characters will be prepended to the zero-width\n        // space, so subtract 1 from the offset to account for the zero-width\n        // space character.\n        (parentNode.hasAttribute(DATA_EDITABLE_ZERO_WIDTH) ||\n          // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\\n'\n          // when the document ends with a new-line character. This results in the offset\n          // length being off by one, so we need to subtract one to account for this.\n          (IS_FIREFOX && offsetNode.textContent?.endsWith('\\n\\n')))\n      ) {\n        offset--\n      }\n    }\n\n    if (!textNode) {\n      if (suppressThrow) {\n        return null as T extends true ? Point | null : Point\n      }\n      throw new Error(`Cannot resolve a Editor point from DOM point: ${domPoint}`)\n    }\n\n    // COMPAT: If someone is clicking from one Editor editor into another,\n    // the select event fires twice, once for the old editor's `element`\n    // first, and then afterwards for the correct `element`. (2017/03/03)\n    const editorNode = Editable.toEditorNode(editor, textNode!)\n    const path = Editable.findPath(editor, editorNode)\n    return { path, offset } as T extends true ? Point | null : Point\n  },\n\n  /**\n   * Find a Editor range from a DOM range or selection.\n   */\n  toEditorRange<T extends boolean>(\n    editor: Editor,\n    domRange: DOMRange | DOMStaticRange | DOMSelection,\n    options: {\n      exactMatch: T\n      suppressThrow: T\n    },\n  ): T extends true ? Range | null : Range {\n    const { exactMatch, suppressThrow } = options\n    const el = isDOMSelection(domRange) ? domRange.anchorNode : domRange.startContainer\n    let anchorNode\n    let anchorOffset\n    let focusNode\n    let focusOffset\n    let isCollapsed\n\n    if (el) {\n      if (isDOMSelection(domRange)) {\n        anchorNode = domRange.anchorNode\n        anchorOffset = domRange.anchorOffset\n        focusNode = domRange.focusNode\n        focusOffset = domRange.focusOffset\n        // COMPAT: There's a bug in chrome that always returns `true` for\n        // `isCollapsed` for a Selection that comes from a ShadowRoot.\n        // (2020/08/08)\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n        if (IS_CHROME && hasShadowRoot()) {\n          isCollapsed =\n            domRange.anchorNode === domRange.focusNode &&\n            domRange.anchorOffset === domRange.focusOffset\n        } else {\n          isCollapsed = domRange.isCollapsed\n        }\n      } else {\n        anchorNode = domRange.startContainer\n        anchorOffset = domRange.startOffset\n        focusNode = domRange.endContainer\n        focusOffset = domRange.endOffset\n        isCollapsed = domRange.collapsed\n      }\n    }\n\n    if (anchorNode == null || focusNode == null || anchorOffset == null || focusOffset == null) {\n      throw new Error(`Cannot resolve a Editor range from DOM range: ${domRange}`)\n    }\n\n    const anchor = Editable.toEditorPoint(editor, [anchorNode, anchorOffset], {\n      exactMatch,\n      suppressThrow,\n    })\n    if (!anchor) {\n      return null as T extends true ? Range | null : Range\n    }\n\n    const focus = isCollapsed\n      ? anchor\n      : Editable.toEditorPoint(editor, [focusNode, focusOffset], {\n          exactMatch,\n          suppressThrow,\n        })\n    if (!focus) {\n      return null as T extends true ? Range | null : Range\n    }\n\n    let range: Range = { anchor: anchor as Point, focus: focus as Point }\n    // if the selection is a hanging range that ends in a void\n    // and the DOM focus is an Element\n    // (meaning that the selection ends before the element)\n    // unhang the range to avoid mistakenly including the void\n    if (\n      Range.isExpanded(range) &&\n      Range.isForward(range) &&\n      isDOMElement(focusNode) &&\n      Editor.void(editor, { at: range.focus, mode: 'highest' })\n    ) {\n      range = Editor.unhangRange(editor, range, { voids: true })\n    }\n\n    return range as unknown as T extends true ? Range | null : Range\n  },\n\n  toRelativePosition(editor: Editor, x: number, y: number): [number, number] {\n    const container = Editable.toDOMNode(editor, editor)\n    const rootRect = container.getBoundingClientRect()\n\n    return [x - rootRect.left, y - rootRect.top]\n  },\n\n  reverseRelativePosition(editor: Editor, x: number, y: number): [number, number] {\n    const container = Editable.toDOMNode(editor, editor)\n    const rootRect = container.getBoundingClientRect()\n    return [x + rootRect.left, y + rootRect.top]\n  },\n\n  scrollIntoView(editor: Editor, range = editor.selection) {\n    if (!range) return\n    const domRange = Editable.toDOMRange(editor, range)\n    const focusEl = domRange.endContainer.parentElement!\n    scrollIntoView(focusEl, {\n      scrollMode: 'if-needed',\n    })\n  },\n}\n","import { Ancestor, Editor, Node, Key } from '@editablejs/models'\n\n/**\n * Two weak maps that allow us rebuild a path given a node. They are populated\n * at render time such that after a render occurs we can always backtrack.\n */\n\nexport const NODE_TO_INDEX: WeakMap<Node, number> = new WeakMap()\nexport const NODE_TO_PARENT: WeakMap<Node, Ancestor> = new WeakMap()\n\n/**\n * Weak maps that allow us to go between Slate nodes and DOM nodes. These\n * are used to resolve DOM event-related logic into Slate actions.\n */\nexport const EDITOR_TO_WINDOW: WeakMap<Editor, Window> = new WeakMap()\nexport const EDITOR_TO_ELEMENT: WeakMap<Editor, HTMLElement> = new WeakMap()\nexport const EDITOR_TO_INPUT: WeakMap<Editor, HTMLTextAreaElement> = new WeakMap()\nexport const EDITOR_TO_SHADOW: WeakMap<Editor, ShadowRoot | null> = new WeakMap()\nexport const ELEMENT_TO_NODE: WeakMap<HTMLElement, Node> = new WeakMap()\nexport const NODE_TO_ELEMENT: WeakMap<Node, HTMLElement> = new WeakMap()\nexport const NODE_TO_KEY: WeakMap<Node, Key> = new WeakMap()\nexport const EDITOR_TO_KEY_TO_ELEMENT: WeakMap<Editor, WeakMap<Key, HTMLElement>> = new WeakMap()\nexport const EDITOR_TO_SELECTION_RECTS = new WeakMap<Editor, DOMRect[]>()\n\n/**\n * Weak maps for storing editor-related state.\n */\nexport const IS_CLICKING: WeakMap<Editor, boolean> = new WeakMap()\nexport const IS_COMPOSING: WeakMap<Editor, boolean> = new WeakMap()\nexport const IS_ON_COMPOSITION_END: WeakMap<Editor, boolean> = new WeakMap()\nexport const IS_SHIFT_PRESSED: WeakMap<Editor, boolean> = new WeakMap()\nexport const IS_MOUSEDOWN: WeakMap<Editor, boolean> = new WeakMap()\nexport const IS_TOUCHMOVING: WeakMap<Editor, boolean> = new WeakMap()\nexport const IS_TOUCHING: WeakMap<Editor, boolean> = new WeakMap()\nexport const IS_TOUCH_HOLD: WeakMap<Editor, boolean> = new WeakMap()\n/**\n * Weak map for associating the context `onChange` context with the plugin.\n */\nexport const NODE_TO_RESTORE_DOM = new WeakMap<Node, () => void>()\n\nexport const IS_PASTE_TEXT: WeakMap<Editor, boolean> = new WeakMap()\n","// COMPAT: This is required to prevent TypeScript aliases from doing some very\n// weird things for Slate's types with the same name as globals. (2019/11/27)\nimport {\n  DOMPoint,\n  isDOMElement,\n  DOMElement,\n  DOMNode,\n  isDOMComment,\n  isDOMHTMLElement,\n} from '@editablejs/models'\nimport { Constants } from './constants'\nimport { CAN_USE_DOM } from './environment'\n\n/**\n * Normalize a DOM point so that it always refers to a text node.\n */\n\nexport const normalizeDOMPoint = (domPoint: DOMPoint): DOMPoint => {\n  let [node, offset] = domPoint\n\n  // If it's an element node, its offset refers to the index of its children\n  // including comment nodes, so try to find the right text child node.\n  if (isDOMElement(node) && node.childNodes.length) {\n    let isLast = offset === node.childNodes.length\n    let index = isLast ? offset - 1 : offset\n    ;[node, index] = getEditableChildAndIndex(node, index, isLast ? 'backward' : 'forward')\n    // If the editable child found is in front of input offset, we instead seek to its end\n    isLast = index < offset\n\n    // If the node has children, traverse until we have a leaf node. Leaf nodes\n    // can be either text nodes, or other void DOM nodes.\n    while (isDOMElement(node) && node.childNodes.length) {\n      const i = isLast ? node.childNodes.length - 1 : 0\n      node = getEditableChild(node, i, isLast ? 'backward' : 'forward')\n    }\n\n    // Determine the new offset inside the text node.\n    offset = isLast && node.textContent != null ? node.textContent.length : 0\n  }\n\n  // Return the node and offset.\n  return [node, offset]\n}\n\n/**\n * Determines wether the active element is nested within a shadowRoot\n */\n\nexport const hasShadowRoot = () => {\n  return !!(window.document.activeElement && window.document.activeElement.shadowRoot)\n}\n\n/**\n * Get the nearest editable child and index at `index` in a `parent`, preferring\n * `direction`.\n */\n\nexport const getEditableChildAndIndex = (\n  parent: DOMElement,\n  index: number,\n  direction: 'forward' | 'backward',\n): [DOMNode, number] => {\n  const { childNodes } = parent\n  let child = childNodes[index]\n  let i = index\n  let triedForward = false\n  let triedBackward = false\n\n  // While the child is a comment node, or an element node with no children,\n  // keep iterating to find a sibling non-void, non-comment node.\n  while (isDOMComment(child) || (isDOMElement(child) && child.childNodes.length === 0)) {\n    if (triedForward && triedBackward) {\n      break\n    }\n\n    if (i >= childNodes.length) {\n      triedForward = true\n      i = index - 1\n      direction = 'backward'\n      continue\n    }\n\n    if (i < 0) {\n      triedBackward = true\n      i = index + 1\n      direction = 'forward'\n      continue\n    }\n\n    child = childNodes[i]\n    index = i\n    i += direction === 'forward' ? 1 : -1\n  }\n\n  return [child, index]\n}\n\n/**\n * Get the nearest editable child at `index` in a `parent`, preferring\n * `direction`.\n */\n\nexport const getEditableChild = (\n  parent: DOMElement,\n  index: number,\n  direction: 'forward' | 'backward',\n): DOMNode => {\n  const [child] = getEditableChildAndIndex(parent, index, direction)\n  return child\n}\n\nexport const isEditableDOMElement = (value: any): boolean => {\n  if (isDOMHTMLElement(value)) {\n    return ['INPUT', 'TEXTAREA'].indexOf(value.nodeName) > -1 || value.isContentEditable\n  }\n  return false\n}\n\nexport const canForceTakeFocus = () => {\n  if (!CAN_USE_DOM) return true\n  const activeElement = document.activeElement\n  if (isEditableDOMElement(activeElement)) return false\n  return true\n}\n\nexport const inAbsoluteDOMElement = (value: any): boolean => {\n  if (isDOMHTMLElement(value)) {\n    let node: HTMLElement | null = value\n    while (node) {\n      const attributeNames = node.getAttributeNames()\n      if (attributeNames.some(name => Constants.dataNode === name)) return false\n      const styles = getComputedStyle(node)\n      if (~['absolute', 'fixed'].indexOf(styles.position)) {\n        return true\n      }\n      node = node.parentElement\n    }\n  }\n  return false\n}\n","import * as React from 'react'\n\nexport const IS_REACT_VERSION_17_OR_ABOVE = parseInt(React.version.split('.')[0], 10) >= 17\n\nexport const IS_IOS =\n  typeof navigator !== 'undefined' &&\n  typeof window !== 'undefined' &&\n  /iPad|iPhone|iPod/.test(navigator.userAgent) &&\n  !(window as any).MSStream\n\nexport const IS_APPLE = typeof navigator !== 'undefined' && /Mac OS X/.test(navigator.userAgent)\n\nexport const IS_FIREFOX =\n  typeof navigator !== 'undefined' && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent)\n\nexport const IS_SAFARI =\n  typeof navigator !== 'undefined' && /Version\\/[\\d\\.]+.*Safari/.test(navigator.userAgent)\n\n// \"modern\" Edge was released at 79.x\nexport const IS_EDGE_LEGACY =\n  typeof navigator !== 'undefined' &&\n  /Edge?\\/(?:[0-6][0-9]|[0-7][0-8])(?:\\.)/i.test(navigator.userAgent)\n\nexport const IS_CHROME = typeof navigator !== 'undefined' && /Chrome/i.test(navigator.userAgent)\n\n// Native `beforeInput` events don't work well with react on Chrome 75\n// and older, Chrome 76+ can use `beforeInput` though.\nexport const IS_CHROME_LEGACY =\n  typeof navigator !== 'undefined' &&\n  /Chrome?\\/(?:[0-7][0-5]|[0-6][0-9])(?:\\.)/i.test(navigator.userAgent)\n\n// Firefox did not support `beforeInput` until `v87`.\nexport const IS_FIREFOX_LEGACY =\n  typeof navigator !== 'undefined' &&\n  /^(?!.*Seamonkey)(?=.*Firefox\\/(?:[0-7][0-9]|[0-8][0-6])(?:\\.)).*/i.test(navigator.userAgent)\n\n// qq browser\nexport const IS_QQBROWSER =\n  typeof navigator !== 'undefined' && /.*QQBrowser/.test(navigator.userAgent)\n\n// UC mobile browser\nexport const IS_UC_MOBILE =\n  typeof navigator !== 'undefined' && /.*UCBrowser/.test(navigator.userAgent)\n\n// Wechat browser\nexport const IS_WECHATBROWSER =\n  typeof navigator !== 'undefined' && /.*Wechat/.test(navigator.userAgent)\n\n// Check if DOM is available as React does internally.\n// https://github.com/facebook/react/blob/master/packages/shared/ExecutionEnvironment.js\nexport const CAN_USE_DOM = !!(\n  typeof window !== 'undefined' &&\n  typeof window.document !== 'undefined' &&\n  typeof window.document.createElement !== 'undefined'\n)\n\n// COMPAT: Firefox/Edge Legacy don't support the `beforeinput` event\n// Chrome Legacy doesn't support `beforeinput` correctly\nexport const HAS_BEFORE_INPUT_SUPPORT =\n  !IS_CHROME_LEGACY &&\n  !IS_EDGE_LEGACY &&\n  // globalThis is undefined in older browsers\n  typeof globalThis !== 'undefined' &&\n  globalThis.InputEvent &&\n  // @ts-ignore The `getTargetRanges` property isn't recognized.\n  typeof globalThis.InputEvent.prototype.getTargetRanges === 'function'\n\n/**\n * Touch devices\n */\nexport const isTouchDevice = CAN_USE_DOM && 'ontouchstart' in document.documentElement\n","interface NearbyNode {\n  node: Element\n  rect: DOMRect\n}\n\n/**\n * 是否在一个节点前面\n * @param rect\n * @param node\n * @param otherNode\n * @returns\n */\nexport const isPrecedingY = (rect: DOMRect, node: Node, other: NearbyNode) => {\n  return (\n    rect.bottom > other.rect.bottom ||\n    (rect.top === other.rect.bottom &&\n      node.compareDocumentPosition(other.node) === Node.DOCUMENT_POSITION_PRECEDING)\n  )\n}\n\nexport const isFollowingY = (rect: DOMRect, node: Node, other: NearbyNode) => {\n  return (\n    rect.top < other.rect.top ||\n    (rect.top === other.rect.top &&\n      node.compareDocumentPosition(other.node) === Node.DOCUMENT_POSITION_FOLLOWING)\n  )\n}\n\nexport const isPrecedingX = (rect: DOMRect, node: Node, other: NearbyNode) => {\n  return (\n    rect.right > other.rect.right ||\n    (rect.right === other.rect.right &&\n      node.compareDocumentPosition(other.node) === Node.DOCUMENT_POSITION_PRECEDING)\n  )\n}\n\nexport const isFollowingX = (rect: DOMRect, node: Node, other: NearbyNode) => {\n  return (\n    rect.left < other.rect.left ||\n    (rect.left === other.rect.left &&\n      node.compareDocumentPosition(other.node) === Node.DOCUMENT_POSITION_FOLLOWING)\n  )\n}\n\n/**\n * 是否垂直对齐\n * @param rect\n * @param other\n * @param scale\n * @returns\n */\nexport const isAlignY = (rect: DOMRect, other: DOMRect, scale = 0.4) => {\n  if (rect.bottom === other.bottom) return true\n  // 未在水平上\n  if (rect.top > other.bottom || other.top > rect.bottom) return false\n  const minHeight = Math.min(other.height, rect.height)\n  const innerHeight = Math.min(rect.bottom, other.bottom) - Math.max(rect.top, other.top)\n  // 超过多少比例在水平上\n  return 0 === minHeight || innerHeight / minHeight > scale\n}\n\n/**\n * 判断 x 在 rect 中是否处于 left 与 right 之间\n * @param x\n * @param rect\n * @returns\n */\nexport const isBetweenX = (x: number, rect: DOMRect) => {\n  return x >= rect.left && x <= rect.right\n}\n\n/**\n * 判断 y 在 rect 中是否处于 top 与 bottom 之间\n * @param y\n * @param rect\n * @returns\n */\nexport const isBetweenY = (y: number, rect: DOMRect) => {\n  return y >= rect.top && y <= rect.bottom\n}\n\n/**\n * 获取 x 在 rect 中 left 与 right 之间最小的距离\n * @param x\n * @param rect\n * @returns\n */\nexport const getMinXInRect = (x: number, rect: DOMRect) => {\n  return Math.min(Math.abs(x - rect.left), Math.abs(x - rect.right))\n}\n\nexport const onNearbyY = (\n  x: number,\n  rect: DOMRect,\n  node: Node,\n  nearbyNode: NearbyNode,\n  preceding = true,\n) => {\n  if (isAlignY(rect, nearbyNode.rect)) {\n    const topBetween = isBetweenX(x, nearbyNode.rect)\n    const isBetween = isBetweenX(x, rect)\n    const topMin = getMinXInRect(x, nearbyNode.rect)\n    const min = getMinXInRect(x, rect)\n    if (!topBetween && (isBetween || min < topMin)) {\n      return true\n    }\n    return false\n  } else if (preceding) {\n    return isPrecedingY(rect, node, nearbyNode)\n  } else {\n    return isFollowingY(rect, node, nearbyNode)\n  }\n}\n\ntype NearbyNodes = {\n  top: NearbyNode | null\n  below: NearbyNode | null\n  left: NearbyNode | null\n  right: NearbyNode | null\n}\n\n/**\n * 查找附近的节点\n * @param nodes\n * @param x\n * @param y\n * @returns\n */\nconst findNearbyNodes = (nodes: Element[], x: number, y: number): Element | NearbyNodes | null => {\n  const closerNode: NearbyNodes = {\n    top: null,\n    below: null,\n    left: null,\n    right: null,\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    const child = nodes[i]\n    const rects = child.getClientRects()\n    for (let r = 0; r < rects.length; r++) {\n      const rect = rects[r]\n      // 刚好在区域内\n      if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {\n        return child\n      }\n      // 点击位置在区域 top上方\n      else if (y < rect.top) {\n        if (!closerNode.below || onNearbyY(x, rect, child, closerNode.below, false)) {\n          closerNode.below = {\n            rect,\n            node: child,\n          }\n        }\n      }\n      // 点击区域在 bottom 上方\n      else if (y > rect.bottom) {\n        if (!closerNode.top || onNearbyY(x, rect, child, closerNode.top)) {\n          closerNode.top = {\n            rect,\n            node: child,\n          }\n        }\n        if (closerNode.left && isPrecedingX(rect, child, closerNode.left)) {\n          closerNode.left = {\n            rect,\n            node: child,\n          }\n        }\n      } else if (\n        isBetweenY(y, rect) &&\n        x > rect.left &&\n        (!closerNode.left || isPrecedingX(rect, child, closerNode.left))\n      ) {\n        closerNode.left = {\n          rect,\n          node: child,\n        }\n      } else if (\n        isBetweenY(y, rect) &&\n        x < rect.right &&\n        (!closerNode.right || isFollowingX(rect, child, closerNode.right))\n      ) {\n        closerNode.right = {\n          rect,\n          node: child,\n        }\n      }\n    }\n  }\n  return closerNode\n}\n\nexport default findNearbyNodes\n","import { nextBreak, previousBreak } from '@editablejs/breaker'\n\n/**\n * @zh-CN 获取字符串索引处的向前或向后字符\n * @param text 文本\n * @param offset 索引\n * @param backward 是否取向后的字符，默认 false\n * @returns 字符串索引处的上或下个字符\n */\nexport const getCharFromGraphemeBreaker = (text: string, offset: number, backward = false) => {\n  if (offset < 0 || offset > text.length) {\n    return ''\n  }\n  let value\n  if (backward) {\n    value = previousBreak(text, offset)\n    return text.substring(value, offset)\n  } else {\n    value = nextBreak(text, offset)\n    return text.substring(offset, value)\n  }\n}\n\n/**\n * 获取字符串索引处的向后的字符索引\n * @param text 文本\n * @param offset 索引\n * @returns 向后的字符索引\n */\nexport const getCharOffsetBackward = (text: string, offset: number) => {\n  return getCharFromGraphemeBreaker(text, offset, true).length || 1\n}\n\n/**\n * 获取字符串索引处的向前的字符索引\n * @param text 文本\n * @param offset 索引\n * @returns 向前的字符索引\n */\nexport const getCharOffsetForward = (text: string, offset: number) => {\n  return getCharFromGraphemeBreaker(text, offset).length || 1\n}\n\n/**\n * 字形断路器\n * 获取字符串中的字符范围，Unicode字符范围不确定（高代理、低代理、私有代理字符存在）\n * @param text 文本\n * @param offset 当前索引\n * @returns [start, end]\n */\nexport const getCharRange = (text: string, offset: number) => {\n  let i = 0\n  for (; i <= offset; ) {\n    const end = i + getCharOffsetForward(text, i)\n    if (end > offset) return [i, end]\n    i = end\n  }\n  return [i, i + Math.min(text.length, 1)]\n}\n\nconst isSpace = (char: string) => /\\s/.test(char)\n// http://www.unicode.org/charts/\nconst isIdeograph = (char: string) =>\n  /[\\u3040-\\u30ff\\u3400-\\u4dbf\\u4e00-\\u9fff\\uf900-\\ufaff\\uff66-\\uff9f\\u3131-\\uD79D]/.test(char)\n// http://www.unicode.org/charts/\n// https://zh.wikipedia.org/zh-cn/Unicode%E5%AD%97%E7%AC%A6%E5%88%97%E8%A1%A8\nconst isSpecialCharacters = (char: string) =>\n  /[\\u0021-\\u002F\\u003A-\\u0040\\u005B-\\u0060\\u007B-\\u007E\\u00A1-\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65\\uFFE5]/.test(\n    char,\n  )\n\nconst equalOfCharacterType = (char: string, other: string) => {\n  return (\n    !!char &&\n    !!other &&\n    !isSpace(char) &&\n    !isSpecialCharacters(char) &&\n    !isSpace(other) &&\n    !isSpecialCharacters(other) &&\n    isIdeograph(char) === isIdeograph(other)\n  )\n}\n\ninterface Segment {\n  segment: string\n  index: number\n  input: string\n  isWordLike: boolean\n}\n\ndeclare global {\n  interface Window {\n    Intl: {\n      Segmenter?: new (\n        locale?: string,\n        options?: { granularity: 'word' | 'sentence' | 'line' },\n      ) => {\n        segment: (text: string) => Iterable<Segment>\n      }\n    }\n  }\n}\n\nexport const splitTextOfWord = (text: string, callback?: (segments: Segment[]) => Segment) => {\n  // split word\n  const Segmenter = window.Intl.Segmenter\n  if (Segmenter && isIdeograph(text)) {\n    const segments: Segment[] = Array.from(\n      new Segmenter(undefined, { granularity: 'word' }).segment(text),\n    )\n    if (segments.length > 0) {\n      const { segment, index } = callback ? callback(segments) : segments[segments.length - 1]\n      return { text: segment, offset: index }\n    }\n  }\n  return { text, offset: 0 }\n}\n\nexport const getWordBackward = (text: string, offset: number) => {\n  let currentChar = getCharFromGraphemeBreaker(text, offset, true)\n  let backwardOffset = offset - 1\n  for (; backwardOffset >= 0; ) {\n    const backwardChar = getCharFromGraphemeBreaker(text, backwardOffset, true)\n    if (equalOfCharacterType(currentChar, backwardChar)) {\n      backwardOffset -= backwardChar.length\n    } else break\n  }\n  if (offset - backwardOffset > 1) {\n    const wordText = text.substring(backwardOffset, offset)\n    const { offset: wordOffset } = splitTextOfWord(wordText)\n    backwardOffset += wordOffset\n  }\n  return text.substring(backwardOffset < 0 ? 0 : backwardOffset, offset)\n}\n\nexport const getWordOffsetBackward = (text: string, offset: number) => {\n  return offset - getWordBackward(text, offset).length\n}\n\nexport const getWordForward = (text: string, offset: number) => {\n  let currentChar = getCharFromGraphemeBreaker(text, offset)\n  let forwardOffset = offset + 1\n  for (; forwardOffset < text.length; ) {\n    const forwardChar = getCharFromGraphemeBreaker(text, forwardOffset)\n    if (equalOfCharacterType(currentChar, forwardChar)) {\n      forwardOffset += forwardChar.length\n    } else break\n  }\n  if (forwardOffset - offset > 1) {\n    const newText = text.substring(offset, forwardOffset)\n    const { text: wordText, offset: wordOffset } = splitTextOfWord(newText, segments => segments[0])\n    forwardOffset = offset + wordOffset + wordText.length\n  }\n  return text.substring(offset, forwardOffset > text.length ? text.length : forwardOffset)\n}\n\nexport const getWordOffsetForward = (text: string, offset: number) => {\n  return offset + getWordForward(text, offset).length\n}\n\nexport const getWordRange = (text: string, offset: number) => {\n  if (!text) return [0, 0]\n  offset = Math.min(offset, text.length)\n\n  let previousChar = getCharFromGraphemeBreaker(text, offset, true)\n  let nextChar = getCharFromGraphemeBreaker(text, offset)\n\n  let backwardOffset = offset - 1\n  let forwardOffset = offset + 1\n  if (!nextChar) {\n    return [offset, offset]\n  }\n  if (previousChar && equalOfCharacterType(previousChar, nextChar)) {\n    for (; backwardOffset >= 0; ) {\n      const backwardChar = getCharFromGraphemeBreaker(text, backwardOffset, true)\n      if (equalOfCharacterType(previousChar, backwardChar)) {\n        backwardOffset -= backwardChar.length\n      } else break\n    }\n  } else {\n    backwardOffset = offset\n  }\n\n  for (; forwardOffset < text.length; ) {\n    const forwardChar = getCharFromGraphemeBreaker(text, forwardOffset)\n    if (equalOfCharacterType(nextChar, forwardChar)) {\n      forwardOffset += forwardChar.length\n    } else break\n  }\n  // split word\n  if (forwardOffset - backwardOffset > 1) {\n    const newText = text.substring(backwardOffset, forwardOffset)\n    const { text: wordText, offset: wordOffset } = splitTextOfWord(newText, segments => {\n      for (let i = segments.length - 1; i >= 0; i--) {\n        const segment = segments[i]\n        const wordStart = segment.index + backwardOffset\n        if (offset >= wordStart && offset < wordStart + segment.segment.length) {\n          return segment\n        }\n      }\n      return segments[0]\n    })\n    backwardOffset += wordOffset\n    forwardOffset = wordText.length + backwardOffset\n  }\n  return [backwardOffset, forwardOffset]\n}\n\n/**\n * @zh-CN 获取在Text节点处鼠标点击坐标时的字符索引\n * @param node Text Node\n * @param x\n * @param y\n * @param start\n * @param end\n * @param length\n * @returns\n *\n */\nexport const getTextOffset = (\n  node: Text,\n  x: number,\n  y: number,\n  start: number,\n  end: number,\n  length: number,\n): number => {\n  const range = document.createRange()\n  if (end - start > 1) {\n    const mid = Math.floor((start + end) / 2)\n    try {\n      range.setStart(node, mid)\n      range.setEnd(node, Math.max(Math.min(mid, length), 0))\n    } catch (e) {\n      return start\n    }\n    const rects = range.getClientRects()\n    if (rects.length === 0) {\n      return start\n    }\n    for (const rect of rects) {\n      if (y < rect.top) {\n        return getTextOffset(node, x, y, start, mid, length)\n      } else if (y > rect.bottom) {\n        return getTextOffset(node, x, y, mid, end, length)\n      } else if (x <= rect.left + rect.width) {\n        return getTextOffset(node, x, y, start, mid, length)\n      }\n    }\n    return getTextOffset(node, x, y, mid, end, length)\n  }\n  const [rStart, rEnd] = getCharRange(node.textContent || '', start)\n  try {\n    range.setStart(node, rStart)\n    range.setEnd(node, Math.max(Math.min(rEnd, length), 0))\n  } catch (err) {\n    return rStart\n  }\n  const rects = range.getClientRects()\n  if (rects.length === 0) return rStart\n\n  for (const rect of rects) {\n    if (rect.width === 0) continue\n    if (y < rect.top) {\n      return rStart\n    } else if (y > rect.bottom) {\n      return rEnd\n    } else if (x <= rect.left + rect.width / 2) {\n      return rStart\n    }\n  }\n  return rEnd\n}\n","import {\n  Editor,\n  Node,\n  Range,\n  Element,\n  NodeEntry,\n  Path,\n  DOMElement,\n  DOMRange,\n  isDOMElement,\n} from '@editablejs/models'\nimport { Editable } from '../plugin/editable'\nimport {\n  DATA_EDITABLE_COMPOSITION,\n  DATA_EDITABLE_NODE,\n  DATA_EDITABLE_STRING,\n  DATA_EDITABLE_ZERO_WIDTH,\n} from './constants'\n\ninterface LineRectangle {\n  top: number\n  height: number\n  bottom: number\n  left: number\n  right: number\n}\n\n/**\n * Splits the rectangles into lines based on their positions.\n * @param rects\n */\nconst splitRectsIntoLines = (rects: DOMRect[] | DOMRectList) => {\n  const lines: Map<LineRectangle, DOMRect[]> = new Map()\n  if (rects.length === 0) return lines\n\n  const lineKeys: LineRectangle[] = []\n\n  /**\n   * Finds the line that the rectangle belongs to.\n   * @param rect\n   */\n  const findLineKey = (rect: DOMRect) => {\n    for (const lineKey of lineKeys) {\n      const { right } = lineKey\n      const previousRects = lines.get(lineKey)\n      const lastRect = previousRects\n        ? previousRects\n            .concat()\n            .reverse()\n            .find(p => p.width > 0) ?? previousRects[previousRects.length - 1]\n        : null\n      if (isRectInLine(rect, lineKey) && rect.left <= (lastRect ? lastRect.right : right) + 1) {\n        return lineKey\n      }\n    }\n    return null\n  }\n\n  // Loop through each rectangle and find its line\n  for (let r = 0; r < rects.length; r++) {\n    const rect = rects[r]\n    const key = findLineKey(rect)\n    if (key) {\n      lines.get(key)?.push(rect)\n    } else {\n      const lineRect = {\n        top: rect.top,\n        height: rect.height,\n        bottom: rect.bottom,\n        left: rect.left,\n        right: rect.right,\n      }\n      lines.set(lineRect, [rect])\n      lineKeys.push(lineRect)\n    }\n  }\n\n  // Find the minimum top, maximum bottom, and maximum right for each line\n  for (const [line, rects] of lines) {\n    // If there's only one rectangle in the line, skip\n    if (rects.length === 1) continue\n\n    let minTop = line.top,\n      maxBottom = line.bottom,\n      maxRight = line.right\n\n    // Compare each rectangle\n    for (const rect of rects) {\n      const { top, bottom, right } = rect\n      if (top < minTop) minTop = top\n      if (bottom > maxBottom) maxBottom = bottom\n      if (right > maxRight && rect.width > 0) maxRight = right\n    }\n    line.top = minTop\n    line.bottom = maxBottom\n    line.right = maxRight\n  }\n  return lines\n}\n\n/**\n * Calculates the height of a node based on line height and font size\n * @param el The DOM element to calculate height for\n * @returns The calculated height\n */\nconst calculateElementHeight = (el: DOMElement) => {\n  const { lineHeight, fontSize } = window.getComputedStyle(el)\n\n  // TODO: Handle pt, em, rem units\n\n  let height = 0\n  // Ends with px\n  if (lineHeight.endsWith('px')) {\n    height = parseFloat(lineHeight)\n    return height\n  }\n  // Ends with %\n  else if (lineHeight.endsWith('%')) {\n    height = parseInt(lineHeight, 10) / 100\n  }\n  // Number\n  else if (/^\\d+(\\.\\d+)?$/.test(lineHeight)) {\n    height = parseFloat(lineHeight)\n  } else {\n    return el.getBoundingClientRect().height\n  }\n\n  let size = 0\n  if (fontSize.endsWith('px')) {\n    size = parseInt(fontSize, 10)\n  }\n\n  return height * size\n}\n\n/**\n * Resets the DOMRect of an element to the specified height\n * @param rect The DOMRect to reset\n * @param height The new height for the rect\n * @returns The reset DOMRect\n */\nconst resetElementRect = (rect: DOMRect, height: number) => {\n  const oldHeight = rect.height\n  if (oldHeight >= height) return rect\n  const top = rect.top + (oldHeight - height) / 2\n  return new DOMRect(rect.left, top, rect.width, height)\n}\n\n/**\n * Check if a given DOMRect intersects with a given line defined by its top, bottom, and height values\n * @param {DOMRect} rect - The DOMRect to check\n * @param {Object} line - An object with top, bottom, and height properties representing the line\n * @return {Boolean} - True if the rect intersects with the line, false otherwise\n */\nconst isRectInLine = (rect: DOMRect, line: Record<'top' | 'bottom' | 'height', number>) => {\n  const deltaEdge = rect.height / 3\n  return (\n    // Check if the rect is fully contained within the line\n    (rect.top >= line.top &&\n      (rect.bottom <= line.bottom ||\n        // Check if the top of the rect is in the line and the overflow of the bottom is within 2/3\n        rect.top + deltaEdge < line.bottom ||\n        // Check if the bottom of the rect is within 2/3 from the top of the line and the top of the rect is above the bottom of the line\n        (rect.top <= line.top + line.height / 3 && rect.bottom > line.top))) ||\n    // Check if the rect covers the height of the line and the line is within the top and bottom of the rect\n    (rect.top <= line.top &&\n      (rect.bottom >= line.bottom ||\n        // Check if the top of the rect is above or equal to the top of the line and the bottom of the rect is within 2/3 of the line\n        rect.bottom - deltaEdge > line.top)) ||\n    // Check if the bottom of the rect is within 2/3 from the bottom of the line and the top of the rect is above the bottom of the line\n    (rect.bottom <= line.bottom &&\n      rect.bottom >= line.bottom - line.height / 3 &&\n      rect.top < line.bottom)\n  )\n}\n/**\n * Find the maximum position in the line of the top position in the el node\n * @param editor - The Editor instance\n * @param element - The DOM element\n * @param top - The top position\n * @param bottom - The bottom position\n * @returns - Object containing the line rect information\n */\nconst matchHighest = (editor: Editor, element: DOMElement, top: number, bottom: number) => {\n  const lineRect = {\n    top,\n    height: bottom - top,\n    bottom,\n  }\n\n  /**\n   * Compare the height of the current rect with the line rect\n   * and update the line rect with the highest values\n   * @param rect - The current rect\n   */\n  const compareHeight = (rect: DOMRect) => {\n    if (isRectInLine(rect, lineRect)) {\n      const newTop = lineRect.top < rect.top ? lineRect.top : rect.top\n      const newBottom = lineRect.bottom > rect.bottom ? lineRect.bottom : rect.bottom\n      lineRect.height = newBottom - newTop\n      lineRect.top = newTop\n      lineRect.bottom = newBottom\n    }\n  }\n\n  /**\n   * Recursively find the child nodes of the element and compare their rects\n   * @param element - The DOM element\n   */\n  const match = (element: DOMElement) => {\n    for (const child of element.childNodes) {\n      if (isDOMElement(child)) {\n        const hasNode = child.hasAttribute(DATA_EDITABLE_NODE)\n        const node = hasNode ? Editable.toEditorNode(editor, child) : null\n        if (node) {\n          if (Element.isElement(node)) {\n            if (editor.isVoid(node)) {\n              const rect = resetElementRect(\n                child.getBoundingClientRect(),\n                calculateElementHeight(child),\n              )\n              compareHeight(rect)\n            } else if (editor.isInline(node)) {\n              const height = calculateElementHeight(child)\n              const rects = child.getClientRects()\n              for (let r = 0; r < rects.length; r++) {\n                const rect = resetElementRect(rects[r], height)\n                compareHeight(rect)\n              }\n            } else {\n              match(child)\n            }\n          } else {\n            const nodes = child.querySelectorAll(\n              `[${DATA_EDITABLE_STRING}], [${DATA_EDITABLE_COMPOSITION}], [${DATA_EDITABLE_ZERO_WIDTH}]`,\n            )\n            nodes.forEach(node => {\n              const height = calculateElementHeight(node)\n              const rects = node.getClientRects()\n              for (let r = 0; r < rects.length; r++) {\n                const rect = resetElementRect(rects[r], height)\n                compareHeight(rect)\n              }\n            })\n          }\n        } else {\n          match(child)\n        }\n      }\n    }\n  }\n\n  match(element)\n  return lineRect\n}\n/**\n * Get the line rectangles of a given node in an editor.\n * @param editor The editor instance.\n * @param node The node to get line rectangles of.\n * @param minWidth The minimum width of the line rectangles. Default value is 4.\n * @returns An array of DOMRect objects representing the line rectangles.\n */\nexport const getLineRectsByNode = (editor: Editor, node: Node, minWidth = 4) => {\n  const path = Editable.findPath(editor, node)\n  const block: NodeEntry | undefined =\n    Editor.isBlock(editor, node) && path.length === 1\n      ? [node, path]\n      : Editor.above<Element>(editor, {\n          at: path,\n          match: n => Editor.isBlock(editor, n),\n          mode: 'highest',\n        })\n  if (!block) return []\n  const domEl = Editable.toDOMNode(editor, block[0])\n  const domRect = domEl.getBoundingClientRect()\n  const range = document.createRange()\n  range.selectNodeContents(Editable.toDOMNode(editor, node))\n  const lines = splitRectsIntoLines(range.getClientRects())\n  const lineRects: DOMRect[] = []\n  for (const [line, rects] of lines) {\n    let width = line.right - line.left\n    const lineRect = matchHighest(editor, domEl, line.top, line.bottom)\n    line.top = lineRect.top\n    line.height = lineRect.height\n    line.bottom = lineRect.bottom\n    // 空节点的宽度给个最小值\n    if (width < 1 && domRect.left === rects[0].left) {\n      width = minWidth\n    }\n    lineRects.push(new DOMRect(rects[0].left, line.top, width, line.height))\n  }\n  return lineRects\n}\n\n/**\n * Get DOMRect objects split by line within range\n * @param editor\n * @param range\n * @param minWidth minimum width of empty node, default to 4\n * @returns array of DOMRect objects\n */\nexport const getLineRectsByRange = (editor: Editor, range: Range, minWidth = 4) => {\n  const anchor = Range.start(range)\n  const focus = Range.end(range)\n  // 开始位置的 block节点\n  const anchorEntry = Editor.above<Element>(editor, {\n    at: anchor,\n    match: n => Editor.isBlock(editor, n),\n    mode: 'lowest',\n  })\n  // 结束位置的 block 节点\n  const focusEntry = Editor.above<Element>(editor, {\n    at: focus,\n    match: n => Editor.isBlock(editor, n),\n    mode: 'lowest',\n  })\n  if (!anchorEntry || !focusEntry) return []\n\n  const blockRects: DOMRect[] = []\n  const rectMap: Map<\n    DOMRect,\n    {\n      dom: DOMElement\n      element: Element\n    }\n  > = new Map()\n\n  let [startBlock, startPath] = anchorEntry\n  let [_, endPath] = focusEntry\n  const ranges: DOMRange[] = []\n  let isStart = true\n  let next: NodeEntry<Element> | undefined = anchorEntry\n  while (next) {\n    const [nextBlock, nextPath] = next as NodeEntry<Element>\n    const element = Editable.toDOMNode(editor, nextBlock)\n    const rect = element.getBoundingClientRect()\n    rectMap.set(rect, {\n      dom: element,\n      element: nextBlock,\n    })\n    blockRects.push(rect)\n\n    if (Path.equals(nextPath, endPath)) break\n    if (!isStart) {\n      const range = document.createRange()\n      range.selectNodeContents(element)\n      ranges.push(range)\n    } else {\n      isStart = false\n    }\n    next = Editor.next<Element>(editor, {\n      at: nextPath,\n      match: n => Editor.isBlock(editor, n),\n    })\n  }\n  if (Path.equals(startPath, endPath)) {\n    ranges.unshift(Editable.toDOMRange(editor, range))\n  } else {\n    ranges.unshift(\n      Editable.toDOMRange(editor, {\n        anchor,\n        focus: Editor.end(editor, {\n          path: startPath,\n          offset: startBlock.children.length,\n        }),\n      }),\n    )\n    ranges.push(\n      Editable.toDOMRange(editor, {\n        anchor: Editor.start(editor, {\n          path: endPath,\n          offset: 0,\n        }),\n        focus,\n      }),\n    )\n  }\n\n  // 拆分的行\n  const rects: DOMRect[] = []\n  for (const range of ranges) {\n    rects.push(...range.getClientRects())\n  }\n  const lines = splitRectsIntoLines(rects)\n  const lineRects: DOMRect[] = []\n  let prevLineRect: DOMRect | null = null\n  for (const [line, rects] of lines) {\n    // 找到对应行所在的 element\n    const blockRect = blockRects.find(\n      r =>\n        isRectInLine(r, line) &&\n        (line.left >= r.left || Math.abs(line.left - r.left) < 1) &&\n        (line.right <= r.right || Math.abs(line.right - r.right) < 1),\n    )\n    const block = blockRect ? rectMap.get(blockRect) : null\n\n    let width = line.right - line.left\n    if (block) {\n      const { dom, element } = block\n      const lineRect = matchHighest(editor, dom, line.top, line.bottom)\n      line.top = lineRect.top\n      line.height = lineRect.height\n      // 空节点的宽度给个最小值\n      if (\n        dom &&\n        Editor.isEmpty(editor, element) &&\n        width < 1 &&\n        dom.getBoundingClientRect().left === line.left\n      ) {\n        width = minWidth\n      }\n    }\n    // 去除行与行直接多余覆盖部分\n    if (prevLineRect && prevLineRect.bottom > line.top) {\n      const diffVal = prevLineRect.bottom - line.top\n      line.top += diffVal\n      line.height -= diffVal\n    }\n    const lineRect = new DOMRect(rects[0].left, line.top, width, line.height)\n\n    prevLineRect = lineRect\n    lineRects.push(lineRect)\n  }\n  return lineRects\n}\n","import { Editor } from '@editablejs/models'\nimport create, { StoreApi, UseBoundStore, useStore } from 'zustand'\nimport { Editable } from '../plugin/editable'\nimport { useEditableStatic } from './use-editable'\n\ninterface FocusedStore {\n  isFocused: boolean\n}\n\nconst EDITABLE_TO_FOCUSED_STORE = new WeakMap<Editor, UseBoundStore<StoreApi<FocusedStore>>>()\n\nconst getStore = (editor: Editor) => {\n  let store = EDITABLE_TO_FOCUSED_STORE.get(editor)\n  if (!store) {\n    store = create<FocusedStore>(() => ({\n      isFocused: false,\n    }))\n    EDITABLE_TO_FOCUSED_STORE.set(editor, store)\n    store.subscribe(({ isFocused }) => {\n      if (!Editable.isEditor(editor)) return\n\n      if (isFocused) {\n        editor.onFocus()\n      } else {\n        editor.onBlur()\n      }\n    })\n  }\n\n  return store\n}\n\nexport const useFocused = (): [boolean, (isFocused: boolean) => void] => {\n  const editor = useEditableStatic()\n  const store = getStore(editor)\n  const isFocused = useStore(store, state => state.isFocused)\n\n  return [\n    isFocused,\n    (isFocused: boolean) => {\n      store.setState({ isFocused })\n    },\n  ]\n}\n\nexport const Focused = {\n  is: (editor: Editor) => {\n    const store = getStore(editor)\n    return store.getState().isFocused\n  },\n}\n","export const composeEventHandlers = <E>(\n  originalEventHandler?: (event: E) => void,\n  ourEventHandler?: (event: E) => void,\n  { checkForDefaultPrevented = true } = {},\n) => {\n  return function handleEvent(event: E) {\n    originalEventHandler?.(event)\n\n    if (checkForDefaultPrevented === false || !(event as unknown as Event).defaultPrevented) {\n      return ourEventHandler?.(event)\n    }\n  }\n}\n\nexport const isTouchEvent = (event: any): event is TouchEvent => {\n  return typeof window.TouchEvent !== 'undefined' && event instanceof TouchEvent\n}\n\nexport const isTouch = (event: any): event is Touch => {\n  return typeof window.Touch !== 'undefined' && event instanceof Touch\n}\n\nexport const isMouseEvent = (event: any): event is MouseEvent => {\n  return event instanceof MouseEvent\n}\n\nexport const getNativeEvent = (event: any) => {\n  const { nativeEvent } = event\n  event = nativeEvent ?? event\n  if (isTouchEvent(event)) {\n    return event.touches[0] || event.changedTouches[0]\n  }\n  return event\n}\n","import { Editor } from '@editablejs/models'\nimport create, { StoreApi, UseBoundStore, useStore } from 'zustand'\nimport { useEditableStatic } from './use-editable'\n\ninterface ReadOnlyStore {\n  isReadOnly: boolean\n}\n\nconst EDITABLE_TO_FOCUSED_STORE = new WeakMap<Editor, UseBoundStore<StoreApi<ReadOnlyStore>>>()\n\nconst getStore = (editor: Editor) => {\n  let store = EDITABLE_TO_FOCUSED_STORE.get(editor)\n  if (!store) {\n    store = create<ReadOnlyStore>(() => ({\n      isReadOnly: false,\n    }))\n    EDITABLE_TO_FOCUSED_STORE.set(editor, store)\n  }\n\n  return store\n}\n\nexport const useReadOnly = (): [boolean, (isReadOnly: boolean) => void] => {\n  const editor = useEditableStatic()\n  const store = getStore(editor)\n  const isReadOnly = useStore(store, state => state.isReadOnly)\n\n  return [\n    isReadOnly,\n    (isReadOnly: boolean) => {\n      store.setState({ isReadOnly })\n    },\n  ]\n}\n\nexport const ReadOnly = {\n  is: (editor: Editor) => {\n    const store = getStore(editor)\n    return store.getState().isReadOnly\n  },\n}\n","import * as React from 'react'\nimport { CAN_USE_DOM } from '../utils/environment'\n\n/**\n * Prevent warning on SSR by falling back to useEffect when DOM isn't available\n */\n\nexport const useIsomorphicLayoutEffect = CAN_USE_DOM ? React.useLayoutEffect : React.useEffect\n","import * as React from 'react'\nimport { Text, Path, Range, Element } from '@editablejs/models'\nimport { useStore } from 'zustand'\nimport { Decorate, ElementDecorate, getDecorateStore, TextDecorate } from '../plugin/decorate'\nimport { useEditableStatic } from './use-editable'\n\nexport const useDecorateStore = () => {\n  const editor = useEditableStatic()\n  return React.useMemo(() => {\n    return getDecorateStore(editor)\n  }, [editor])\n}\n\nexport const useTextDecorations = (text: Text, path: Path) => {\n  const store = useDecorateStore()\n  const decorations = useStore(store, state => state.decorations)\n  return React.useMemo(() => {\n    return decorations.reduce<{ decorate: TextDecorate; ranges: Range[] }[]>((acc, decorate) => {\n      if (!Decorate.isTextDecorate(decorate)) return acc\n      const ranges = decorate.match(text, path)\n      if (ranges.length > 0) {\n        acc.push({ decorate, ranges })\n      }\n      return acc\n    }, [])\n  }, [decorations, text, path])\n}\n\nexport const useElementDecorations = (element: Element, path: Path) => {\n  const store = useDecorateStore()\n  const decorations = useStore(store, state => state.decorations)\n  return React.useMemo(() => {\n    return decorations.reduce<ElementDecorate[]>((acc, decorate) => {\n      if (Decorate.isTextDecorate(decorate)) return acc\n      if (decorate.match(element, path)) {\n        acc.push(decorate)\n      }\n      return acc\n    }, [])\n  }, [decorations, element, path])\n}\n","// Import necessary dependencies and models from @editablejs\nimport * as React from 'react'\nimport { Editor, Range, Node, Path, Text, Element } from '@editablejs/models'\n\n// Import the create and StoreApi from zustand\nimport create, { StoreApi, UseBoundStore } from 'zustand'\n\n// Define interface for properties passed to the render function of a text decoration\nexport interface DecorateRenderProps<T = Node> {\n  node: T\n  path: Path\n  children: React.ReactElement\n}\n\n// Define BaseDecorate interface with a key property that is optional\nexport interface BaseDecorate {\n  key?: string\n}\n\n// Define TextDecorate interface with match and renderText functions\nexport interface TextDecorate extends BaseDecorate {\n  match: (node: Text, path: Path) => Range[]\n  renderText: (props: DecorateRenderProps<Text>) => React.ReactElement\n}\n\n// Define ElementDecorate interface with match and renderElement functions\nexport interface ElementDecorate extends BaseDecorate {\n  match: (node: Element, path: Path) => boolean\n  renderElement: (props: DecorateRenderProps<Element>) => React.ReactElement\n}\n\n// Define a type for decorations which can either be a TextDecorate or an ElementDecorate\nexport type Decorate = TextDecorate | ElementDecorate\n\n// Define DecorateStore interface with decorations property\nexport interface DecorateStore {\n  decorations: Decorate[]\n}\n\n// Define a WeakMap to store Editor instances and their associated decoration stores\nconst EDITOR_TO_DECORATE_STORE = new WeakMap<Editor, UseBoundStore<StoreApi<DecorateStore>>>()\n\n// Function to retrieve the decoration store for a given Editor instance\nexport const getDecorateStore = (editor: Editor) => {\n  let store = EDITOR_TO_DECORATE_STORE.get(editor)\n  if (!store) {\n    store = create<DecorateStore>(() => ({\n      decorations: [],\n    }))\n    EDITOR_TO_DECORATE_STORE.set(editor, store)\n  }\n  return store\n}\n\n// Helper function to determine if a decoration is specified by its key or by its reference\nconst predicate = (decorate: Decorate | string) => {\n  const isKey = typeof decorate === 'string'\n  return (d: Decorate) => {\n    return isKey ? d.key === decorate : d === decorate\n  }\n}\n\n// Object to handle adding, removing, and checking the presence of decorations in a given Editor instance\nexport const Decorate = {\n  // Check if a given value is a TextDecorate\n  isTextDecorate: (value: any): value is TextDecorate => {\n    return value && typeof value.match === 'function' && typeof value.renderText === 'function'\n  },\n\n  // Add a decoration to the decorations array of a given Editor instance\n  create: (editor: Editor, decorate: Decorate) => {\n    const store = getDecorateStore(editor)\n    store.setState(state => ({\n      decorations: [...state.decorations, decorate],\n    }))\n  },\n\n  // Remove\n  remove: (editor: Editor, decorate: Decorate | string) => {\n    const store = getDecorateStore(editor)\n    store.setState(state => ({\n      decorations: state.decorations.filter(d => !predicate(decorate)(d)),\n    }))\n  },\n\n  has: (editor: Editor, decorate: Decorate | string) => {\n    const store = getDecorateStore(editor)\n    return store.getState().decorations.some(predicate(decorate))\n  },\n}\n","import * as React from 'react'\nimport { Editor, Node } from '@editablejs/models'\nimport { useStore } from 'zustand'\nimport { Placeholder } from '../plugin/placeholder'\nimport { useEditableStatic } from './use-editable'\nimport { useIsomorphicLayoutEffect } from './use-isomorphic-layout-effect'\nimport { Editable } from '../plugin/editable'\n\nexport const usePlaceholderStore = () => {\n  const editor = useEditableStatic()\n  return React.useMemo(() => {\n    return Placeholder.getStore(editor)\n  }, [editor])\n}\n\nexport const usePlaceholders = () => {\n  const store = usePlaceholderStore()\n  const placeholders = useStore(store, state => state.placeholders)\n  return placeholders\n}\n\nexport const usePlaceholder = (node: Node) => {\n  const editor = useEditableStatic()\n  const store = usePlaceholderStore()\n  const actives = useStore(store, state => state.actives)\n  useIsomorphicLayoutEffect(() => {\n    if (Editor.isEmpty(editor, node)) {\n      Placeholder.update(editor, [node, Editable.findPath(editor, node)])\n      return () => {\n        store.setState(({ actives }) => {\n          return {\n            actives: actives.filter(d => d.entry[0] !== node),\n          }\n        })\n      }\n    }\n  }, [store, node, editor])\n\n  return React.useMemo(() => {\n    return actives.find(d => d.entry[0] === node)?.render\n  }, [actives, node])\n}\n","import * as React from 'react'\nimport { Editor, Node, NodeEntry, Range } from '@editablejs/models'\nimport create, { UseBoundStore, StoreApi } from 'zustand'\nimport { Editable } from './editable'\n\nexport interface RenderPlaceholderProps {\n  node: Node\n}\nexport type PlaceholderRender = (props: RenderPlaceholderProps) => React.ReactNode\n\nexport type PlaceholderSubscribe = (entry: NodeEntry) => PlaceholderRender | void\n\nconst PLACEHOLDER_IS_ALONE = new WeakMap<PlaceholderSubscribe, boolean>()\nexport interface ActivePlaceholder {\n  entry: NodeEntry\n  alone: boolean\n  render: PlaceholderRender\n  placeholder: PlaceholderSubscribe\n}\n\nexport interface PlaceholderStore {\n  placeholders: PlaceholderSubscribe[]\n  actives: ActivePlaceholder[]\n}\n\nconst EDITOR_TO_PLACEHOLDER_STORE = new WeakMap<\n  Editable,\n  UseBoundStore<StoreApi<PlaceholderStore>>\n>()\n\nconst getPlaceholderStore = (editor: Editable) => {\n  let store = EDITOR_TO_PLACEHOLDER_STORE.get(editor)\n  if (!store) {\n    store = create<PlaceholderStore>(() => ({\n      placeholders: [],\n      actives: [],\n    }))\n    EDITOR_TO_PLACEHOLDER_STORE.set(editor, store)\n  }\n  return store\n}\n\nexport const Placeholder = {\n  getStore: getPlaceholderStore,\n\n  isAlone: (fn: PlaceholderSubscribe) => {\n    return PLACEHOLDER_IS_ALONE.get(fn) ?? false\n  },\n\n  subscribe: (editor: Editable, fn: PlaceholderSubscribe, alone = false) => {\n    const store = getPlaceholderStore(editor)\n    PLACEHOLDER_IS_ALONE.set(fn, alone)\n\n    store.setState(state => ({\n      placeholders: [...state.placeholders.filter(d => d !== fn), fn],\n    }))\n\n    return () => {\n      store.setState(state => ({\n        placeholders: state.placeholders.filter(d => d !== fn),\n      }))\n      PLACEHOLDER_IS_ALONE.delete(fn)\n    }\n  },\n\n  update: (editor: Editable, entry: NodeEntry) => {\n    const store = getPlaceholderStore(editor)\n    const state = store.getState()\n    let render: PlaceholderRender | null = null\n    let placeholder: PlaceholderSubscribe | null = null\n    const aloneActive = state.actives.find(d => d.alone && d.entry[0] === entry[0])\n    if (aloneActive) {\n      const r = aloneActive.placeholder(entry)\n      if (r) {\n        render = r\n        placeholder = aloneActive.placeholder\n      }\n    }\n    // 没有以编辑器为placeholder的情况下，才会去找其他的placeholder\n    else {\n      const hasEditorPlaceholder = state.actives.some(d => d.entry[0] === editor)\n      const placeholders = state.placeholders.sort(a => (Placeholder.isAlone(a) ? 1 : 0))\n      for (let i = placeholders.length - 1; i >= 0; i--) {\n        placeholder = placeholders[i]\n        if (!Placeholder.isAlone(placeholder) && hasEditorPlaceholder) continue\n        const r = placeholder(entry)\n        if (r) {\n          render = r\n          break\n        }\n      }\n    }\n\n    const actives = state.actives.filter(d => {\n      if (!d.alone || (d.entry[0] === entry[0] && render)) return false\n      return Editor.isEmpty(editor, d.entry[0])\n    })\n\n    if (render && placeholder) {\n      actives.push({\n        entry,\n        alone: Placeholder.isAlone(placeholder),\n        render,\n        placeholder,\n      })\n    }\n    store.setState({ actives })\n    return render\n  },\n\n  refresh: (editor: Editable) => {\n    const isReadOnly = Editable.isReadOnly(editor)\n    const store = getPlaceholderStore(editor)\n    if (isReadOnly) {\n      store.setState({ actives: [] })\n    } else if (Editor.isEmpty(editor, editor)) {\n      Placeholder.update(editor, [editor, []])\n    } else if (editor.selection && Range.isCollapsed(editor.selection)) {\n      const nodes = Editor.nodes(editor, {\n        at: editor.selection,\n      })\n      for (const entry of nodes) {\n        if (Editor.isEmpty(editor, entry[0])) {\n          return Placeholder.update(editor, entry)\n        }\n      }\n      store.setState(({ actives }) => {\n        return {\n          actives: actives.filter(d => {\n            if (!d.alone) return false\n            return Editor.isEmpty(editor, d.entry[0])\n          }),\n        }\n      })\n    } else {\n      store.setState(({ actives }) => ({\n        actives: actives.filter(d => d.alone),\n      }))\n    }\n  },\n}\n","import * as React from 'react'\n\nexport const NodeSelectedContext = React.createContext<boolean>(false)\n\n/**\n * Get the current `selected` state of an element.\n */\nexport const useNodeSelected = (): boolean => {\n  return React.useContext(NodeSelectedContext)\n}\n","import * as React from 'react'\n\nexport const NodeFocusedContext = React.createContext<boolean>(false)\n\n/**\n * Get the current `focused` state of an element.\n */\nexport const useNodeFocused = (): boolean => {\n  return React.useContext(NodeFocusedContext)\n}\n","import * as React from 'react'\nimport { Grid } from '@editablejs/models'\n\nexport const GridContext = React.createContext<Grid | null>(null)\n\nexport const useGrid = (): Grid | null => {\n  return React.useContext(GridContext)\n}\n","import * as React from 'react'\n\nimport { cancellablePromise, useCancellablePromises } from './use-cancellable-promises'\n\nconst useMultipleClick = (options: {\n  onClick?: (event: React.MouseEvent) => void\n  onMultipleClick: (event: React.MouseEvent, count: number) => boolean | void\n}) => {\n  const { onClick, onMultipleClick } = options\n  const api = useCancellablePromises()\n  const pointRef = React.useRef<{ x: number; y: number }>()\n  const countRef = React.useRef(0)\n\n  const isSamePoint = (event: React.MouseEvent | MouseEvent | Touch) => {\n    const point = pointRef.current\n    return point\n      ? Math.abs(event.clientY - point.y) < 10 && Math.abs(event.clientX - point.x) < 10\n      : false\n  }\n\n  const clear = () => {\n    api.clearPendingPromises()\n    pointRef.current = undefined\n  }\n\n  const handleMultipleClick = (event: React.MouseEvent) => {\n    if (event.button === 2) return\n    const point = pointRef.current\n    if (point) {\n      if (isSamePoint(event)) {\n        api.clearPendingPromises()\n        countRef.current += 1\n        if (onMultipleClick(event, countRef.current) === false) {\n          clear()\n          return\n        }\n      } else {\n        clear()\n      }\n    } else {\n      countRef.current = 1\n      pointRef.current = {\n        x: event.clientX,\n        y: event.clientY,\n      }\n    }\n    if (countRef.current === 1 && onMultipleClick(event, 1) === false) {\n      clear()\n    } else {\n      const waitForClick = cancellablePromise(api.delay(500))\n      api.appendPendingPromise(waitForClick)\n      return waitForClick.promise\n        .then(() => {\n          api.removePendingPromise(waitForClick)\n          if (onClick) onClick(event)\n          pointRef.current = undefined\n        })\n        .catch(errorInfo => {\n          api.removePendingPromise(waitForClick)\n          if (!errorInfo.isCanceled) {\n            throw errorInfo.error\n          }\n        })\n    }\n  }\n\n  return { handleMultipleClick, isSamePoint }\n}\n\nexport { useMultipleClick }\n","import * as React from 'react'\n\nexport interface CellablePromise<T> {\n  promise: Promise<T>\n  cancel: () => void\n}\n\nconst cancellablePromise = <T>(promise: Promise<T>) => {\n  let isCanceled = false\n\n  const wrappedPromise = new Promise((resolve, reject) => {\n    promise.then(\n      value => (isCanceled ? reject({ isCanceled, value }) : resolve(value)),\n      error => reject({ isCanceled, error }),\n    )\n  })\n\n  return {\n    promise: wrappedPromise,\n    cancel: () => (isCanceled = true),\n  }\n}\n\nconst noop = () => {}\n\nconst delay = (n: number) => new Promise(resolve => setTimeout(resolve, n))\n\nconst useCancellablePromises = <T>() => {\n  const pendingPromises = React.useRef<CellablePromise<T>[]>([])\n\n  const appendPendingPromise = (promise: CellablePromise<T>) =>\n    (pendingPromises.current = [...pendingPromises.current, promise])\n\n  const removePendingPromise = (promise: CellablePromise<T>) =>\n    (pendingPromises.current = pendingPromises.current.filter(p => p !== promise))\n\n  const clearPendingPromises = () => pendingPromises.current.map(p => p.cancel())\n\n  const api = {\n    pendingPromises,\n    appendPendingPromise,\n    removePendingPromise,\n    clearPendingPromises,\n    delay,\n    noop,\n  }\n\n  return api\n}\n\nexport { useCancellablePromises, cancellablePromise }\n","import * as React from 'react'\nimport ReactDOM from 'react-dom'\nimport { useIsomorphicLayoutEffect } from '../hooks/use-isomorphic-layout-effect'\n\nexport interface ShadowRect {\n  left: number\n  top: number\n  width: number\n  height: number\n  color?: string\n  style?: React.CSSProperties\n}\n\ntype ShadowBlockProps = {\n  rect: ShadowRect\n} & React.HTMLAttributes<HTMLDivElement>\n\nexport const ShadowBlockDefault: React.FC<ShadowBlockProps & React.RefAttributes<HTMLDivElement>> =\n  React.forwardRef<HTMLDivElement, ShadowBlockProps>(({ children, rect, style, ...props }, ref) => (\n    <div\n      ref={ref}\n      style={{\n        position: 'absolute',\n        top: rect.top,\n        left: rect.left,\n        width: rect.width,\n        height: rect.height,\n        // 数值为单数的情况下，两组重合位置会有阴影\n        // transform: `translateX(${rect.left || 0}px) translateY(${rect.top || 0}px)`,\n        opacity: 1,\n        backgroundColor: `${rect.color || 'transparent'}`,\n        zIndex: 1,\n        ...style,\n      }}\n      {...props}\n    >\n      {children}\n    </div>\n  ))\n\nShadowBlockDefault.displayName = 'ShadowBlock'\n\nexport const ShadowBlock = React.memo(ShadowBlockDefault, (prev, next) => {\n  return (\n    prev.rect.left === next.rect.left &&\n    prev.rect.top === next.rect.top &&\n    prev.rect.width === next.rect.width &&\n    prev.rect.height === next.rect.height &&\n    prev.rect.color === next.rect.color &&\n    prev.children === next.children\n  )\n})\n\ninterface ShadowContainerProps {\n  children?: React.ReactNode\n}\n\nconst ShadowContainer: React.FC<ShadowContainerProps & React.RefAttributes<ShadowRoot>> =\n  React.forwardRef<ShadowRoot, ShadowContainerProps>(({ children }, ref) => {\n    const [root, setRoot] = React.useState<ShadowRoot>()\n    const containerRef = React.useRef<HTMLDivElement>(null)\n\n    useIsomorphicLayoutEffect(() => {\n      if (!containerRef.current || containerRef.current.shadowRoot) return\n      const root = containerRef.current.attachShadow({ mode: 'open' })\n      setRoot(root)\n    }, [])\n\n    React.useImperativeHandle(ref, () => root!, [root])\n\n    return (\n      <div ref={containerRef} style={{ position: 'absolute', zIndex: 2, top: 0, left: 0 }}>\n        {root &&\n          ReactDOM.createPortal(<div style={{ pointerEvents: 'none' }}>{children}</div>, root)}\n      </div>\n    )\n  })\n\nShadowContainer.displayName = 'Shadow'\n\nexport default ShadowContainer\n","import * as React from 'react'\nimport { Range } from '@editablejs/models'\nimport { useEditableStatic } from '../hooks/use-editable'\nimport { useFocused } from '../hooks/use-focused'\nimport { useIsomorphicLayoutEffect } from '../hooks/use-isomorphic-layout-effect'\nimport { IS_MOUSEDOWN } from '../utils/weak-maps'\nimport {\n  useSelectionDrawingEnabled,\n  useSelectionDrawingRects,\n  useSelectionDrawingSelection,\n  useSelectionDrawingStyle,\n} from '../hooks/use-selection-drawing'\nimport { isTouchDevice } from '../utils/environment'\nimport { useReadOnly } from '../hooks/use-read-only'\nimport { ShadowBlock } from './shadow'\n\ninterface CaretProps {\n  timeout?: number | false\n}\n\nconst CaretComponent: React.FC<CaretProps> = React.memo(({ timeout = 530 }) => {\n  const editor = useEditableStatic()\n\n  const [focused] = useFocused()\n\n  const timer = React.useRef<number>()\n\n  const ref = React.useRef<HTMLDivElement>(null)\n\n  const [readOnly] = useReadOnly()\n\n  const enabled = useSelectionDrawingEnabled()\n  const selection = useSelectionDrawingSelection()\n  const rects = useSelectionDrawingRects()\n  const style = useSelectionDrawingStyle()\n\n  const caretWidth = isTouchDevice ? style.touchWidth : style.caretWidth\n  const caretColor = isTouchDevice ? style.touchColor : style.caretColor\n\n  const rect = React.useMemo(() => {\n    if (!selection || rects.length === 0 || !focused || !Range.isCollapsed(selection)) return null\n    return rects[0].toJSON()\n  }, [focused, rects, selection])\n\n  const clearActive = React.useCallback(() => {\n    clearTimeout(timer.current)\n  }, [])\n\n  const setOpacity = (opacity?: number) => {\n    const elRef = ref.current\n    if (elRef) {\n      elRef.style.opacity =\n        opacity !== undefined ? String(opacity) : elRef.style.opacity === '1' ? '0' : '1'\n    }\n  }\n\n  const active = React.useCallback(\n    (opacity?: number) => {\n      clearActive()\n      if (!rect || timeout === false) return\n      if (IS_MOUSEDOWN.get(editor)) {\n        setOpacity(1)\n      } else {\n        setOpacity(opacity)\n      }\n      timer.current = setTimeout(() => {\n        active()\n      }, timeout)\n    },\n    [clearActive, editor, rect, timeout],\n  )\n\n  useIsomorphicLayoutEffect(() => {\n    if (readOnly) {\n      clearActive()\n    } else active(1)\n    return () => clearActive()\n  }, [editor, readOnly, active, clearActive])\n\n  if (!enabled || readOnly) return null\n\n  return (\n    <ShadowBlock\n      rect={\n        rect\n          ? Object.assign({}, rect, { width: caretWidth, color: caretColor })\n          : { width: 0, height: 0, top: 0, left: 0 }\n      }\n      ref={ref}\n      style={{ willChange: 'opacity, transform', opacity: rect ? 1 : 0 }}\n    />\n  )\n})\nCaretComponent.displayName = 'CaretComponent'\nexport { CaretComponent }\n","import * as React from 'react'\nimport { useStore } from 'zustand'\nimport { SelectionDrawing } from '../plugin/selection-drawing'\nimport { EDITOR_TO_SELECTION_RECTS } from '../utils/weak-maps'\nimport { useEditableStatic } from './use-editable'\nimport { useIsomorphicLayoutEffect } from './use-isomorphic-layout-effect'\n\nexport const useSelectionDrawingStore = () => {\n  const editor = useEditableStatic()\n  return React.useMemo(() => {\n    return SelectionDrawing.getStore(editor)\n  }, [editor])\n}\n\nexport const useSelectionDrawingStyle = () => {\n  const store = useSelectionDrawingStore()\n  return useStore(store, state => state.style)\n}\n\nexport const useSelectionDrawingSelection = () => {\n  const store = useSelectionDrawingStore()\n  return useStore(store, state => state.selection)\n}\n\nexport const useSelectionDrawingRects = () => {\n  const editor = useEditableStatic()\n  const selection = useSelectionDrawingSelection()\n  const [rects, setRects] = React.useState<DOMRect[]>([])\n  useIsomorphicLayoutEffect(() => {\n    const rects = selection ? SelectionDrawing.toRects(editor, selection) : []\n    EDITOR_TO_SELECTION_RECTS.set(editor, rects)\n    setRects(rects)\n  }, [editor, selection])\n\n  return rects\n}\n\nexport const useSelectionDrawingEnabled = () => {\n  const store = useSelectionDrawingStore()\n  return useStore(store, state => state.enabled)\n}\n","import create, { StoreApi, UseBoundStore } from 'zustand'\nimport { Selection, Range, Editor } from '@editablejs/models'\nimport { getLineRectsByRange } from '../utils/selection'\nimport { Editable } from './editable'\n\nexport interface SelectionDrawingStyle {\n  /**\n   * 拖蓝聚焦颜色\n   */\n  focusColor?: string\n  /**\n   * 拖蓝失焦颜色\n   */\n  blurColor?: string\n  /**\n   * 光标颜色\n   */\n  caretColor?: string\n  /**\n   * 光标宽度\n   */\n  caretWidth?: number\n  /**\n   * 拖拽光标的颜色\n   */\n  dragColor?: string\n  /**\n   * 触摸光标的颜色\n   */\n  touchColor?: string\n  /**\n   * 触摸光标的宽度\n   */\n  touchWidth?: number\n}\n\nexport interface SelectionDrawingStore {\n  style: SelectionDrawingStyle\n  selection: Selection | null\n  enabled: boolean\n}\n\nconst EDITOR_TO_SELECTION_DRAWING_STORE = new WeakMap<\n  Editor,\n  UseBoundStore<StoreApi<SelectionDrawingStore>>\n>()\n\nconst getStore = (editor: Editor) => {\n  let store = EDITOR_TO_SELECTION_DRAWING_STORE.get(editor)\n  if (!store) {\n    store = create<SelectionDrawingStore>(() => ({\n      style: {\n        focusColor: 'rgba(0,127,255,0.3)',\n\n        blurColor: 'rgba(136, 136, 136, 0.3)',\n\n        caretColor: '#000',\n\n        caretWidth: 1,\n\n        dragColor: 'rgb(37, 99, 235)',\n\n        touchWidth: 2,\n\n        touchColor: 'rgb(37, 99, 235)',\n      },\n      selection: null,\n      rects: null,\n      enabled: true,\n    }))\n    EDITOR_TO_SELECTION_DRAWING_STORE.set(editor, store)\n  }\n  return store\n}\n\nexport const SelectionDrawing = {\n  getStore,\n\n  setStyle: (editor: Editor, style: Partial<SelectionDrawingStyle>) => {\n    const store = getStore(editor)\n    store.setState(state => ({ ...state, style }))\n  },\n\n  setSelection: (editor: Editor, selection: Selection | null) => {\n    const store = getStore(editor)\n    store.setState(state => ({ ...state, selection }))\n  },\n\n  setEnabled: (editor: Editor, enabled: boolean) => {\n    const store = getStore(editor)\n    store.setState(state => ({ ...state, enabled }))\n  },\n\n  toRects(editor: Editor, range: Range, relative = true) {\n    let rects: DOMRect[] = []\n    if (Range.isCollapsed(range)) {\n      const domRange = Editable.toDOMRange(editor, range)\n      const clientRects = domRange.getClientRects()\n      if (clientRects.length > 1) {\n        rects = [clientRects[clientRects.length - 1]]\n      } else {\n        rects = [domRange.getBoundingClientRect()]\n      }\n    } else {\n      rects = getLineRectsByRange(editor, range)\n    }\n\n    return relative\n      ? rects.map(r => {\n          const [x, y] = Editable.toRelativePosition(editor, r.left, r.top)\n          r.x = x\n          r.y = y\n          return r\n        })\n      : rects\n  },\n}\n","import * as React from 'react'\nimport { Range } from '@editablejs/models'\nimport { useFocused } from '../hooks/use-focused'\nimport {\n  useSelectionDrawingSelection,\n  useSelectionDrawingRects,\n  useSelectionDrawingEnabled,\n  useSelectionDrawingStyle,\n} from '../hooks/use-selection-drawing'\nimport { ShadowBlock } from './shadow'\nimport { isTouchDevice } from '../utils/environment'\n\ninterface SelectionProps {}\n\nconst SelectionComponent: React.FC<SelectionProps> = () => {\n  const selection = useSelectionDrawingSelection()\n  const rects = useSelectionDrawingRects()\n  const enabled = useSelectionDrawingEnabled()\n  const style = useSelectionDrawingStyle()\n  const [focused] = useFocused()\n  if (!enabled || !selection || Range.isCollapsed(selection)) return null\n\n  return (\n    <>\n      {rects.map((rect, index) => {\n        return (\n          <ShadowBlock\n            key={`sel-${index}`}\n            rect={Object.assign({}, rect.toJSON(), {\n              color: isTouchDevice || focused ? style.focusColor : style.blurColor,\n            })}\n          />\n        )\n      })}\n    </>\n  )\n}\n\nexport { SelectionComponent }\n","import { Range } from '@editablejs/models'\nimport * as React from 'react'\nimport { Editable } from '../plugin/editable'\nimport {\n  EDITOR_TO_INPUT,\n  IS_COMPOSING,\n  IS_MOUSEDOWN,\n  IS_PASTE_TEXT,\n  IS_TOUCHING,\n} from '../utils/weak-maps'\nimport { useFocused } from '../hooks/use-focused'\nimport { ShadowBlock, ShadowRect } from './shadow'\nimport { useIsomorphicLayoutEffect } from '../hooks/use-isomorphic-layout-effect'\nimport { useEditableStatic } from '../hooks/use-editable'\nimport {\n  useSelectionDrawingSelection,\n  useSelectionDrawingRects,\n} from '../hooks/use-selection-drawing'\nimport { ReadOnly, useReadOnly } from '../hooks/use-read-only'\nimport { composeEventHandlers } from '../utils/event'\nimport { useEffect } from 'react'\n\ninterface InputProps {\n  autoFocus?: boolean\n}\n\nconst InputComponent: React.FC<InputProps> = ({ autoFocus }) => {\n  const editor = useEditableStatic()\n  const inputRef = React.useRef<HTMLTextAreaElement>(null)\n  const [focused, setFocused] = useFocused()\n  const [readOnly] = useReadOnly()\n\n  const [rect, setRect] = React.useState<ShadowRect | null>(null)\n\n  useIsomorphicLayoutEffect(() => {\n    if (inputRef.current) EDITOR_TO_INPUT.set(editor, inputRef.current)\n    return () => {\n      EDITOR_TO_INPUT.delete(editor)\n    }\n  }, [editor])\n\n  useEffect(() => {\n    if (autoFocus) {\n      editor.focus()\n      Editable.scrollIntoView(editor)\n    }\n  }, [editor, autoFocus])\n\n  const handleKeydown = (event: React.KeyboardEvent) => {\n    const { nativeEvent } = event\n    if (Editable.isComposing(editor) && nativeEvent.isComposing === false) {\n      IS_COMPOSING.set(editor, false)\n    }\n\n    if (event.defaultPrevented || Editable.isComposing(editor)) {\n      return\n    }\n    editor.onKeydown(nativeEvent)\n  }\n\n  const handleKeyup = (event: React.KeyboardEvent) => {\n    const { nativeEvent } = event\n    editor.onKeyup(nativeEvent)\n  }\n\n  const handleBlur = () => {\n    if (!IS_MOUSEDOWN.get(editor) && !IS_TOUCHING.get(editor)) setFocused(false)\n  }\n\n  const handleFocus = () => {\n    setFocused(true)\n  }\n\n  const handleBeforeInput = (event: React.FormEvent<HTMLTextAreaElement>) => {\n    const textarea = event.target\n    if (!(textarea instanceof HTMLTextAreaElement)) return\n    const { value } = textarea\n    editor.onBeforeInput(value)\n  }\n\n  const handleInput = (event: React.FormEvent<HTMLTextAreaElement>) => {\n    const textarea = event.target\n    if (!(textarea instanceof HTMLTextAreaElement)) return\n    const value = textarea.value\n    if (!IS_COMPOSING.get(editor)) {\n      textarea.value = ''\n    }\n    editor.onInput(value)\n  }\n\n  const handleCompositionStart = (ev: React.CompositionEvent) => {\n    const { data } = ev.nativeEvent\n    editor.onCompositionStart(data)\n  }\n\n  const handleCompositionEnd = (event: React.CompositionEvent) => {\n    const textarea = event.target\n    if (!(textarea instanceof HTMLTextAreaElement)) return\n    const value = textarea.value\n    textarea.value = ''\n    editor.onCompositionEnd(value)\n  }\n\n  const handlePaste = (event: React.ClipboardEvent) => {\n    composeEventHandlers(\n      (event: React.ClipboardEvent) => {\n        if (ReadOnly.is(editor)) {\n          event.preventDefault()\n        }\n      },\n      event => {\n        const { nativeEvent } = event\n        const isPasteText = IS_PASTE_TEXT.get(editor)\n        event.preventDefault()\n        const e = new ClipboardEvent(isPasteText ? 'pasteText' : 'paste', nativeEvent)\n        editor.onPaste(e)\n      },\n    )(event)\n  }\n\n  const selection = useSelectionDrawingSelection()\n  const rects = useSelectionDrawingRects()\n\n  useIsomorphicLayoutEffect(() => {\n    if (!selection || !focused || rects.length === 0) return setRect(null)\n    if (Range.isCollapsed(selection)) {\n      setRect(rects[0].toJSON())\n    } else {\n      const rect = rects[rects.length - 1].toJSON()\n      rect.left = rect.left + rect.width\n      return setRect(rect)\n    }\n  }, [focused, rects, selection])\n\n  return (\n    <ShadowBlock\n      rect={Object.assign({}, rect, { color: 'transparent', width: 1 })}\n      style={{ opacity: 0, outline: 'none', caretColor: 'transparent', overflow: 'hidden' }}\n    >\n      <textarea\n        ref={inputRef}\n        rows={1}\n        style={{\n          fontSize: 'inherit',\n          lineHeight: 1,\n          padding: 0,\n          border: 'none',\n          whiteSpace: 'nowrap',\n          width: '1em',\n          overflow: 'auto',\n          resize: 'vertical',\n        }}\n        readOnly={readOnly}\n        onKeyDown={handleKeydown}\n        onKeyUp={handleKeyup}\n        onBeforeInput={handleBeforeInput}\n        onInput={handleInput}\n        onCompositionStart={handleCompositionStart}\n        onCompositionEnd={handleCompositionEnd}\n        onBlur={handleBlur}\n        onFocus={handleFocus}\n        onPaste={handlePaste}\n      />\n    </ShadowBlock>\n  )\n}\n\nexport { InputComponent }\n","import * as React from 'react'\nimport { useEditableStatic } from './use-editable'\nimport { Drag, DragStore } from '../plugin/drag'\nimport { useStore } from 'zustand'\n\nexport const useDragStore = () => {\n  const editor = useEditableStatic()\n  const store = React.useMemo(() => {\n    return Drag.getStore(editor)\n  }, [editor])\n  return store\n}\n\n/**\n * 是否拖拽中\n * @returns\n */\nexport const useDragging = () => {\n  const store = useDragStore()\n\n  const drag = useStore(store, state => state.drag !== null)\n\n  return React.useMemo(() => drag, [drag])\n}\n\nexport const useDragType = () => {\n  const store = useDragStore()\n\n  const type = useStore(store, state => state.drag?.type ?? null)\n\n  return React.useMemo(() => type, [type])\n}\n\n/**\n * 拖拽到的目标\n * @returns\n */\nexport const useDragTo = () => {\n  const store = useDragStore()\n  const drag = useStore(store, state => state.drag)\n\n  return React.useMemo(() => drag?.to ?? null, [drag])\n}\n\n/**\n * 当前拖拽的鼠标位置\n * @returns\n */\nexport const useDragPosition = () => {\n  const store = useDragStore()\n  const drag = useStore(store, state => state.drag)\n\n  return React.useMemo(() => drag?.position ?? null, [drag])\n}\n\n/**\n * 当前拖拽的数据\n * @returns\n */\nexport const useDragData = () => {\n  const store = useDragStore()\n  const drag = useStore(store, state => state.drag)\n\n  return React.useMemo(() => drag?.data ?? 0, [drag])\n}\n\nexport const useDragMethods = () => {\n  const editor = useEditableStatic()\n\n  const setDrag = React.useCallback(\n    (drag: Partial<DragStore['drag']>) => {\n      Drag.setDrag(editor, drag)\n    },\n    [editor],\n  )\n\n  const getDrag = React.useCallback(() => {\n    return Drag.getDrag(editor)\n  }, [editor])\n\n  return React.useMemo(() => ({ setDrag, getDrag }), [setDrag, getDrag])\n}\n","import create, { StoreApi, UseBoundStore } from 'zustand'\nimport { Editor, Range, Element, Path, Selection } from '@editablejs/models'\nimport { Editable } from './editable'\n\nexport interface DragStore {\n  drag: {\n    type: 'block' | 'text'\n    /**\n     * 拖拽的开始位置\n     */\n    from: Range | Path\n    /**\n     * 拖拽到目标位置\n     */\n    to: Selection | Path\n    /**\n     * 拖拽的数据\n     */\n    data: DataTransfer\n    /**\n     * 当前鼠标位置\n     */\n    position: Record<'x' | 'y', number>\n  } | null\n}\n\nconst EDITOR_TO_DRAG_STORE = new WeakMap<Editor, UseBoundStore<StoreApi<DragStore>>>()\n\nconst getDragStore = (editor: Editor) => {\n  let store = EDITOR_TO_DRAG_STORE.get(editor)\n  if (!store) {\n    store = create<DragStore>(() => ({\n      drag: null,\n    }))\n    EDITOR_TO_DRAG_STORE.set(editor, store)\n  }\n  return store\n}\n\n/**\n * 拖拽相关状态操作\n */\nexport const Drag = {\n  getStore: getDragStore,\n\n  getDrag: (editor: Editor) => {\n    const store = getDragStore(editor)\n    const { drag } = store.getState()\n    return drag\n  },\n\n  setDrag: (editor: Editor, drag: Partial<DragStore['drag']>) => {\n    const store = getDragStore(editor)\n    store.setState(state => {\n      return {\n        drag: drag === null ? null : Object.assign({}, state.drag, drag),\n      }\n    })\n  },\n\n  clear: (editor: Editor) => {\n    const store = getDragStore(editor)\n    store.setState({ drag: null })\n  },\n\n  toBlockPath: (editor: Editor) => {\n    const drag = Drag.getDrag(editor)\n    if (!drag || drag.type !== 'block') return\n    const { to, position } = drag\n    if (!to) return\n    const entry = Editor.above(editor, {\n      at: Path.isPath(to) ? to : to.focus,\n      match: n => Element.isElement(n),\n      mode: 'lowest',\n    })\n    if (!entry) return\n    const element = Editable.toDOMNode(editor, entry[0])\n    const rect = element.getBoundingClientRect()\n    const { y, height } = rect\n    const { y: pY } = position\n    if (pY > y + height / 2) {\n      return Path.next(entry[1])\n    } else {\n      return entry[1]\n    }\n  },\n}\n","import * as React from 'react'\nimport { Editor, Element, Path, GridCell } from '@editablejs/models'\nimport { useDragPosition, useDragTo, useDragType } from '../hooks/use-drag'\nimport { useEditableStatic } from '../hooks/use-editable'\nimport { useSelectionDrawingStyle } from '../hooks/use-selection-drawing'\nimport { Editable } from '../plugin/editable'\nimport { SelectionDrawing } from '../plugin/selection-drawing'\nimport { ShadowBlock } from './shadow'\n\nexport const DragCaretComponent = React.memo(() => {\n  const editor = useEditableStatic()\n  const dragTo = useDragTo()\n  const dragType = useDragType()\n  const dragPosition = useDragPosition()\n  const rects = React.useMemo(() => {\n    if (!dragTo || !dragPosition) return null\n    if (dragType === 'block') {\n      const entry = Editor.above(editor, {\n        at: dragTo,\n        match: n => Element.isElement(n),\n        mode: 'lowest',\n      })\n      if (!entry) return null\n      const element = Editable.toDOMNode(editor, entry[0])\n      const rect = element.getBoundingClientRect()\n      let { x, y } = rect\n      const { height, width } = rect\n      const { y: pY } = dragPosition\n      const space = 1\n      // bottom\n      if (pY > y + height / 2) {\n        y += height + space\n      }\n      // find previous sibling\n      else {\n        const previous = Editor.previous(editor, {\n          at: entry[1],\n          match: (n, p) => {\n            if (!Element.isElement(n)) return false\n            const gridCell = GridCell.find(editor, entry[1])\n            if (!gridCell) return true\n            const matchCell = GridCell.find(editor, p)\n            if (!matchCell) return false\n\n            return Path.equals(gridCell[1], matchCell[1])\n          },\n          mode: 'lowest',\n        })\n        if (previous) {\n          const previousElement = Editable.toDOMNode(editor, previous[0])\n          const previousRect = previousElement.getBoundingClientRect()\n          y = previousRect.y + previousRect.height + space\n        } else {\n          y -= space\n        }\n      }\n      const [rx, ry] = Editable.toRelativePosition(editor, x, y)\n      return [new DOMRect(rx, ry, width, 2)]\n    }\n\n    return SelectionDrawing.toRects(editor, Editor.range(editor, dragTo))\n  }, [dragPosition, dragTo, dragType, editor])\n\n  const { dragColor, caretWidth } = useSelectionDrawingStyle()\n  if (!rects || rects.length === 0) return null\n  if (dragType === 'block') {\n    return (\n      <ShadowBlock\n        rect={Object.assign({}, rects[0].toJSON(), {\n          color: dragColor,\n        })}\n      />\n    )\n  }\n  return (\n    <ShadowBlock\n      rect={Object.assign({}, rects[0].toJSON(), {\n        width: caretWidth,\n        color: dragColor,\n      })}\n    />\n  )\n})\n\nDragCaretComponent.displayName = 'DragCaretComponent'\n","import React from 'react'\nimport { useSlotComponents } from '../hooks/use-slot'\n\nexport const Slots = React.memo(() => {\n  const slots = useSlotComponents()\n  return (\n    <>\n      {slots.map(({ component: Component, props }, index) => (\n        <Component key={index} {...props} />\n      ))}\n    </>\n  )\n})\nSlots.displayName = 'Slots'\n","import React from 'react'\nimport { useStore } from 'zustand'\nimport shallow from 'zustand/shallow'\nimport { Slot } from '../plugin/solt'\nimport { useEditableStatic } from './use-editable'\n\nexport const useSlotStore = () => {\n  const editor = useEditableStatic()\n  return React.useMemo(() => Slot.getStore(editor), [editor])\n}\n\nexport const useSlotComponents = () => {\n  const store = useSlotStore()\n  return useStore(store, state => state.components, shallow)\n}\n\nexport const useSlotActive = (component: React.FC) => {\n  const components = useSlotComponents()\n  const editor = useEditableStatic()\n  const slot = components.find(c => c.component === component)\n  return React.useMemo(() => {\n    return [\n      slot?.props.active ?? false,\n      (active: boolean) => {\n        Slot.update(editor, { active }, c => c === component)\n      },\n    ] as const\n  }, [editor, slot, component])\n}\n","import merge from 'lodash.merge'\nimport * as React from 'react'\nimport create, { StoreApi, UseBoundStore } from 'zustand'\nimport { Editor } from '@editablejs/models'\n\nexport interface SlotComponentProps {\n  active?: boolean\n}\n\nexport interface SlotState<T extends SlotComponentProps> {\n  component: React.FC\n  props: T\n}\n\nexport interface SlotStore<T extends SlotComponentProps> {\n  components: SlotState<T>[]\n}\n\nconst EDITOR_TO_SLOTS_STORE = new WeakMap<\n  Editor,\n  UseBoundStore<StoreApi<SlotStore<SlotComponentProps>>>\n>()\n\nconst getStore = (editor: Editor) => {\n  let store = EDITOR_TO_SLOTS_STORE.get(editor)\n  if (!store) {\n    store = create<SlotStore<SlotComponentProps>>(() => ({\n      components: [],\n    }))\n    EDITOR_TO_SLOTS_STORE.set(editor, store)\n  }\n  return store\n}\n\nexport const Slot = {\n  getStore,\n\n  mount<T extends SlotComponentProps>(editor: Editor, component: React.FC<T>, props: T = {} as T) {\n    const store = getStore(editor)\n    store.setState(state => {\n      const { components } = state\n      if (components.some(c => c.component === component)) return state\n      return {\n        components: [...components, { component, props } as SlotState<T>],\n      }\n    })\n  },\n\n  unmount(editor: Editor, component: React.FC) {\n    const store = getStore(editor)\n    store.setState(state => {\n      const { components } = state\n      if (!components.some(c => c.component === component)) return state\n      return {\n        components: components.filter(c => c.component !== component),\n      }\n    })\n  },\n\n  update: <T extends SlotComponentProps>(\n    editor: Editor,\n    props: Partial<T>,\n    predicate: (value: React.FC<T>, index: number) => boolean = () => true,\n  ) => {\n    const store = getStore(editor)\n    store.setState(state => {\n      const { components } = state\n      return {\n        components: components.map((c, index) => {\n          if (!predicate(c.component, index)) return c\n          return { ...c, props: merge(c.props, props) }\n        }),\n      }\n    })\n  },\n}\n","import * as React from 'react'\nimport { Range } from '@editablejs/models'\nimport { useEditableStatic } from '../hooks/use-editable'\nimport { useFocused } from '../hooks/use-focused'\nimport {\n  useSelectionDrawingSelection,\n  useSelectionDrawingRects,\n  useSelectionDrawingEnabled,\n  useSelectionDrawingStyle,\n} from '../hooks/use-selection-drawing'\nimport { isTouchDevice } from '../utils/environment'\nimport { IS_TOUCHING, IS_TOUCHMOVING, IS_TOUCH_HOLD } from '../utils/weak-maps'\nimport { ShadowBlock } from './shadow'\n\ninterface TouchPointProps {\n  onAnchorTouchStart?: (e: React.TouchEvent) => void\n  onFocusTouchStart?: (e: React.TouchEvent) => void\n}\n\nconst TouchPointComponent: React.FC<TouchPointProps> = React.memo(\n  ({ onAnchorTouchStart, onFocusTouchStart }) => {\n    const selection = useSelectionDrawingSelection()\n    const rects = useSelectionDrawingRects()\n    const enabled = useSelectionDrawingEnabled()\n    const style = useSelectionDrawingStyle()\n    const editor = useEditableStatic()\n\n    if (\n      rects.length === 0 ||\n      !isTouchDevice ||\n      !enabled ||\n      !selection ||\n      IS_TOUCHING.get(editor) ||\n      (!IS_TOUCHMOVING.get(editor) && Range.isCollapsed(selection))\n    )\n      return null\n    const anchor = rects[0]\n    const focus = rects[rects.length - 1]\n\n    const baseStyle: React.CSSProperties = {\n      position: 'absolute',\n      width: 12,\n      height: 12,\n      borderRadius: '100%',\n      overscrollBehavior: 'none',\n      background: style.dragColor,\n    }\n\n    return (\n      <>\n        <ShadowBlock\n          rect={Object.assign({}, anchor.toJSON(), {\n            color: style.dragColor,\n            width: 2,\n            left: anchor.left - 1,\n          })}\n          style={{\n            zIndex: 2,\n          }}\n        >\n          <div\n            onTouchStart={onAnchorTouchStart}\n            style={{\n              ...baseStyle,\n              top: -10,\n              left: -5,\n            }}\n          />\n        </ShadowBlock>\n        <ShadowBlock\n          rect={Object.assign({}, focus.toJSON(), {\n            color: style.dragColor,\n            width: 2,\n            left: focus.right - 1,\n          })}\n          style={{\n            zIndex: 2,\n          }}\n        >\n          <div\n            onTouchStart={onFocusTouchStart}\n            style={{\n              ...baseStyle,\n              bottom: -10,\n              right: -5,\n            }}\n          />\n        </ShadowBlock>\n      </>\n    )\n  },\n)\nTouchPointComponent.displayName = 'TouchPointComponent'\nexport { TouchPointComponent }\n","import * as React from 'react'\nimport { Descendant, Node, Editor, Scrubber } from '@editablejs/models'\nimport create, { StoreApi, UseBoundStore } from 'zustand'\nimport { Editable } from '../plugin/editable'\nimport { EditableStore, EditableStoreContext } from '../hooks/use-editable'\nimport { useIsomorphicLayoutEffect } from '../hooks/use-isomorphic-layout-effect'\n\nconst EDITABLE_TO_STORE = new WeakMap<Editable, UseBoundStore<StoreApi<EditableStore>>>()\n\nexport const EditableProvider = (props: {\n  editor: Editable\n  value?: Descendant[]\n  children: React.ReactNode\n  onChange?: (value: Descendant[]) => void\n}) => {\n  const {\n    editor,\n    children,\n    value = [{ type: 'paragraph', children: [{ text: '' }] }],\n    onChange,\n    ...rest\n  } = props\n\n  const store = React.useMemo(() => {\n    const store = EDITABLE_TO_STORE.get(editor)\n    if (store) {\n      return store\n    }\n    if (!Node.isNodeList(value)) {\n      throw new Error(\n        `[Editable] value is invalid! Expected a list of elements` +\n          `but got: ${Scrubber.stringify(value)}`,\n      )\n    }\n    if (!Editor.isEditor(editor)) {\n      throw new Error(`[Editable] editor is invalid! you passed:` + `${Scrubber.stringify(editor)}`)\n    }\n    editor.children = value\n    Object.assign(editor, rest)\n    const newStore = create<EditableStore>(() => ({\n      editor: [editor],\n    }))\n    EDITABLE_TO_STORE.set(editor, newStore)\n    editor.normalizeNode([editor, []])\n    return newStore\n  }, [editor, value, rest])\n\n  useIsomorphicLayoutEffect(() => {\n    const handleChange = () => {\n      if (onChange) {\n        onChange(editor.children)\n      }\n      store.setState({\n        editor: [editor],\n      })\n    }\n    editor.on('change', handleChange)\n    return () => {\n      editor.off('change', handleChange)\n    }\n  }, [editor, onChange])\n\n  return (\n    <EditableStoreContext.Provider\n      value={{\n        store,\n        editor,\n      }}\n    >\n      {children}\n    </EditableStoreContext.Provider>\n  )\n}\n","import * as React from 'react'\nimport { Path, Grid, GridSelection } from '@editablejs/models'\nimport { Editable } from '../plugin/editable'\nimport { useEditableStatic } from './use-editable'\nimport { useGrid } from './use-grid'\nimport { useIsomorphicLayoutEffect } from './use-isomorphic-layout-effect'\nimport { useNodeFocused } from './use-node-focused'\n\nconst useGridSelection = () => {\n  const editor = useEditableStatic()\n  const grid = useGrid()\n  // selection\n  const [selection, setSelection] = React.useState<GridSelection | null>(null)\n  const nodeFocused = useNodeFocused()\n\n  useIsomorphicLayoutEffect(() => {\n    if (grid && nodeFocused) {\n      const selection = Grid.getSelection(editor, [grid, Editable.findPath(editor, grid)])\n      if (selection) {\n        setSelection(prev => {\n          if (\n            !prev ||\n            !Path.equals(prev.start, selection.start) ||\n            !Path.equals(prev.end, selection.end)\n          ) {\n            const path = Editable.findPath(editor, grid)\n            const startPath = path.concat(selection.start)\n            const endPath = path.concat(selection.end)\n            const edgeSelection = Grid.edges(editor, [grid, path], selection)\n            const { start: tableStart, end: tableEnd } = Grid.span(\n              editor,\n              [grid, path],\n              edgeSelection,\n            )\n            const selStart = path.concat(tableStart)\n            const selEnd = path.concat(tableEnd)\n            // 有合并的单元格时选择区域会变大，所以需要重新select\n            if (!Path.equals(startPath, selStart) || !Path.equals(endPath, selEnd)) {\n              Grid.select(editor, [grid, path], edgeSelection)\n              return prev\n            }\n            return selection\n          }\n          return prev\n        })\n        return\n      }\n    }\n    setSelection(null)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [editor, editor.selection, nodeFocused])\n\n  return selection\n}\n\nexport { useGridSelection }\n","import * as React from 'react'\nimport { GridCell, Grid } from '@editablejs/models'\nimport { Editable } from '../plugin/editable'\nimport { useEditableStatic } from './use-editable'\nimport { useGrid } from './use-grid'\nimport { useGridSelection } from './use-grid-selection'\nimport { useIsomorphicLayoutEffect } from './use-isomorphic-layout-effect'\n\nconst useGridSelectionRect = () => {\n  const editor = useEditableStatic()\n\n  const grid = useGrid()\n\n  const selection = useGridSelection()\n\n  const [rect, setRect] = React.useState<DOMRect | null>(null)\n\n  useIsomorphicLayoutEffect(() => {\n    if (!selection || !grid) return setRect(null)\n    const { start, end } = GridCell.edges(selection)\n    if (GridCell.equal(start, end)) return setRect(null)\n    const path = Editable.findPath(editor, grid)\n    const startCell = Grid.getCell(editor, path, start)\n    if (!startCell) return setRect(null)\n    const endCell = Grid.getCell(editor, path, end)\n    if (!endCell) return setRect(null)\n    const startEl = Editable.toDOMNode(editor, startCell[0])\n    const endEl = Editable.toDOMNode(editor, endCell[0])\n    const tableEl = Editable.toDOMNode(editor, grid)\n    const tableRect = tableEl.getBoundingClientRect()\n    const startRect = startEl.getBoundingClientRect()\n    const endRect = endEl.getBoundingClientRect()\n    const width =\n      endRect.left < startRect.left\n        ? startRect.right - endRect.left\n        : endRect.right - startRect.left\n    const height = Math.max(endRect.bottom - startRect.top, startRect.height)\n    const top = startRect.top - tableRect.top\n    const left = Math.min(startRect.left - tableRect.left, endRect.left - tableRect.left)\n    setRect(new DOMRect(left, top, width, height))\n  }, [editor, selection, grid])\n\n  return rect\n}\n\nexport { useGridSelectionRect }\n","import * as React from 'react'\nimport { GridSelected, Grid } from '@editablejs/models'\nimport { Editable } from '../plugin/editable'\nimport { useEditableStatic } from './use-editable'\nimport { useGrid } from './use-grid'\nimport { useGridSelection } from './use-grid-selection'\n\nconst defaultSelected = {\n  rows: [],\n  cols: [],\n  rowFull: false,\n  colFull: false,\n  allFull: false,\n  cells: [],\n  count: 0,\n}\n\nconst useGridSelected = () => {\n  const editor = useEditableStatic()\n\n  const grid = useGrid()\n\n  const selection = useGridSelection()\n\n  const selected: GridSelected = React.useMemo(() => {\n    if (!grid) return defaultSelected\n    const sel = Grid.getSelected(editor, Editable.findPath(editor, grid), selection ?? undefined)\n    return sel ?? defaultSelected\n  }, [editor, selection, grid])\n\n  return selected\n}\n\nexport { useGridSelected }\n","import ReactDOM from 'react-dom'\nimport {\n  Editor,\n  Node,\n  Path,\n  Operation,\n  Transforms,\n  Range,\n  Point,\n  List,\n  Key,\n} from '@editablejs/models'\nimport { Editable, RenderElementProps, RenderLeafProps } from './editable'\nimport {\n  EDITOR_TO_KEY_TO_ELEMENT,\n  NODE_TO_KEY,\n  IS_SHIFT_PRESSED,\n  EDITOR_TO_INPUT,\n  EDITOR_TO_SHADOW,\n} from '../utils/weak-maps'\nimport { findCurrentLineRange } from '../utils/lines'\nimport { EventEmitter } from './event'\nimport { Placeholder } from './placeholder'\nimport { Focused } from '../hooks/use-focused'\nimport { canForceTakeFocus } from '../utils/dom'\nimport { withInput } from './with-input'\nimport { withKeydown } from './with-keydown'\nimport { withNormalizeNode } from './with-normalize-node'\nimport { withDataTransfer } from './with-data-transfer'\nimport { getWordRange } from '../utils/text'\nimport { ReadOnly } from '../hooks/use-read-only'\n\n/**\n * `withEditable` adds React and DOM specific behaviors to the editor.\n *\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\n * this plugin.\n *\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\n */\nexport const withEditable = <T extends Editor>(editor: T) => {\n  const e = editor as T & Editable\n\n  withInput(e)\n\n  withKeydown(e)\n\n  withNormalizeNode(e)\n\n  withDataTransfer(e)\n\n  const { apply, onChange, deleteBackward, deleteForward } = e\n\n  // The WeakMap which maps a key to a specific HTMLElement must be scoped to the editor instance to\n  // avoid collisions between editors in the DOM that share the same value.\n  EDITOR_TO_KEY_TO_ELEMENT.set(e, new WeakMap())\n\n  e.deleteForward = unit => {\n    const { selection } = editor\n\n    if (selection && Range.isCollapsed(selection)) {\n      const [cell] = Editor.nodes(editor, {\n        match: n => e.isGridCell(n),\n      })\n\n      if (cell) {\n        const [, cellPath] = cell\n        const end = Editor.end(editor, cellPath)\n        if (Point.equals(selection.anchor, end)) {\n          return\n        }\n      }\n    }\n    deleteForward(unit)\n  }\n\n  e.deleteBackward = unit => {\n    const { selection } = editor\n\n    if (selection && Range.isCollapsed(selection)) {\n      const [cell] = Editor.nodes(editor, {\n        match: n => e.isGridCell(n),\n      })\n\n      if (cell) {\n        const [, cellPath] = cell\n        const start = Editor.start(editor, cellPath)\n\n        if (Point.equals(selection.anchor, start)) {\n          return\n        }\n      }\n      const list = List.above(e)\n      if (list && Editor.isStart(e, selection.focus, list[1])) {\n        List.unwrapList(e)\n        return\n      }\n    }\n    if (unit !== 'line') {\n      return deleteBackward(unit)\n    }\n\n    if (selection && Range.isCollapsed(selection)) {\n      const parentBlockEntry = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at: selection,\n      })\n\n      if (parentBlockEntry) {\n        const [, parentBlockPath] = parentBlockEntry\n        const parentElementRange = Editor.range(editor, parentBlockPath, selection.anchor)\n\n        const currentLineRange = findCurrentLineRange(e, parentElementRange)\n\n        if (!Range.isCollapsed(currentLineRange)) {\n          Transforms.delete(editor, { at: currentLineRange })\n        }\n      }\n    }\n  }\n\n  // This attempts to reset the NODE_TO_KEY entry to the correct value\n  // as apply() changes the object reference and hence invalidates the NODE_TO_KEY entry\n  e.apply = (op: Operation) => {\n    const matches: [Path, Key][] = []\n\n    switch (op.type) {\n      case 'insert_text':\n      case 'remove_text':\n      case 'set_node':\n      case 'split_node': {\n        matches.push(...getMatches(e, op.path))\n        break\n      }\n\n      case 'set_selection': {\n        break\n      }\n\n      case 'insert_node':\n      case 'remove_node': {\n        matches.push(...getMatches(e, Path.parent(op.path)))\n        break\n      }\n\n      case 'merge_node': {\n        const prevPath = Path.previous(op.path)\n        matches.push(...getMatches(e, prevPath))\n        break\n      }\n\n      case 'move_node': {\n        const commonPath = Path.common(Path.parent(op.path), Path.parent(op.newPath))\n        matches.push(...getMatches(e, commonPath))\n        break\n      }\n    }\n\n    apply(op)\n\n    for (const [path, key] of matches) {\n      const [node] = Editor.node(e, path)\n      NODE_TO_KEY.set(node, key)\n    }\n    if (!Editable.isFocused(e) && canForceTakeFocus()) {\n      e.focus()\n    }\n  }\n\n  e.on = (type, handler, prepend) => {\n    EventEmitter.on(e, type, handler, prepend)\n  }\n\n  e.off = (type, handler) => {\n    EventEmitter.off(e, type, handler)\n  }\n\n  e.once = (type, handler, prepend) => {\n    EventEmitter.on(e, type, handler, prepend)\n  }\n\n  e.emit = (type, ...args) => {\n    EventEmitter.emit(e, type, ...args)\n  }\n\n  let prevSelection: Range | null = null\n  let prevAnchorNode: Node | null = null\n  let prevFocusNode: Node | null = null\n\n  e.onChange = () => {\n    if (\n      ((!prevSelection || !e.selection) && prevSelection !== e.selection) ||\n      (prevSelection &&\n        e.selection &&\n        (!Range.equals(prevSelection, e.selection) ||\n          prevAnchorNode !== Node.get(e, e.selection.anchor.path) ||\n          prevFocusNode !== Node.get(e, e.selection.focus.path)))\n    ) {\n      e.onSelectionChange()\n      prevSelection = e.selection ? Object.assign({}, e.selection) : null\n      prevAnchorNode = e.selection ? Node.get(e, e.selection.anchor.path) : null\n      prevFocusNode = e.selection ? Node.get(e, e.selection.focus.path) : null\n    }\n    Placeholder.refresh(e)\n    onChange()\n    e.emit('change')\n  }\n\n  e.blur = (): void => {\n    const shadow = EDITOR_TO_SHADOW.get(editor)\n    const textarea = EDITOR_TO_INPUT.get(editor)\n    if (textarea && shadow && shadow.activeElement !== textarea) {\n      textarea.blur()\n    }\n  }\n  /**\n   * Focus the editor.\n   */\n  e.focus = (start): void => {\n    if (!editor.selection) {\n      const path = Editable.findPath(e, e)\n      const point = start ? Editor.start(e, path) : Editor.end(e, path)\n      Transforms.select(e, point)\n    } else if (start === true) {\n      const path = Editable.findPath(e, e)\n      Transforms.select(e, Editor.start(e, path))\n    } else if (start === false) {\n      const path = Editable.findPath(e, e)\n      Transforms.select(e, Editor.end(e, path))\n    }\n\n    const shadow = EDITOR_TO_SHADOW.get(editor)\n    const textarea = EDITOR_TO_INPUT.get(editor)\n    if (textarea && shadow && shadow.activeElement !== textarea) {\n      textarea.focus({ preventScroll: true })\n    }\n  }\n\n  e.selectWord = (options = {}) => {\n    const { at, edge = 'focus' } = options\n    if (at) {\n      Transforms.select(e, at)\n    }\n    const { selection } = e\n    if (!selection) return\n    const point = ['focus', 'end'].includes(edge) ? Range.end(selection) : Range.start(selection)\n    const { text, offset } = Editable.findTextOffsetOnLine(e, point)\n    if (text) {\n      const { path } = point\n      const [startOffset, endOffset] = getWordRange(text, offset)\n      Transforms.select(e, {\n        anchor: Editable.findPointOnLine(e, path, startOffset, true),\n        focus: Editable.findPointOnLine(e, path, endOffset),\n      })\n      e.onSelectEnd()\n    }\n  }\n\n  e.selectLine = (options = {}) => {\n    const { at, edge = 'focus' } = options\n    if (at) {\n      Transforms.select(e, at)\n    }\n    const { selection } = e\n    if (!selection) return\n    const point = ['focus', 'end'].includes(edge) ? Range.end(selection) : Range.start(selection)\n    const { path } = point\n    const node = Node.get(e, path)\n    let linePath = path\n    if (!Editor.isBlock(e, node)) {\n      const block = Editor.above(e, {\n        match: n => Editor.isBlock(e, n),\n        at: path,\n      })\n\n      linePath = block?.[1] ?? path.slice(0, 1)\n    }\n\n    const range = Editor.range(e, linePath)\n    Transforms.select(e, range)\n    e.onSelectEnd()\n  }\n\n  e.onKeyup = (event: KeyboardEvent) => {\n    if (event.key.toLowerCase() === 'shift') {\n      IS_SHIFT_PRESSED.set(editor, false)\n    }\n    e.emit('keyup', event)\n  }\n\n  e.onFocus = () => {\n    e.focus()\n    Placeholder.refresh(e)\n    e.emit('focus')\n  }\n\n  e.onBlur = () => {\n    Placeholder.refresh(e)\n    e.emit('blur')\n  }\n\n  e.onSelectStart = () => {\n    e.emit('selectstart')\n  }\n\n  e.onSelecting = () => {\n    e.emit('selecting')\n  }\n\n  e.onSelectEnd = () => {\n    e.emit('selectend')\n  }\n\n  e.onSelectionChange = () => {\n    e.emit('selectionchange')\n  }\n\n  e.onTouchHold = event => {\n    e.emit('touchhold', event)\n  }\n\n  e.onTouchTrack = () => {\n    e.emit('touchtrack')\n  }\n\n  e.onContextMenu = event => {\n    e.emit('contextmenu', event)\n  }\n\n  e.onDestory = () => {\n    e.emit('destory')\n  }\n\n  e.renderElementAttributes = ({ attributes }) => {\n    return attributes\n  }\n\n  e.renderLeafAttributes = ({ attributes }) => {\n    return attributes\n  }\n\n  e.renderElement = (props: RenderElementProps) => {\n    const { attributes, children, element } = props\n    const Tag = e.isInline(element) ? 'span' : 'div'\n    return <Tag {...attributes}>{children}</Tag>\n  }\n\n  e.renderLeaf = (props: RenderLeafProps) => {\n    const { attributes, children } = props\n    return <span {...attributes}>{children}</span>\n  }\n\n  e.renderPlaceholder = ({ attributes, children }) => {\n    return (\n      <span\n        style={{\n          pointerEvents: 'none',\n          userSelect: 'none',\n          width: '100%',\n        }}\n      >\n        <span\n          style={{\n            position: 'absolute',\n            opacity: '0.333',\n            width: 'fit-content',\n            whiteSpace: 'nowrap',\n            textIndent: 'initial',\n            textOverflow: 'ellipsis',\n            maxWidth: '100%',\n            overflow: 'hidden',\n          }}\n          {...attributes}\n        >\n          {children}\n        </span>\n      </span>\n    )\n  }\n\n  const { insertBreak } = e\n\n  e.insertBreak = () => {\n    const { selection } = editor\n\n    if (!Editable.isEditor(editor) || !selection || Range.isExpanded(selection)) {\n      insertBreak()\n      return\n    }\n    const entrie = List.above(editor)\n    if (!entrie) {\n      insertBreak()\n      return\n    }\n    List.splitList(editor)\n  }\n\n  e.insertFile = (_, range) => {\n    if (range) {\n      Transforms.select(e, range)\n    }\n  }\n\n  return e\n}\n\nconst getMatches = (e: Editable, path: Path) => {\n  const matches: [Path, Key][] = []\n  for (const [n, p] of Editor.levels(e, { at: path })) {\n    const key = Editable.findKey(e, n)\n    matches.push([p, key])\n  }\n  return matches\n}\n","/**\n * Utilities for single-line deletion\n */\n\nimport { Range, Editor } from '@editablejs/models'\nimport { Editable } from '../plugin/editable'\n\nconst doRectsIntersect = (rect: DOMRect, compareRect: DOMRect) => {\n  const middle = (compareRect.top + compareRect.bottom) / 2\n\n  return rect.top <= middle && rect.bottom >= middle\n}\n\nconst areRangesSameLine = (editor: Editable, range1: Range, range2: Range) => {\n  const rect1 = Editable.toDOMRange(editor, range1).getBoundingClientRect()\n  const rect2 = Editable.toDOMRange(editor, range2).getBoundingClientRect()\n\n  return doRectsIntersect(rect1, rect2) && doRectsIntersect(rect2, rect1)\n}\n\n/**\n * A helper utility that returns the end portion of a `Range`\n * which is located on a single line.\n *\n * @param {Editor} editor The editor object to compare against\n * @param {Range} parentRange The parent range to compare against\n * @returns {Range} A valid portion of the parentRange which is one a single line\n */\nexport const findCurrentLineRange = (editor: Editable, parentRange: Range): Range => {\n  const parentRangeBoundary = Editor.range(editor, Range.end(parentRange))\n  const positions = Array.from(Editor.positions(editor, { at: parentRange }))\n\n  let left = 0\n  let right = positions.length\n  let middle = Math.floor(right / 2)\n\n  if (areRangesSameLine(editor, Editor.range(editor, positions[left]), parentRangeBoundary)) {\n    return Editor.range(editor, positions[left], parentRangeBoundary)\n  }\n\n  if (positions.length < 2) {\n    return Editor.range(editor, positions[positions.length - 1], parentRangeBoundary)\n  }\n\n  while (middle !== positions.length && middle !== left) {\n    if (areRangesSameLine(editor, Editor.range(editor, positions[middle]), parentRangeBoundary)) {\n      right = middle\n    } else {\n      left = middle\n    }\n\n    middle = Math.floor((left + right) / 2)\n  }\n\n  return Editor.range(editor, positions[right], parentRangeBoundary)\n}\n","export type Listener = (...args: any[]) => void\n\nexport class Emitter {\n  static listenerCount(emitter: Emitter, type: string | number): number {\n    return emitter.listenerCount(type)\n  }\n\n  static defaultMaxListeners: number = 10\n\n  events: Record<string | number, Listener | Listener[]> = {}\n\n  maxListeners: number | undefined = undefined\n\n  eventsCount = 0\n\n  listenerCount(type: string | number): number {\n    const evlistener = this.events[type]\n\n    if (typeof evlistener === 'function') {\n      return 1\n    } else if (evlistener !== undefined) {\n      return evlistener.length\n    }\n\n    return 0\n  }\n\n  eventNames(): Array<string | number> {\n    return Object.keys(this.events)\n  }\n\n  setMaxListeners(count: number): this {\n    this.maxListeners = count\n    return this\n  }\n\n  getMaxListeners(): number {\n    return this.maxListeners ?? Emitter.defaultMaxListeners\n  }\n\n  emit(type: string | number, ...args: any[]): boolean {\n    const handler = this.events[type]\n\n    if (handler === undefined) return false\n\n    if (typeof handler === 'function') {\n      handler(...args)\n    } else {\n      const len = handler.length\n      for (let i = 0; i < len; ++i) handler[i](...args)\n    }\n\n    return true\n  }\n\n  on(type: string | number, listener: Listener, prepend = false): this {\n    let existing = this.events[type]\n    if (existing === undefined) {\n      // Optimize the case of one listener. Don't need the extra array object.\n      this.events[type] = listener\n      ++this.eventsCount\n    } else {\n      if (typeof existing === 'function') {\n        // Adding the second element, need to change to array.\n        existing = this.events[type] = prepend ? [listener, existing] : [existing, listener]\n        // If we've already got an array, just append.\n      } else if (prepend) {\n        existing.unshift(listener)\n      } else {\n        existing.push(listener)\n      }\n\n      // Check for listener leak\n      const maxCount = this.getMaxListeners()\n      if (maxCount > 0 && existing.length > maxCount) {\n        // No error code for this since it is a Warning\n        // eslint-disable-next-line no-restricted-syntax\n        const e = new Error(\n          'Possible EventEmitter memory leak detected. ' +\n            existing.length +\n            ' ' +\n            String(type) +\n            ' listeners ' +\n            'added. Use emitter.setMaxListeners() to ' +\n            'increase limit',\n        )\n        console.warn(e)\n      }\n    }\n\n    return this\n  }\n\n  off(type: string | number, listener: Listener): this {\n    const list = this.events[type]\n    if (list === undefined) return this\n\n    if (list === listener) {\n      if (--this.eventsCount === 0) this.events = {}\n      else {\n        delete this.events[type]\n      }\n    } else if (typeof list !== 'function') {\n      let position = -1\n\n      for (let i = list.length - 1; i >= 0; i--) {\n        if (list[i] === listener) {\n          position = i\n          break\n        }\n      }\n\n      if (position < 0) return this\n\n      if (position === 0) list.shift()\n      else {\n        list.splice(position, 1)\n      }\n\n      if (list.length === 1) this.events[type] = list[0]\n    }\n\n    return this\n  }\n\n  once(type: string | number, listener: Listener, prepend = false): this {\n    const wrapper = (...args: any[]) => {\n      this.off(type, wrapper)\n      listener(...args)\n    }\n    return this.on(type, wrapper, prepend)\n  }\n}\n","import { Editable } from './editable'\nimport { Emitter } from './emitter'\n\nconst EDITOR_TO_EVENT: WeakMap<Editable, Emitter> = new WeakMap()\n\ntype EventEndingKey<\n  Set,\n  Needle extends string,\n  Key extends keyof Set = keyof Set,\n> = Key extends `${Needle}${infer _X}` ? (_X extends `` ? never : _X) : never\n\ntype EndingKey = EventEndingKey<Editable, 'on'>\n\nexport type EventType = Lowercase<EndingKey>\n\nexport type EventHandler<\n  T extends EventType,\n  Key extends EndingKey = EndingKey,\n> = Key extends `${Lowercase<Key>}`\n  ? never\n  : T extends Lowercase<Key>\n  ? Editable[`on${Key}`]\n  : never\n\nexport const EventEmitter = {\n  get: (editor: Editable) => {\n    let event = EDITOR_TO_EVENT.get(editor)\n    if (!event) {\n      event = new Emitter()\n      EDITOR_TO_EVENT.set(editor, event)\n    }\n    return event\n  },\n  on: <T extends EventType>(\n    editor: Editable,\n    type: T,\n    handler: EventHandler<T>,\n    prepend = false,\n  ) => {\n    EventEmitter.get(editor).on(type, handler, prepend)\n  },\n\n  off: <T extends EventType>(editor: Editable, type: T, handler: EventHandler<T>) => {\n    EventEmitter.get(editor).off(type, handler)\n  },\n\n  once: <T extends EventType>(\n    editor: Editable,\n    type: T,\n    handler: EventHandler<T>,\n    prepend = false,\n  ) => {\n    EventEmitter.get(editor).once(type, handler, prepend)\n  },\n\n  emit: <T extends EventType>(editor: Editable, type: T, ...args: Parameters<EventHandler<T>>) => {\n    EventEmitter.get(editor).emit(type, ...args)\n  },\n}\n","import { CompositionText, Editor, Transforms, Range, Text } from '@editablejs/models'\nimport { IS_COMPOSING } from '../utils/weak-maps'\nimport { Editable } from './editable'\n\nexport const withInput = <T extends Editor>(editor: T) => {\n  const e = editor as T & Editable\n\n  e.onInput = (value: string) => {\n    if (!editor.selection) return\n    if (Editable.isComposing(editor)) {\n      const { selection, marks } = editor\n      let [node, path] = Editor.node(editor, selection)\n      if (marks) {\n        // 使用零宽字符绕过slate里面不能插入空字符的问题。组合输入法完成后会删除掉\n        const compositionText: CompositionText = {\n          text: '\\u200b',\n          ...marks,\n          composition: {\n            text: value,\n            offset: 0,\n            isEmpty: true,\n          },\n        }\n        Transforms.insertNodes(editor, compositionText)\n        e.marks = null\n      } else if (Text.isText(node)) {\n        const composition = CompositionText.isCompositionText(node) ? node.composition : null\n        const offset = composition?.offset ?? Range.start(selection).offset\n\n        Transforms.setNodes<CompositionText>(\n          editor,\n          {\n            composition: {\n              ...composition,\n              text: value,\n              offset,\n            },\n          },\n          { at: path },\n        )\n        const point = { path, offset: offset + value.length }\n        Transforms.select(editor, {\n          anchor: point,\n          focus: point,\n        })\n      }\n    } else {\n      editor.insertText(value)\n    }\n    e.emit('input', value)\n  }\n\n  e.onBeforeInput = value => {\n    e.emit('beforeinput', value)\n  }\n\n  e.onCompositionStart = data => {\n    if (editor.selection && Range.isExpanded(editor.selection)) {\n      Editor.deleteFragment(editor)\n    }\n    IS_COMPOSING.set(editor, true)\n    e.emit('compositionstart', data)\n  }\n\n  e.onCompositionEnd = (value: string) => {\n    const { selection } = editor\n    if (!selection) return\n    const [node, path] = Editor.node(editor, selection)\n    if (Text.isText(node)) {\n      const composition = CompositionText.isCompositionText(node) ? node.composition : null\n      Transforms.setNodes<CompositionText>(\n        editor,\n        {\n          composition: undefined,\n        },\n        { at: path },\n      )\n      const point = { path, offset: composition?.offset ?? selection.anchor.offset }\n      const range = composition?.isEmpty\n        ? {\n            anchor: { path, offset: 0 },\n            focus: { path, offset: 1 },\n          }\n        : point\n      Transforms.select(editor, range)\n\n      IS_COMPOSING.set(editor, false)\n      Transforms.insertText(editor, value)\n    }\n    e.emit('compositionend', value)\n  }\n\n  return e\n}\n","import { Editor, Transforms, Node, Range } from '@editablejs/models'\nimport getDirection from 'direction'\nimport Hotkeys from '../utils/hotkeys'\nimport { getWordOffsetBackward, getWordOffsetForward } from '../utils/text'\nimport { IS_PASTE_TEXT, IS_SHIFT_PRESSED } from '../utils/weak-maps'\nimport { Editable } from './editable'\n\nexport const withKeydown = <T extends Editor>(editor: T) => {\n  const e = editor as T & Editable\n\n  e.onKeydown = (event: KeyboardEvent) => {\n    e.emit('keydown', event)\n    if (event.defaultPrevented) return\n    const { selection } = editor\n    const element = editor.children[selection !== null ? selection.focus.path[0] : 0]\n    const isRTL = getDirection(Node.string(element)) === 'rtl'\n\n    if (Hotkeys.isShift(event)) {\n      IS_SHIFT_PRESSED.set(e, true)\n    }\n\n    if (Hotkeys.isSelectAll(event)) {\n      event.preventDefault()\n      Transforms.select(e, Editor.range(e, []))\n      return\n    }\n\n    if (Hotkeys.isCut(event)) {\n      event.preventDefault()\n      e.cut()\n      return\n    }\n\n    if (Hotkeys.isCopy(event)) {\n      event.preventDefault()\n      e.copy()\n      return\n    }\n\n    if (Hotkeys.isPaste(event)) {\n      IS_PASTE_TEXT.set(e, false)\n      return\n    }\n\n    if (Hotkeys.isPasteText(event)) {\n      IS_PASTE_TEXT.set(e, true)\n      return\n    }\n\n    if (Hotkeys.isExtendForward(event)) {\n      event.preventDefault()\n      Transforms.move(e, { edge: 'focus' })\n      return\n    }\n\n    if (Hotkeys.isExtendBackward(event)) {\n      event.preventDefault()\n      Transforms.move(e, { edge: 'focus', reverse: true })\n      return\n    }\n\n    if (Hotkeys.isExtendUp(event)) {\n      event.preventDefault()\n      const point = Editable.findPreviousLinePoint(e)\n      if (point && selection)\n        Transforms.select(editor, {\n          anchor: selection.anchor,\n          focus: point,\n        })\n      return\n    }\n\n    if (Hotkeys.isExtendDown(event)) {\n      event.preventDefault()\n      const point = Editable.findNextLinePoint(e)\n      if (point && selection)\n        Transforms.select(editor, {\n          anchor: selection.anchor,\n          focus: point,\n        })\n      return\n    }\n\n    if (Hotkeys.isMoveUp(event)) {\n      event.preventDefault()\n      const point = Editable.findPreviousLinePoint(e)\n      if (point) Transforms.select(editor, point)\n      return\n    }\n\n    if (Hotkeys.isMoveDown(event)) {\n      event.preventDefault()\n      const point = Editable.findNextLinePoint(e)\n      if (point) Transforms.select(editor, point)\n      return\n    }\n\n    if (Hotkeys.isExtendLineBackward(event)) {\n      event.preventDefault()\n      Transforms.move(e, {\n        unit: 'line',\n        edge: 'focus',\n        reverse: true,\n      })\n      return\n    }\n\n    if (Hotkeys.isExtendLineForward(event)) {\n      event.preventDefault()\n      Transforms.move(e, { unit: 'line', edge: 'focus' })\n      return\n    }\n\n    if (Hotkeys.isMoveWordBackward(event)) {\n      event.preventDefault()\n\n      if (selection && Range.isExpanded(selection)) {\n        Transforms.collapse(editor, { edge: 'focus' })\n      }\n      if (selection) {\n        const { focus } = selection\n        const { path: focusPath } = focus\n        if (Editor.isStart(editor, focus, focusPath)) {\n          Transforms.move(e, { reverse: !isRTL })\n          return\n        }\n        const { text, offset } = Editable.findTextOffsetOnLine(e, focus)\n        if (text) {\n          const wordOffset = getWordOffsetBackward(text, offset)\n          const newPoint = Editable.findPointOnLine(e, focusPath, wordOffset)\n          Transforms.select(editor, newPoint)\n          return\n        }\n      }\n      Transforms.move(e, { unit: 'word', reverse: !isRTL })\n      return\n    }\n\n    if (Hotkeys.isMoveWordForward(event)) {\n      event.preventDefault()\n\n      if (selection && Range.isExpanded(selection)) {\n        Transforms.collapse(editor, { edge: 'focus' })\n      }\n      if (selection) {\n        const { focus } = selection\n        const { path: focusPath } = focus\n        if (Editor.isEnd(editor, focus, focusPath)) {\n          Transforms.move(e, { reverse: isRTL })\n          return\n        }\n        const { text, offset } = Editable.findTextOffsetOnLine(e, focus)\n        if (text) {\n          const wordOffset = getWordOffsetForward(text, offset)\n          Transforms.select(editor, Editable.findPointOnLine(e, focusPath, wordOffset))\n          return\n        }\n      }\n      Transforms.move(e, { unit: 'word', reverse: isRTL })\n      return\n    }\n\n    if (Hotkeys.isMoveBackward(event)) {\n      event.preventDefault()\n\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms.move(e, { reverse: !isRTL })\n      } else {\n        Transforms.collapse(editor, { edge: 'start' })\n      }\n\n      return\n    }\n\n    if (Hotkeys.isMoveForward(event)) {\n      event.preventDefault()\n\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms.move(e, { reverse: isRTL })\n      } else {\n        Transforms.collapse(editor, { edge: 'end' })\n      }\n\n      return\n    }\n\n    if (Hotkeys.isMoveLineStart(event)) {\n      event.preventDefault()\n\n      const point = Editable.findLineEdgePoint(e)\n      if (point) {\n        Transforms.select(editor, point)\n      }\n\n      return\n    }\n\n    if (Hotkeys.isMoveLineEnd(event)) {\n      event.preventDefault()\n\n      const point = Editable.findLineEdgePoint(e, { edge: 'end' })\n      if (point) {\n        Transforms.select(editor, point)\n      }\n\n      return\n    }\n\n    if (Hotkeys.isMoveEditorStart(event)) {\n      event.preventDefault()\n\n      e.focus(true)\n\n      return\n    }\n\n    if (Hotkeys.isMoveEditorEnd(event)) {\n      event.preventDefault()\n\n      e.focus(false)\n\n      return\n    }\n\n    if (Hotkeys.isSoftBreak(event)) {\n      event.preventDefault()\n      Editor.insertSoftBreak(editor)\n      return\n    }\n\n    if (Hotkeys.isSplitBlock(event)) {\n      event.preventDefault()\n      Editor.insertBreak(editor)\n      return\n    }\n\n    if (Hotkeys.isDeleteBackward(event)) {\n      event.preventDefault()\n      if (selection && Range.isExpanded(selection)) {\n        Editor.deleteFragment(editor)\n      } else {\n        Editor.deleteBackward(editor)\n      }\n      return\n    }\n\n    if (Hotkeys.isDeleteForward(event)) {\n      event.preventDefault()\n\n      if (selection && Range.isExpanded(selection)) {\n        Editor.deleteFragment(editor, { direction: 'forward' })\n      } else {\n        Editor.deleteForward(editor)\n      }\n\n      return\n    }\n\n    if (Hotkeys.isDeleteLineBackward(event)) {\n      event.preventDefault()\n\n      if (selection && Range.isExpanded(selection)) {\n        Editor.deleteFragment(editor, { direction: 'backward' })\n      } else {\n        Editor.deleteBackward(editor, { unit: 'line' })\n      }\n\n      return\n    }\n\n    if (Hotkeys.isDeleteLineForward(event)) {\n      event.preventDefault()\n\n      if (selection && Range.isExpanded(selection)) {\n        Editor.deleteFragment(editor, { direction: 'forward' })\n      } else {\n        Editor.deleteForward(editor, { unit: 'line' })\n      }\n\n      return\n    }\n\n    if (Hotkeys.isDeleteWordBackward(event)) {\n      event.preventDefault()\n\n      if (selection && Range.isExpanded(selection)) {\n        Editor.deleteFragment(editor, { direction: 'backward' })\n      } else {\n        Editor.deleteBackward(editor, { unit: 'word' })\n      }\n\n      return\n    }\n\n    if (Hotkeys.isDeleteWordForward(event)) {\n      event.preventDefault()\n\n      if (selection && Range.isExpanded(selection)) {\n        Editor.deleteFragment(editor, { direction: 'forward' })\n      } else {\n        Editor.deleteForward(editor, { unit: 'word' })\n      }\n\n      return\n    }\n  }\n}\n","import { isHotkey, isCodeHotkey, isKeyHotkey } from 'is-hotkey'\nimport { IS_APPLE } from './environment'\n\n/**\n * Hotkey mappings for each platform.\n */\n\nconst HOTKEYS: Record<string, string | string[]> = {\n  compose: ['down', 'left', 'right', 'up', 'backspace', 'enter'],\n  selectAll: 'mod+a',\n  cut: 'mod+x',\n  copy: 'mod+c',\n  paste: 'mod+v',\n  pasteText: 'mod+shift+v',\n  moveUp: 'up',\n  moveDown: 'down',\n  moveBackward: 'left',\n  moveForward: 'right',\n  shift: 'shift',\n  moveWordBackward: 'ctrl+left',\n  moveWordForward: 'ctrl+right',\n  extendUp: 'shift+up',\n  extendDown: 'shift+down',\n  deleteBackward: 'shift?+backspace',\n  deleteForward: 'shift?+delete',\n  extendBackward: 'shift+left',\n  extendForward: 'shift+right',\n  insertSoftBreak: 'shift+enter',\n  splitBlock: 'enter',\n  undo: 'mod+z',\n}\n\nconst APPLE_HOTKEYS: Record<string, string | string[]> = {\n  moveLineBackward: 'opt+up',\n  moveLineForward: 'opt+down',\n  moveWordBackward: 'opt+left',\n  moveWordForward: 'opt+right',\n  moveLineStart: 'cmd+left',\n  moveLineEnd: 'cmd+right',\n  moveEditorStart: 'cmd+up',\n  moveEditorEnd: 'cmd+down',\n  deleteBackward: ['ctrl+backspace', 'ctrl+h'],\n  deleteForward: ['ctrl+delete', 'ctrl+d'],\n  deleteLineBackward: 'cmd+shift?+backspace',\n  deleteLineForward: ['cmd+shift?+delete', 'ctrl+k'],\n  deleteWordBackward: 'opt+shift?+backspace',\n  deleteWordForward: 'opt+shift?+delete',\n  extendLineBackward: 'opt+shift+up',\n  extendLineForward: 'opt+shift+down',\n  redo: 'cmd+shift+z',\n  transposeCharacter: 'ctrl+t',\n}\n\nconst WINDOWS_HOTKEYS: Record<string, string | string[]> = {\n  deleteWordBackward: 'ctrl+shift?+backspace',\n  deleteWordForward: 'ctrl+shift?+delete',\n  redo: ['ctrl+y', 'ctrl+shift+z'],\n}\n\n/**\n * Create a platform-aware hotkey checker.\n */\n\nconst create = (key: string) => {\n  const generic = HOTKEYS[key]\n  const apple = APPLE_HOTKEYS[key]\n  const windows = WINDOWS_HOTKEYS[key]\n  const isGeneric = generic && isKeyHotkey(generic)\n  const isApple = apple && isKeyHotkey(apple)\n  const isWindows = windows && isKeyHotkey(windows)\n\n  return (event: KeyboardEvent) => {\n    if (isGeneric && isGeneric(event)) return true\n    if (IS_APPLE && isApple && isApple(event)) return true\n    if (!IS_APPLE && isWindows && isWindows(event)) return true\n    return false\n  }\n}\n\n/**\n * Hotkeys.\n */\n\nconst Hotkeys = {\n  isSelectAll: create('selectAll'),\n  isCut: create('cut'),\n  isCopy: create('copy'),\n  isPaste: create('paste'),\n  isPasteText: create('pasteText'),\n  isMoveUp: create('moveUp'),\n  isMoveDown: create('moveDown'),\n  isCompose: create('compose'),\n  isMoveBackward: create('moveBackward'),\n  isMoveForward: create('moveForward'),\n  isDeleteBackward: create('deleteBackward'),\n  isDeleteForward: create('deleteForward'),\n  isDeleteLineBackward: create('deleteLineBackward'),\n  isDeleteLineForward: create('deleteLineForward'),\n  isDeleteWordBackward: create('deleteWordBackward'),\n  isDeleteWordForward: create('deleteWordForward'),\n  isExtendUp: create('extendUp'),\n  isExtendDown: create('extendDown'),\n  isExtendBackward: create('extendBackward'),\n  isExtendForward: create('extendForward'),\n  isExtendLineBackward: create('extendLineBackward'),\n  isExtendLineForward: create('extendLineForward'),\n  isMoveLineBackward: create('moveLineBackward'),\n  isMoveLineForward: create('moveLineForward'),\n  isMoveWordBackward: create('moveWordBackward'),\n  isMoveWordForward: create('moveWordForward'),\n  isMoveLineStart: create('moveLineStart'),\n  isMoveLineEnd: create('moveLineEnd'),\n  isMoveEditorStart: create('moveEditorStart'),\n  isMoveEditorEnd: create('moveEditorEnd'),\n  isShift: create('shift'),\n  isRedo: create('redo'),\n  isSoftBreak: create('insertSoftBreak'),\n  isSplitBlock: create('splitBlock'),\n  isTransposeCharacter: create('transposeCharacter'),\n  isUndo: create('undo'),\n}\n\nexport default Hotkeys\n\nfunction match(\n  keys: string | string[] | ((e: KeyboardEvent) => boolean),\n  event: KeyboardEvent,\n): boolean\nfunction match<T extends string = string>(\n  keys: Record<T, string | string[] | ((e: KeyboardEvent) => boolean)>,\n  event: KeyboardEvent,\n): T | false\nfunction match<T extends string = string>(\n  keys:\n    | string\n    | string[]\n    | ((e: KeyboardEvent) => boolean)\n    | Record<T, string | string[] | ((e: KeyboardEvent) => boolean)>,\n  event: KeyboardEvent,\n): T | boolean {\n  if (typeof keys === 'string' || Array.isArray(keys)) {\n    return isHotkey(keys, event)\n  } else if (typeof keys === 'function') {\n    return keys(event)\n  } else {\n    for (const key in keys) {\n      const value = keys[key]\n      if (match(value, event)) {\n        return key\n      }\n    }\n  }\n  return false\n}\nexport const Hotkey = {\n  isCode: isCodeHotkey,\n  isKey: isKeyHotkey,\n  format: (key: string, char = '+') => {\n    let keys = key.toLowerCase().split('+')\n    keys = keys.map(key => {\n      if (key === 'mod') {\n        return IS_APPLE ? '⌘' : 'Ctrl'\n      } else if (key === 'opt') {\n        return IS_APPLE ? 'Option' : 'Alt'\n      } else if (key.length > 1) {\n        return key.substring(0, 1).toUpperCase() + key.substring(1).toLowerCase()\n      }\n      return key.toUpperCase()\n    })\n    return keys.join(char)\n  },\n  match,\n}\n","import { Editor, Transforms, Node, Path } from '@editablejs/models'\nimport { Editable } from './editable'\n\nexport const withNormalizeNode = <T extends Editor>(editor: T) => {\n  const e = editor as T & Editable\n\n  const { normalizeNode } = editor\n\n  e.normalizeNode = entry => {\n    const [node, path] = entry\n    if (Editor.isBlock(e, node)) {\n      const { type, ...attributes } = node\n      let isUnwrap = false\n      const isParagraph = !type || type === 'paragraph'\n      // 相同type类的block不嵌套，paragraph 下不能嵌套block节点\n      for (const [child, childPath] of Node.children(editor, path)) {\n        if (Editor.isBlock(e, child)) {\n          if (!isUnwrap && !isParagraph && child.type === type) {\n            Transforms.unwrapNodes(editor, { at: childPath })\n            return\n          } else if (isParagraph) {\n            Transforms.setNodes(editor, attributes, { at: childPath })\n            isUnwrap = true\n          }\n        }\n      }\n      if (isUnwrap) {\n        Transforms.unwrapNodes(editor, { at: path })\n        return\n      }\n    }\n    normalizeNode(entry)\n  }\n\n  return e\n}\n","import { HTMLDeserializer } from '@editablejs/deserializer/html'\nimport { Editor, Transforms, Range, Node } from '@editablejs/models'\nimport { HTMLSerializer } from '@editablejs/serializer/html'\nimport { TextSerializer } from '@editablejs/serializer/text'\nimport { readClipboardData, writeClipboardData } from '../utils/clipboard'\nimport {\n  APPLICATION_FRAGMENT_TYPE,\n  DATA_EDITABLE_FRAGMENT,\n  TEXT_HTML,\n  TEXT_PLAIN,\n} from '../utils/constants'\nimport { fragmentToString, parseDataTransfer } from '../utils/data-transfer'\nimport { IS_PASTE_TEXT } from '../utils/weak-maps'\nimport { Editable } from './editable'\n\nexport const withDataTransfer = <T extends Editor>(editor: T) => {\n  const e = editor as T & Editable\n\n  e.toDataTransfer = range => {\n    const fragment = e.getFragment(range)\n    const fragmentString = fragmentToString(fragment)\n\n    const text = fragment.map(node => TextSerializer.transformWithEditor(e, node)).join('\\n')\n\n    let html = fragment.map(node => HTMLSerializer.transformWithEditor(e, node)).join('')\n    html = `<div ${DATA_EDITABLE_FRAGMENT}=\"${fragmentString}\">${html}</div>`\n    html = `<html><head><meta name=\"source\" content=\"${DATA_EDITABLE_FRAGMENT}\" /></head><body>${html}</body></html>`\n    const dataTransfer = new DataTransfer()\n    dataTransfer.setData(TEXT_PLAIN, text)\n    dataTransfer.setData(TEXT_HTML, html)\n    dataTransfer.setData(APPLICATION_FRAGMENT_TYPE, fragmentString)\n    return dataTransfer\n  }\n\n  e.onCut = event => {\n    if (event.defaultPrevented) return\n    const { selection } = e\n    const { clipboardData } = event\n    if (clipboardData) writeClipboardData(clipboardData)\n    if (selection) {\n      if (Range.isExpanded(selection)) {\n        Editor.deleteFragment(e)\n      } else {\n        const node = Node.parent(e, selection.anchor.path)\n        if (Editor.isVoid(e, node)) {\n          Transforms.delete(e)\n        }\n      }\n    }\n    e.emit('cut', event)\n  }\n\n  e.onCopy = event => {\n    if (event.defaultPrevented) return\n    const { clipboardData } = event\n    if (clipboardData) writeClipboardData(clipboardData)\n    e.emit('copy', event)\n  }\n\n  e.onPaste = event => {\n    if (event.defaultPrevented) return\n    const { clipboardData } = event\n    if (!clipboardData) return\n    event.preventDefault()\n    const { text, fragment, html, files } = parseDataTransfer(clipboardData)\n    const isPasteText = event.type === 'pasteText'\n    if (!isPasteText && fragment.length > 0) {\n      e.insertFragment(fragment)\n    } else if (!isPasteText && html) {\n      const document = new DOMParser().parseFromString(html, TEXT_HTML)\n      const fragment = HTMLDeserializer.transformWithEditor(e, document.body)\n      e.insertFragment(fragment)\n    } else {\n      const lines = text.split(/\\r\\n|\\r|\\n/)\n      let split = false\n\n      for (const line of lines) {\n        if (split) {\n          Transforms.splitNodes(e, { always: true })\n        }\n        e.normalizeSelection(selection => {\n          if (selection !== e.selection) e.selection = selection\n          e.insertText(line)\n        })\n        split = true\n      }\n    }\n    for (const file of files) {\n      e.insertFile(file)\n    }\n    e.emit('paste', event)\n  }\n\n  e.copy = range => {\n    const data = e.toDataTransfer(range)\n    const event = new ClipboardEvent('copy', { clipboardData: data })\n    e.onCopy(event)\n  }\n\n  e.cut = range => {\n    const data = e.toDataTransfer(range)\n    const event = new ClipboardEvent('copy', { clipboardData: data })\n    if (range) {\n      Transforms.select(e, range)\n    }\n    e.onCut(event)\n  }\n\n  e.insertFromClipboard = range => {\n    if (range) {\n      Transforms.select(e, range)\n    }\n    readClipboardData().then(data => {\n      const event = new ClipboardEvent('paste', { clipboardData: data })\n      e.onPaste(event)\n    })\n  }\n\n  e.insertTextFromClipboard = range => {\n    if (range) {\n      Transforms.select(e, range)\n    }\n    readClipboardData().then(data => {\n      IS_PASTE_TEXT.set(e, true)\n      const event = new ClipboardEvent('pasteText', { clipboardData: data })\n      e.onPaste(event)\n    })\n  }\n\n  return e\n}\n","import { APPLICATION_FRAGMENT_TYPE, TEXT_HTML, TEXT_PLAIN } from './constants'\nimport { matchFragmentStringFromHTML, parseDataTransferFiles } from './data-transfer'\nimport { isDOMHTMLElement } from '@editablejs/models'\n\nconst deselectCurrent = () => {\n  const selection = document.getSelection()\n  if (!selection?.rangeCount) {\n    return function () {}\n  }\n  let active: HTMLElement | null = null\n  let activeElement = document.activeElement\n  if (activeElement && activeElement.shadowRoot) {\n    activeElement = activeElement.shadowRoot.activeElement\n  }\n  if (isDOMHTMLElement(activeElement)) {\n    active = activeElement\n  }\n  const ranges: Range[] = []\n  for (var i = 0; i < selection.rangeCount; i++) {\n    ranges.push(selection.getRangeAt(i))\n  }\n  switch (\n    active?.tagName.toUpperCase() // .toUpperCase handles XHTML\n  ) {\n    case 'INPUT':\n    case 'TEXTAREA':\n      active.blur()\n      break\n\n    default:\n      active = null\n      break\n  }\n\n  selection.removeAllRanges()\n  return () => {\n    if (selection.type === 'Caret') {\n      selection.removeAllRanges()\n    }\n\n    if (!selection.rangeCount) {\n      ranges.forEach(range => {\n        selection.addRange(range)\n      })\n    }\n    if (active) {\n      active.focus()\n    }\n  }\n}\n\nexport const readClipboardDataByCommand = () => {\n  return new Promise<DataTransfer | null>((resolve, reject) => {\n    let textarea: HTMLTextAreaElement | null = null\n    let reselectPrevious: (() => void) | null = null\n\n    let selection: Selection | null = null\n    try {\n      reselectPrevious = deselectCurrent()\n\n      selection = document.getSelection()\n\n      textarea = document.createElement('textarea')\n      textarea.style.cssText = 'position: fixed; top: -9999; left: -9999; opacity: 0;'\n\n      textarea.addEventListener('paste', e => {\n        e.preventDefault()\n        e.stopPropagation()\n        resolve(e.clipboardData)\n      })\n\n      document.body.appendChild(textarea)\n\n      textarea.focus()\n\n      const successful = document.execCommand('paste')\n      if (!successful) throw new Error('paste failed')\n    } catch (error) {\n      reject(error)\n    } finally {\n      if (selection) {\n        selection.removeAllRanges()\n      }\n      if (textarea) document.body.removeChild(textarea)\n      if (reselectPrevious) reselectPrevious()\n    }\n  })\n}\n\nexport const readClipboardData = async () => {\n  let text = ''\n  let html = ''\n  let fragment = ''\n  const dataTransfer = new DataTransfer()\n  try {\n    const items = await navigator.clipboard.read()\n    for (const item of items) {\n      try {\n        text += await (await item.getType(TEXT_PLAIN)).text()\n      } catch {}\n      try {\n        html += await (await item.getType(TEXT_HTML)).text()\n      } catch {}\n      if (!fragment) {\n        try {\n          fragment = await (await item.getType(APPLICATION_FRAGMENT_TYPE)).text()\n        } catch (error) {\n          fragment = matchFragmentStringFromHTML(html)\n        }\n      }\n\n      for (const type of item.types) {\n        if (~[APPLICATION_FRAGMENT_TYPE, TEXT_PLAIN, TEXT_HTML].indexOf(type)) continue\n        const blob = await item.getType(type)\n        const file = new File([blob], 'unknow', {\n          type,\n        })\n        dataTransfer.items.add(file)\n      }\n    }\n  } catch (error) {\n    try {\n      const data = await readClipboardDataByCommand()\n      if (data) return data\n    } catch (error) {\n      console.error(error)\n    }\n  }\n  dataTransfer.setData(TEXT_PLAIN, text)\n  dataTransfer.setData(TEXT_HTML, html)\n  dataTransfer.setData(APPLICATION_FRAGMENT_TYPE, fragment)\n  return dataTransfer\n}\n\nexport const writeClipboardDataByCommand = (data: DataTransfer) => {\n  return new Promise<boolean>((resolve, reject) => {\n    let mark: HTMLElement | null = null\n    let reselectPrevious: (() => void) | null = null\n    let selection: Selection | null = null\n    let range: Range | null = null\n    try {\n      reselectPrevious = deselectCurrent()\n\n      range = document.createRange()\n      selection = document.getSelection()\n\n      mark = document.createElement('span')\n      mark.style.cssText = 'position: fixed; top: -9999;'\n      mark.ariaHidden = 'true'\n      mark.textContent = 'copy content'\n      mark.style.userSelect = 'text'\n      mark.addEventListener('copy', e => {\n        e.stopPropagation()\n        const { clipboardData } = e\n        if (clipboardData) {\n          e.preventDefault()\n          clipboardData.clearData()\n          clipboardData.setData(TEXT_PLAIN, data.getData(TEXT_PLAIN))\n          clipboardData.setData(TEXT_HTML, data.getData(TEXT_HTML))\n          clipboardData.setData(APPLICATION_FRAGMENT_TYPE, data.getData(APPLICATION_FRAGMENT_TYPE))\n          const files = parseDataTransferFiles(data)\n          for (const file of files) {\n            clipboardData.items.add(file)\n          }\n          resolve(true)\n        } else {\n          resolve(false)\n        }\n      })\n      document.body.appendChild(mark)\n\n      range.selectNodeContents(mark)\n      selection?.addRange(range)\n\n      const successful = document.execCommand('copy')\n      if (!successful) throw new Error('copy failed')\n    } catch (error) {\n      reject(error)\n    } finally {\n      if (selection) {\n        if (range && typeof selection.removeRange == 'function') {\n          selection.removeRange(range)\n        } else {\n          selection.removeAllRanges()\n        }\n      }\n      if (mark) document.body.removeChild(mark)\n      if (reselectPrevious) reselectPrevious()\n    }\n  })\n}\n\nexport const writeClipboardData = (data: DataTransfer) => {\n  try {\n    const files = parseDataTransferFiles(data)\n\n    navigator.clipboard.write([\n      new ClipboardItem({\n        [TEXT_PLAIN]: new Blob([data.getData(TEXT_PLAIN)], { type: TEXT_PLAIN }),\n        [TEXT_HTML]: new Blob([data.getData(TEXT_HTML)], { type: TEXT_HTML }),\n        // 当前不支持自定义类型\n        // https://github.com/w3c/editing/blob/gh-pages/docs/clipboard-pickling/explainer.md\n        // [APPLICATION_FRAGMENT_TYPE]: data.getData(APPLICATION_FRAGMENT_TYPE),\n        ...files.reduce((acc, file) => ({ ...acc, [file.type]: file }), {}),\n      }),\n    ])\n  } catch (error) {\n    try {\n      writeClipboardDataByCommand(data)\n    } catch (error) {\n      console.error(error)\n    }\n  }\n}\n"],"mappings":"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","names":["React","import_zustand","create","merge","import_zustand","match","key","React","import_models","import_models","React","import_models","React","import_models","React","import_models","import_models","React","rects","import_models","rects","match","element","node","range","lineRect","import_zustand","getStore","create","isFocused","import_zustand","EDITABLE_TO_FOCUSED_STORE","getStore","create","isReadOnly","match","n","window","node","nodes","textNode","block","path","scrollIntoView","String","import_jsx_runtime","React","React","import_zustand","import_zustand","create","import_jsx_runtime","Text","ranges","key","SlateText","React","import_models","import_zustand","import_models","import_zustand","create","actives","import_jsx_runtime","Element","getDirection","children","React","React","React","import_jsx_runtime","React","React","React","import_jsx_runtime","root","ReactDOM","React","import_models","React","import_zustand","import_zustand","import_models","getStore","create","rects","import_jsx_runtime","import_models","import_jsx_runtime","import_models","React","import_jsx_runtime","event","rect","React","import_zustand","import_models","create","import_zustand","React","import_models","import_jsx_runtime","import_react","import_react","import_zustand","import_lodash","import_zustand","getStore","create","predicate","merge","React","shallow","import_jsx_runtime","React","React","import_models","import_jsx_runtime","import_jsx_runtime","window","React","import_models","import_zustand","import_jsx_runtime","store","create","React","import_models","selection","React","import_models","React","import_models","import_models","import_models","import_models","import_models","import_direction","create","key","getDirection","import_models","import_models","import_html","import_text","import_models","error","document","fragment","import_jsx_runtime"]}
\ No newline at end of file
diff --git a/node_modules/@editablejs/editor/dist/index.mjs.map b/node_modules/@editablejs/editor/dist/index.mjs.map
index d817597..a3e90c7 100644
--- a/node_modules/@editablejs/editor/dist/index.mjs.map
+++ b/node_modules/@editablejs/editor/dist/index.mjs.map
@@ -1 +1 @@
-{"version":3,"sources":["../src/utils/constants.ts","../src/utils/data-transfer.ts","../src/hooks/use-locale.ts","../src/plugin/locale.ts","../src/hooks/use-editable.tsx","../src/components/content.tsx","../src/hooks/use-children.tsx","../src/components/element.tsx","../src/components/text.tsx","../src/components/leaf.tsx","../src/components/string.tsx","../src/plugin/editable.ts","../src/utils/weak-maps.ts","../src/utils/dom.ts","../src/utils/environment.ts","../src/utils/nearby.ts","../src/utils/text.ts","../src/utils/selection.ts","../src/hooks/use-focused.ts","../src/utils/event.ts","../src/hooks/use-read-only.ts","../src/hooks/use-isomorphic-layout-effect.ts","../src/hooks/use-decorate.ts","../src/plugin/decorate.ts","../src/hooks/use-placeholder.ts","../src/plugin/placeholder.ts","../src/hooks/use-node-selected.ts","../src/hooks/use-node-focused.ts","../src/hooks/use-grid.ts","../src/hooks/use-multiple-click.ts","../src/hooks/use-cancellable-promises.ts","../src/components/shadow.tsx","../src/components/caret.tsx","../src/hooks/use-selection-drawing.ts","../src/plugin/selection-drawing.ts","../src/components/selection.tsx","../src/components/input.tsx","../src/hooks/use-drag.ts","../src/plugin/drag.ts","../src/components/drag-caret.tsx","../src/components/slot.tsx","../src/hooks/use-slot.ts","../src/plugin/solt.ts","../src/components/touch-point.tsx","../src/components/editable.tsx","../src/hooks/use-grid-selection.ts","../src/hooks/use-grid-selection-rect.ts","../src/hooks/use-grid-selected.ts","../src/plugin/with-editable.tsx","../src/utils/lines.ts","../src/plugin/emitter.ts","../src/plugin/event.ts","../src/plugin/with-input.ts","../src/plugin/with-keydown.ts","../src/utils/hotkeys.ts","../src/plugin/with-normalize-node.ts","../src/plugin/with-data-transfer.ts","../src/utils/clipboard.ts"],"sourcesContent":["export const APPLICATION_FRAGMENT_TYPE = 'application/x-editable-fragment'\nexport const TEXT_HTML = 'text/html'\nexport const TEXT_PLAIN = 'text/plain'\nexport const DATA_EDITABLE_FRAGMENT = `data-ea-fragment`\nexport const DATA_EDITABLE_NODE = `data-ea-node`\nexport const DATA_EDITABLE_INLINE = `data-ea-inline`\nexport const DATA_EDITABLE_STRING = `data-ea-string`\nexport const DATA_EDITABLE_COMPOSITION = `data-ea-composition`\nexport const DATA_EDITABLE_ZERO_WIDTH = `data-ea-zero-width`\nexport const DATA_EDITABLE_LENGTH = `data-ea-length`\nexport const DATA_EDITABLE_VOID = `data-ea-void`\nexport const DATA_EDITABLE_PLACEHOLDER = `data-ea-placeholder`\nexport const DATA_EDITABLE_LEAF = `data-ea-leaf`\n\nexport const Constants = {\n  applicationType: APPLICATION_FRAGMENT_TYPE,\n  htmlType: TEXT_HTML,\n  plainType: TEXT_PLAIN,\n  dataFragment: DATA_EDITABLE_FRAGMENT,\n  dataNode: DATA_EDITABLE_NODE,\n  dataInline: DATA_EDITABLE_INLINE,\n  dataString: DATA_EDITABLE_STRING,\n  dataComposition: DATA_EDITABLE_COMPOSITION,\n  dataZeroWidth: DATA_EDITABLE_ZERO_WIDTH,\n  dataLength: DATA_EDITABLE_LENGTH,\n  dataVoid: DATA_EDITABLE_VOID,\n  dataPlaceholder: DATA_EDITABLE_PLACEHOLDER,\n  dataLeaf: DATA_EDITABLE_LEAF,\n}\n","import { Descendant } from '@editablejs/models'\nimport {\n  APPLICATION_FRAGMENT_TYPE,\n  DATA_EDITABLE_FRAGMENT,\n  TEXT_HTML,\n  TEXT_PLAIN,\n} from './constants'\n\ninterface DataTransferFormatData {\n  html: string\n  text: string\n  fragment: Descendant[]\n  files: File[]\n}\n\n/**\n * Convert fragment to string\n * @param fragment\n * @returns string representation of the fragment\n **/\nexport const fragmentToString = (fragment: Descendant[]) => {\n  const string = JSON.stringify(fragment)\n  return window.btoa(encodeURIComponent(string))\n}\n\n/**\n * Parse fragment from string\n * @param fragment string representation of the fragment\n * @returns fragment\n **/\nexport const parseFragmentFromString = (fragment: string): Descendant[] => {\n  const string = decodeURIComponent(window.atob(fragment))\n  try {\n    return JSON.parse(string)\n  } catch (error) {\n    return []\n  }\n}\n\n/**\n * Match fragment string from HTML\n * @param html\n * @returns string representation of the fragment\n **/\nexport const matchFragmentStringFromHTML = (html: string) => {\n  const reg = new RegExp(`${DATA_EDITABLE_FRAGMENT}=\"(.+?)\"`)\n  return html.match(reg)?.[1] ?? ''\n}\n\n/**\n * Parse files from DataTransfer object\n * @param dataTransfer\n * @returns array of files\n **/\nexport const parseDataTransferFiles = (dataTransfer: DataTransfer) => {\n  let files: File[] = []\n\n  try {\n    if (dataTransfer.items && dataTransfer.items.length > 0) {\n      for (const item of dataTransfer.items) {\n        let file = item.kind === 'file' ? item.getAsFile() : null\n        if (file !== null) {\n          if (file.type && file.type.indexOf('image/png') > -1 && !file.lastModified) {\n            file = new File([file], 'image.png', {\n              type: file.type,\n            })\n          }\n        }\n        if (file) files.push(file)\n      }\n    } else if (dataTransfer.files && dataTransfer.files.length > 0) {\n      files = Array.from(dataTransfer.files)\n    }\n  } catch (err) {\n    if (dataTransfer.files && dataTransfer.files.length > 0) {\n      files = Array.from(dataTransfer.files)\n    }\n  }\n  return files\n}\n\n/**\n * Parse Data from DataTransfer\n * @param dataTransfer\n * @returns DataTransferFormatData\n **/\nexport const parseDataTransfer = (dataTransfer: DataTransfer): DataTransferFormatData => {\n  const text = dataTransfer.getData(TEXT_PLAIN)\n  const html = dataTransfer.getData(TEXT_HTML)\n  let fragment = dataTransfer.getData(APPLICATION_FRAGMENT_TYPE)\n  if (!fragment) fragment = matchFragmentStringFromHTML(html)\n  return {\n    text,\n    html,\n    fragment: fragment ? parseFragmentFromString(fragment) : [],\n    files: parseDataTransferFiles(dataTransfer),\n  }\n}\n\n/**\n * Set Data to DataTransfer\n * @param dataTransfer\n * @param data\n **/\nexport const setDataTransfer = (\n  dataTransfer: DataTransfer,\n  data: Partial<DataTransferFormatData>,\n) => {\n  const { text, html, fragment, files } = data\n  if (text) dataTransfer.setData(TEXT_PLAIN, text)\n  if (html) dataTransfer.setData(TEXT_HTML, html)\n  if (fragment) dataTransfer.setData(APPLICATION_FRAGMENT_TYPE, fragmentToString(fragment))\n  if (files) {\n    for (const file of files) {\n      dataTransfer.items.add(file)\n    }\n  }\n}\n","import * as React from 'react'\nimport { useStore } from 'zustand'\nimport { Editable } from '../plugin/editable'\nimport { Locale, LocaleComponentName } from '../plugin/locale'\nimport { useEditableStatic } from './use-editable'\n\nexport const useLocaleStore = (editor: Editable) => {\n  return React.useMemo(() => {\n    return Locale.getStore(editor)\n  }, [editor])\n}\n\nexport const useLang = (editor: Editable): string => {\n  const store = useLocaleStore(editor)\n  return useStore(store, state => state.lang)\n}\n\nexport const useLocale = <\n  L extends Locale,\n  T extends LocaleComponentName<L> = LocaleComponentName<L>,\n>(\n  componentName: T,\n  defaultLocale?: L[T] | (() => L[T]),\n): L[T] => {\n  const editor = useEditableStatic()\n  const lang = useLang(editor)\n  const localeContext = useLocales<L>(editor, lang)\n  const componentLocaleContext = localeContext[componentName]\n\n  const componentLocale = React.useMemo(() => {\n    const locale = componentLocaleContext || defaultLocale\n    return {\n      ...(locale instanceof Function ? locale() : locale),\n    } as L[T]\n  }, [defaultLocale, componentLocaleContext])\n\n  return componentLocale\n}\n\nexport const useLocales = <T extends Locale>(editor: Editable, lang: string): T => {\n  const store = useLocaleStore(editor)\n\n  const locales = useStore(store, state => state.locales[lang] ?? state.locales['en-US'])\n  return locales as T\n}\n\nexport const useLocaleFormat = <\n  L extends Locale,\n  T extends LocaleComponentName<L> = LocaleComponentName<L>,\n>(\n  componentName: T,\n) => {\n  const locale = useLocale<L>(componentName)\n  return {\n    format: (key: keyof typeof locale, options?: Record<string, string | number>) => {\n      const value = locale[key]\n      if (typeof value === 'string') {\n        if (!options) return value\n        return value.replace(/{(\\w+)}/g, (match, key) => String(options[key]) || match)\n      }\n      return ''\n    },\n  }\n}\n","import merge from 'lodash.merge'\nimport create, { StoreApi, UseBoundStore } from 'zustand'\nimport { Editor } from '@editablejs/models'\nexport interface Locale {\n  locale: string\n}\n\nexport interface LocaleState {\n  lang: string\n  locales: Record<string, Locale>\n}\n\nconst EDITOR_TO_LOCALE_STORE: WeakMap<Editor, UseBoundStore<StoreApi<LocaleState>>> = new WeakMap()\n\nconst getStore = (editor: Editor) => {\n  let store = EDITOR_TO_LOCALE_STORE.get(editor)\n  if (!store) {\n    store = create<LocaleState>(() => ({\n      lang: 'en-US',\n      locales: {},\n    }))\n    EDITOR_TO_LOCALE_STORE.set(editor, store)\n  }\n  return store\n}\n\nexport const Locale = {\n  getStore,\n\n  setLocale: <T extends Locale>(editor: Editor, ...locales: Record<string, T>[]) => {\n    const store = getStore(editor)\n    store.setState(state => {\n      const { lang, locales: prevLocales } = state\n      const newLocales = Object.assign({}, prevLocales)\n      for (const locale of locales) {\n        for (const key in locale) {\n          newLocales[key] = merge(newLocales[key], locale[key])\n        }\n      }\n      return {\n        lang,\n        locales: newLocales,\n      }\n    })\n  },\n\n  getLang: (editor: Editor) => {\n    const state = getStore(editor).getState()\n    return state.lang\n  },\n\n  setLang: (editor: Editor, lang: string) => {\n    const store = getStore(editor)\n    store.setState(state => {\n      return {\n        lang,\n        locales: state.locales,\n      }\n    })\n  },\n\n  getLocale: <T extends Locale>(editor: Editor): T => {\n    const lang = Locale.getLang(editor)\n    const locales = Locale.getLocales(editor)\n    return (locales[lang] ?? locales['en-US']) as any\n  },\n\n  getLocales: (editor: Editor): Record<string, Locale> => {\n    const state = getStore(editor).getState()\n    return state.locales\n  },\n}\n\nexport type LocaleComponentName<T extends Locale> = Exclude<keyof T, 'locale'>\n","import * as React from 'react'\nimport { StoreApi, UseBoundStore, useStore } from 'zustand'\nimport { Editable } from '../plugin/editable'\n\nexport interface EditableStore {\n  editor: [Editable]\n}\n\nexport const useEditableStore = () => {\n  const contenxt = React.useContext(EditableStoreContext)\n  if (!contenxt) {\n    throw new Error(\n      `The \\`useEditableStore\\` hook must be used inside the <EditableProvider> component's context.`,\n    )\n  }\n\n  return contenxt.store\n}\n\nexport interface EditableStoreContext {\n  store: UseBoundStore<StoreApi<EditableStore>>\n  editor: Editable\n}\n\nexport const EditableStoreContext = React.createContext<EditableStoreContext | null>(null)\n\n/**\n * 静态的编辑器对象\n * @returns\n */\nexport const useEditableStatic = (): Editable => {\n  const contenxt = React.useContext(EditableStoreContext)\n\n  if (!contenxt) {\n    throw new Error(\n      `The \\`useEditableStatic\\` hook must be used inside the <EditableProvider> component's context.`,\n    )\n  }\n\n  return contenxt.editor\n}\n\n/**\n * 实时变化的编辑器对象\n * @returns\n */\nexport const useEditable = (): Editable => {\n  const store = useEditableStore()\n\n  return useStore(store, state => {\n    return state.editor\n  })[0]\n}\n","import * as React from 'react'\nimport {\n  Editor,\n  Range,\n  Transforms,\n  Point,\n  Path,\n  Element,\n  DOMNode,\n  getDefaultView,\n  isDOMNode,\n} from '@editablejs/models'\n\nimport useChildren from '../hooks/use-children'\nimport { useEditable, useEditableStatic } from '../hooks/use-editable'\nimport { Editable } from '../plugin/editable'\nimport { useReadOnly } from '../hooks/use-read-only'\nimport { useIsomorphicLayoutEffect } from '../hooks/use-isomorphic-layout-effect'\nimport { inAbsoluteDOMElement } from '../utils/dom'\nimport {\n  EDITOR_TO_ELEMENT,\n  ELEMENT_TO_NODE,\n  NODE_TO_ELEMENT,\n  EDITOR_TO_WINDOW,\n  IS_SHIFT_PRESSED,\n  EDITOR_TO_SHADOW,\n  IS_MOUSEDOWN,\n  IS_TOUCHMOVING,\n  IS_TOUCHING,\n  IS_TOUCH_HOLD,\n} from '../utils/weak-maps'\nimport { useMultipleClick } from '../hooks/use-multiple-click'\nimport { Focused, useFocused } from '../hooks/use-focused'\nimport ShadowContainer from './shadow'\nimport { CaretComponent } from './caret'\nimport { SelectionComponent } from './selection'\nimport { InputComponent } from './input'\nimport { useDragging, useDragMethods, useDragTo } from '../hooks/use-drag'\nimport { SelectionDrawing, SelectionDrawingStyle } from '../plugin/selection-drawing'\nimport { APPLICATION_FRAGMENT_TYPE, DATA_EDITABLE_NODE } from '../utils/constants'\nimport { DragCaretComponent } from './drag-caret'\nimport { parseFragmentFromString, setDataTransfer } from '../utils/data-transfer'\nimport { Slots } from './slot'\nimport { Drag } from '../plugin/drag'\nimport { Placeholder } from '../plugin/placeholder'\nimport { usePlaceholder } from '../hooks/use-placeholder'\nimport { isTouchDevice } from '../utils/environment'\nimport { TouchPointComponent } from './touch-point'\nimport { getNativeEvent, isMouseEvent, isTouchEvent } from '../utils/event'\nimport { canForceTakeFocus, isEditableDOMElement } from '../utils/dom'\nimport { Locale } from '../plugin/locale'\n\nconst Children = (props: Omit<Parameters<typeof useChildren>[0], 'node' | 'selection'>) => {\n  const editor = useEditable()\n  return (\n    <React.Fragment>\n      {useChildren({ ...props, node: editor, selection: editor.selection })}\n    </React.Fragment>\n  )\n}\n\n/**\n * `EditableProps` are passed to the `<Editable>` component.\n */\nexport type EditableProps = {\n  readOnly?: boolean\n  lang?: string\n  autoFocus?: boolean\n  placeholder?: React.ReactNode\n  role?: string\n  style?: React.CSSProperties\n  as?: React.ElementType\n  selectionDrawingStyle?: SelectionDrawingStyle\n}\n\n/**\n * ContentEditable.\n */\nexport const ContentEditable = (props: EditableProps) => {\n  const {\n    autoFocus = true,\n    placeholder,\n    readOnly: readOnlyProp = false,\n    lang,\n    style = {},\n    as: Component = 'div',\n    selectionDrawingStyle: selectionDrawingStyleProp,\n    ...attributes\n  } = props\n  const editor = useEditableStatic()\n\n  const ref = React.useRef<HTMLDivElement>(null)\n  const [readOnly, setReadOnly] = useReadOnly()\n  // 标记是否是刚拖拽完毕\n  const isDragEnded = React.useRef(false)\n  const dragTo = useDragTo()\n  const dragging = useDragging()\n  const { getDrag, setDrag } = useDragMethods()\n\n  const [rendered, setRendered] = React.useState(false)\n\n  // Touch hold timer\n  const touchHoldTimer = React.useRef<number | null>(null)\n\n  React.useEffect(() => {\n    if (placeholder && !readOnly) {\n      const unsubscribe = Placeholder.subscribe(\n        editor,\n        ([node]) => {\n          if (Editable.isEditor(node) && !node.children.some(n => Editor.isList(editor, n)))\n            return () => placeholder\n        },\n        true,\n      )\n\n      return () => {\n        unsubscribe()\n      }\n    }\n  }, [editor, placeholder, readOnly])\n\n  useIsomorphicLayoutEffect(() => {\n    setReadOnly(readOnlyProp)\n  }, [readOnlyProp])\n\n  useIsomorphicLayoutEffect(() => {\n    Locale.setLang(editor, props.lang || 'en-US')\n  }, [editor, lang])\n\n  useIsomorphicLayoutEffect(() => {\n    if (selectionDrawingStyleProp) SelectionDrawing.setStyle(editor, selectionDrawingStyleProp)\n  }, [editor, selectionDrawingStyleProp])\n\n  const [focused, setFocused] = useFocused()\n\n  const startPointRef = React.useRef<Point | null>(null)\n  const isContextMenu = React.useRef(false)\n\n  const clearTouchHoldTimer = () => {\n    if (touchHoldTimer.current) clearTimeout(touchHoldTimer.current)\n  }\n\n  const handleDocumentMouseDown = (event: MouseEvent | TouchEvent) => {\n    const isMouseDown = IS_MOUSEDOWN.get(editor)\n    const isTouching = IS_TOUCHING.get(editor)\n    if (!isMouseDown && !isTouching && !event.defaultPrevented) setFocused(false)\n  }\n\n  const handleSelecting = (point: Point | null, rest = true, forceFocus = true) => {\n    if (!point) return\n    const { selection } = editor\n    if (!rest && selection && Range.includes(selection, point)) {\n      return\n    }\n    let anchor: Point | null = null\n\n    if (IS_TOUCHING.get(editor)) {\n      anchor = point\n    } else {\n      anchor = IS_SHIFT_PRESSED.get(editor) && selection ? selection.anchor : startPointRef.current\n    }\n    if (!anchor) return\n    const range: Range = { anchor, focus: point }\n    if (selection && forceFocus && Range.equals(range, selection)) {\n      editor.focus()\n      setFocused(true)\n      return true\n    }\n    Transforms.select(editor, range)\n    return range\n  }\n\n  const handleDocumentTouchEnd = (event: TouchEvent) => {\n    if (event.defaultPrevented) return\n    clearTouchHoldTimer()\n    // touch move 之后不会触发 mouse up 事件，所以需要在 touch end 时触发\n    if (IS_TOUCHMOVING.get(editor)) {\n      handleDocumentMouseUp(event)\n      IS_TOUCHING.set(editor, false)\n    } else if (IS_TOUCH_HOLD.get(editor)) {\n      IS_TOUCHING.set(editor, false)\n      IS_MOUSEDOWN.set(editor, false)\n      IS_TOUCH_HOLD.set(editor, false)\n      event.preventDefault()\n      editor.onTouchHold(event)\n    }\n  }\n\n  const handleDocumentMouseUp = (event: MouseEvent | TouchEvent) => {\n    const drag = getDrag()\n    const isMouseDown = IS_MOUSEDOWN.get(editor)\n    if (\n      drag ||\n      (IS_TOUCHING.get(editor) && !IS_TOUCH_HOLD.get(editor)) ||\n      (isMouseDown &&\n        (!event.defaultPrevented || (event instanceof MouseEvent && event.button === 2)))\n    ) {\n      if (focused && !isEditableDOMElement(event.target) && canForceTakeFocus()) {\n        editor.focus()\n      }\n      const point = Editable.findEventPoint(editor, event)\n      let isSelectedSame = false\n      if (point && drag) {\n        const { from, data, type = 'text' } = drag\n        const fromRange = Editor.range(editor, from)\n        if (!Range.includes(fromRange, point)) {\n          const fragment = parseFragmentFromString(data.getData(APPLICATION_FRAGMENT_TYPE))\n          if (type === 'block') {\n            const path = Drag.toBlockPath(editor)\n            if (path && fragment.length > 0) {\n              const rangeRef = Editor.rangeRef(editor, {\n                anchor: {\n                  path,\n                  offset: 0,\n                },\n                focus: {\n                  path,\n                  offset: 0,\n                },\n              })\n              Transforms.removeNodes(editor, { at: from })\n              const at = rangeRef.unref()\n              Transforms.insertNodes(editor, fragment, {\n                at: at?.anchor.path ?? path,\n                select: true,\n              })\n            }\n          } else {\n            const deleteAfterRange = Editor.rangeRef(editor, Editor.range(editor, point))\n            Transforms.delete(editor, {\n              at: from,\n              unit: 'line',\n              hanging: true,\n            })\n            const anchorRange = deleteAfterRange.unref()\n            Transforms.select(editor, anchorRange ?? point)\n            Transforms.insertFragment(editor, fragment)\n            const focus = editor.selection?.focus\n            if (anchorRange && focus) {\n              let anchor = anchorRange.anchor\n              const anchorElement = Editor.above(editor, {\n                at: anchorRange,\n                match: node => Element.isElement(node),\n                voids: true,\n              })\n\n              const nextPath = Path.next(anchor.path)\n\n              if (anchorElement && Editor.hasPath(editor, nextPath)) {\n                const nextRange = Editor.range(editor, nextPath)\n                const element = Editor.above(editor, {\n                  at: nextRange,\n                  match: node => Element.isElement(node),\n                  voids: true,\n                })\n                if (element && anchorElement[0] !== element[0]) {\n                  anchor = nextRange.anchor\n                }\n              }\n              Transforms.select(editor, {\n                anchor,\n                focus,\n              })\n            }\n          }\n\n          isDragEnded.current = true\n        } else {\n          Transforms.select(editor, point)\n        }\n      } else {\n        const { selection } = editor\n        if (\n          IS_TOUCHING.get(editor) &&\n          point &&\n          selection &&\n          isSelectedOnCurrentSelection(editor, selection, point)\n        ) {\n          isSelectedSame = true\n        } else {\n          // 是否选中在同一个位置\n          isSelectedSame =\n            handleSelecting(point, !isContextMenu.current, !isEditableDOMElement(event.target)) ===\n            true\n        }\n      }\n      // 修复 touch 时，触发了 mouse up 事件，导致无法触发 onSelectStart\n      if (IS_TOUCHING.get(editor) && !IS_TOUCH_HOLD.get(editor)) {\n        // touch 在同一个位置，触发 onTouchTrack\n        if (isSelectedSame) editor.onTouchTrack()\n        else editor.onSelectStart()\n      }\n      setDrag(null)\n      if (!isDragEnded.current && (!IS_TOUCHING.get(editor) || !isSelectedSame))\n        editor.onSelectEnd()\n    }\n\n    isContextMenu.current = false\n    startPointRef.current = null\n    IS_TOUCHMOVING.set(editor, false)\n    IS_TOUCHING.set(editor, false)\n    IS_MOUSEDOWN.set(editor, false)\n  }\n\n  const handleDocumentMouseMove = (event: MouseEvent | TouchEvent) => {\n    const darg = getDrag()\n    const isMouseDown = IS_MOUSEDOWN.get(editor)\n    // 未长按不触发 move 事件\n    if (IS_TOUCHING.get(editor) && !IS_TOUCH_HOLD.get(editor)) {\n      clearTouchHoldTimer()\n      return\n    }\n    const isTouchMoving = isTouchEvent(event)\n    IS_TOUCHMOVING.set(editor, isTouchMoving)\n\n    if (\n      !isTouchMoving &&\n      !darg &&\n      ((isMouseEvent(event) && event.button !== 0) ||\n        !isMouseDown ||\n        event.defaultPrevented ||\n        isContextMenu.current)\n    )\n      return\n    const point = event.defaultPrevented ? null : Editable.findEventPoint(editor, event)\n    if (point && dragging && isMouseEvent(event)) {\n      setDrag({\n        to: {\n          anchor: point,\n          focus: point,\n        },\n        position: {\n          x: event.clientX,\n          y: event.clientY,\n        },\n      })\n      return\n    }\n    // 阻止 touchmove 时页面滚动\n    if (isTouchMoving) event.preventDefault()\n    const range = handleSelecting(point)\n    if (range) editor.onSelecting()\n  }\n\n  const handleRootTouchStart = (event: React.TouchEvent) => {\n    if (event.defaultPrevented) return\n    if (\n      !event.target ||\n      !ref.current?.contains(event.target as DOMNode) ||\n      isEditableDOMElement(event.target) ||\n      inAbsoluteDOMElement(event.target)\n    )\n      return\n\n    const { selection } = editor\n\n    IS_TOUCHING.set(editor, true)\n    IS_TOUCH_HOLD.set(editor, false)\n    clearTouchHoldTimer()\n    // touch hold\n    touchHoldTimer.current = setTimeout(() => {\n      IS_TOUCH_HOLD.set(editor, true)\n\n      if (Focused.is(editor)) {\n        handleRootMouseDown(event)\n      } else if (!selection || Range.isCollapsed(selection)) {\n        IS_TOUCHING.set(editor, false)\n        const point = Editable.findEventPoint(editor, event)\n        if (point)\n          editor.selectWord({\n            at: {\n              anchor: point,\n              focus: point,\n            },\n          })\n      }\n    }, 530)\n  }\n\n  const handleRootMouseDown = (e: React.MouseEvent | React.TouchEvent) => {\n    const event = getNativeEvent(e)\n    if (e.defaultPrevented && isMouseEvent(event) && event.button !== 2) return\n    if (\n      !event.target ||\n      !ref.current?.contains(event.target as DOMNode) ||\n      isEditableDOMElement(event.target) ||\n      inAbsoluteDOMElement(event.target)\n    )\n      return\n\n    IS_MOUSEDOWN.set(editor, true)\n    if (isDoubleClickRef.current) {\n      if (isSamePoint(event)) {\n        return\n      } else {\n        isDoubleClickRef.current = false\n      }\n    }\n    setFocused(true)\n    const point = Editable.findEventPoint(editor, event)\n    if (point) {\n      const isShift = IS_SHIFT_PRESSED.get(editor)\n      if (!isShift) {\n        const { selection } = editor\n        if (event instanceof MouseEvent && event.button === 2) {\n          isContextMenu.current = true\n        }\n        // Perform drag on existing selection while selected.\n        else if (\n          selection &&\n          focused &&\n          isSelectedOnCurrentSelection(editor, selection, point, isTouchDevice)\n        ) {\n          // Drag not performed on touch devices.\n          if (!isTouchDevice) {\n            const dataTransfer = new DataTransfer()\n            setDataTransfer(dataTransfer, {\n              fragment: editor.getFragment(selection),\n            })\n            setDrag({\n              from: selection,\n              data: dataTransfer,\n              position: {\n                x: event.clientX,\n                y: event.clientY,\n              },\n            })\n            editor.onSelectStart()\n          }\n          return\n        }\n        startPointRef.current = point\n      }\n      const range = handleSelecting(\n        point,\n        !isContextMenu.current,\n        !isEditableDOMElement(event.target),\n      )\n      if (range) editor.onSelectStart()\n    } else startPointRef.current = null\n  }\n\n  const handleRootMouseUp = () => {\n    startPointRef.current = null\n  }\n\n  const isDoubleClickRef = React.useRef(false)\n  const isDoubleClickTimerRef = React.useRef<number>()\n  const { handleMultipleClick, isSamePoint } = useMultipleClick({\n    onClick: () => {\n      isDoubleClickRef.current = false\n    },\n    onMultipleClick: (event, count) => {\n      const { selection } = editor\n      if (!selection || event.defaultPrevented) return\n      event.preventDefault()\n      const container = Editable.toDOMNode(editor, editor)\n      if (isDOMNode(event.target) && !container.contains(event.target)) return\n      const isCollapsed = Range.isCollapsed(selection)\n      if (count === 1 && !isCollapsed) {\n        return false\n      } else if (count === 2) {\n        editor.selectWord()\n        isDoubleClickRef.current = true\n        if (isDoubleClickTimerRef.current) clearTimeout(isDoubleClickTimerRef.current)\n        isDoubleClickTimerRef.current = setTimeout(() => {\n          isDoubleClickRef.current = false\n        }, 500)\n        return\n      } else if (count === 3) {\n        editor.selectLine()\n        isDoubleClickRef.current = false\n        return false\n      }\n    },\n  })\n\n  const [awaitUpdateDrawingSelection, setAwaitUpdateDrawingSelection] = React.useState(\n    editor.selection,\n  )\n\n  useIsomorphicLayoutEffect(() => {\n    const handleChange = () => {\n      const { selection } = editor\n      setAwaitUpdateDrawingSelection(selection ? Object.assign({}, selection) : null)\n    }\n    editor.on('change', handleChange)\n\n    const handleShift = (event: KeyboardEvent) => {\n      if (event.key.toLowerCase() === 'shift') {\n        IS_SHIFT_PRESSED.set(editor, false)\n      }\n    }\n\n    let window: Window | null = null\n    if (ref.current && (window = getDefaultView(ref.current))) {\n      EDITOR_TO_WINDOW.set(editor, window)\n      EDITOR_TO_ELEMENT.set(editor, ref.current)\n      NODE_TO_ELEMENT.set(editor, ref.current)\n      ELEMENT_TO_NODE.set(ref.current, editor)\n      setRendered(true)\n\n      window.addEventListener('keyup', handleShift)\n      window.addEventListener('mousedown', handleDocumentMouseDown)\n      window.addEventListener('mouseup', handleDocumentMouseUp)\n      if (isTouchDevice) {\n        window.addEventListener('touchend', handleDocumentTouchEnd)\n        window.addEventListener('touchmove', handleDocumentMouseMove, { passive: false })\n      } else {\n        window.addEventListener('mousemove', handleDocumentMouseMove)\n      }\n    } else {\n      NODE_TO_ELEMENT.delete(editor)\n    }\n\n    return () => {\n      editor.off('change', handleChange)\n      window?.removeEventListener('keyup', handleShift)\n      window?.removeEventListener('mousedown', handleDocumentMouseDown)\n      window?.removeEventListener('mouseup', handleDocumentMouseUp)\n      if (isTouchDevice) {\n        window?.removeEventListener('touchend', handleDocumentTouchEnd)\n        window?.removeEventListener('touchmove', handleDocumentMouseMove)\n      } else {\n        window?.removeEventListener('mousemove', handleDocumentMouseMove)\n      }\n    }\n  }, [editor, handleDocumentMouseDown, handleDocumentMouseMove, handleDocumentMouseUp])\n\n  React.useEffect(() => {\n    // 在拖拽完成后触发onSelectEnd，否则内容可能还未渲染完毕\n    if (isDragEnded.current) {\n      editor.onSelectEnd()\n      isDragEnded.current = false\n    }\n  }, [awaitUpdateDrawingSelection, editor])\n\n  useIsomorphicLayoutEffect(() => {\n    SelectionDrawing.setSelection(editor, awaitUpdateDrawingSelection)\n  }, [awaitUpdateDrawingSelection])\n\n  // 处理文件拖拽\n  const handleDragOver = (event: React.DragEvent) => {\n    event.preventDefault()\n    if (readOnly) return\n    const point = Editable.findEventPoint(editor, event)\n    if (point) {\n      const dragRange = {\n        anchor: point,\n        focus: point,\n      }\n      const position = {\n        x: event.clientX,\n        y: event.clientY,\n      }\n      if (!dragging) {\n        setDrag({\n          type: 'text',\n          from: dragRange,\n          data: event.dataTransfer,\n        })\n      }\n      setDrag({\n        position,\n        to: dragRange,\n      })\n    }\n  }\n\n  const handleDrop = (event: React.DragEvent) => {\n    event.preventDefault()\n    event.stopPropagation()\n    setDrag(null)\n    if (readOnly) return\n    const point = Editable.findEventPoint(editor, event)\n    if (point) {\n      Transforms.select(editor, point)\n      const clipboardEvent = new ClipboardEvent('paset', { clipboardData: event.dataTransfer })\n      editor.onPaste(clipboardEvent)\n    }\n  }\n\n  const handleContextMenu = (event: React.MouseEvent) => {\n    if (!isTouchDevice) editor.onContextMenu(event.nativeEvent)\n  }\n\n  const cursor = React.useMemo(() => {\n    if (dragging && dragTo) {\n      return 'default'\n    }\n    return 'text'\n  }, [dragTo, dragging])\n\n  const renderPlaceholder = usePlaceholder(editor)\n\n  const handleAnchorTouchPointStart = React.useCallback(\n    (event: React.TouchEvent) => {\n      event.stopPropagation()\n      const { selection } = editor\n      if (!selection) return\n      startPointRef.current = Range.end(selection)\n      IS_MOUSEDOWN.set(editor, true)\n      editor.onSelectStart()\n    },\n    [editor],\n  )\n\n  const handleFocusTouchPointStart = React.useCallback(\n    (event: React.TouchEvent) => {\n      event.stopPropagation()\n      const { selection } = editor\n      if (!selection) return\n      startPointRef.current = Range.start(selection)\n      IS_MOUSEDOWN.set(editor, true)\n      editor.onSelectStart()\n    },\n    [editor],\n  )\n\n  return (\n    <div\n      style={{\n        ...style,\n        position: 'relative',\n      }}\n    >\n      <Component\n        role={readOnly ? undefined : 'textbox'}\n        {...attributes}\n        {...{ [DATA_EDITABLE_NODE]: 'editor' }}\n        zindex={-1}\n        ref={ref}\n        style={{\n          // Prevent the default outline styles.\n          outline: 'none',\n          // Preserve adjacent whitespace and new lines.\n          whiteSpace: 'pre-wrap',\n          // Allow words to break if they are too long.\n          wordBreak: 'break-word',\n          // Disable the default user-select behavior.\n          userSelect: 'none',\n          // Set cursor to text.\n          cursor,\n          //\n          overflowWrap: 'break-word',\n        }}\n        onTouchStart={isTouchDevice ? handleRootTouchStart : undefined}\n        onMouseDown={isTouchDevice ? undefined : handleRootMouseDown}\n        onMouseUp={handleRootMouseUp}\n        onClick={handleMultipleClick}\n        onDragOver={handleDragOver}\n        onDrop={handleDrop}\n        onContextMenu={handleContextMenu}\n      >\n        <Children renderPlaceholder={renderPlaceholder} />\n      </Component>\n      <ShadowContainer ref={current => EDITOR_TO_SHADOW.set(editor, current)}>\n        <CaretComponent />\n        <DragCaretComponent />\n        <SelectionComponent />\n        <InputComponent autoFocus={autoFocus} />\n      </ShadowContainer>\n      <TouchPointComponent\n        onAnchorTouchStart={handleAnchorTouchPointStart}\n        onFocusTouchStart={handleFocusTouchPointStart}\n      />\n      {rendered && <Slots />}\n    </div>\n  )\n}\n\nconst isSelectedOnCurrentSelection = (\n  editor: Editor,\n  selection: Range,\n  point: Point,\n  compareOnCollapsed = false,\n) => {\n  return (\n    (Range.includes(selection, point) &&\n      ((!Point.equals(Range.end(selection), point) &&\n        !Point.equals(Range.start(selection), point)) ||\n        (Range.isCollapsed(selection) &&\n          !!Editor.above(editor, { match: n => Editor.isVoid(editor, n) })))) ||\n    (compareOnCollapsed &&\n      Range.isCollapsed(selection) &&\n      Point.equals(Range.start(selection), point))\n  )\n}\n","import { Editor, Range, Element, Ancestor, Descendant } from '@editablejs/models'\n\nimport ElementComponent from '../components/element'\nimport TextComponent from '../components/text'\nimport { Editable } from '../plugin/editable'\nimport { useEditableStatic } from './use-editable'\nimport { NODE_TO_INDEX, NODE_TO_PARENT } from '../utils/weak-maps'\nimport { NodeSelectedContext } from './use-node-selected'\nimport { NodeFocusedContext } from './use-node-focused'\nimport { GridContext } from './use-grid'\nimport { PlaceholderRender } from '../plugin/placeholder'\n\n/**\n * Children.\n */\nconst useChildren = (props: {\n  node: Ancestor\n  selection: Range | null\n  renderPlaceholder?: PlaceholderRender\n}) => {\n  const { node, selection, renderPlaceholder } = props\n  const editor = useEditableStatic()\n  const path = Editable.findPath(editor, node)\n  const children = []\n  const isLeafBlock =\n    Element.isElement(node) && !editor.isInline(node) && Editor.hasInlines(editor, node)\n\n  for (let i = 0; i < node.children.length; i++) {\n    const p = path.concat(i)\n    const n = node.children[i] as Descendant\n    const key = Editable.findKey(editor, n)\n    const range = Editor.range(editor, p)\n    const sel = selection && Range.intersection(range, selection)\n    const focused =\n      selection && Range.includes(range, selection.anchor) && Range.includes(range, selection.focus)\n\n    if (Element.isElement(n)) {\n      const element = (\n        <NodeSelectedContext.Provider key={`selected-provider-${key.id}`} value={!!sel}>\n          <NodeFocusedContext.Provider key={`focused-provider-${key.id}`} value={focused ?? false}>\n            <ElementComponent\n              element={n}\n              key={key.id}\n              selection={sel}\n              renderPlaceholder={renderPlaceholder}\n            />\n          </NodeFocusedContext.Provider>\n        </NodeSelectedContext.Provider>\n      )\n      if (Editor.isGrid(editor, n)) {\n        children.push(\n          <GridContext.Provider key={`grid-provider-${key.id}`} value={n}>\n            {element}\n          </GridContext.Provider>,\n        )\n      } else {\n        children.push(element)\n      }\n    } else {\n      children.push(\n        <TextComponent\n          renderPlaceholder={renderPlaceholder}\n          key={key.id}\n          isLast={isLeafBlock && i === node.children.length - 1}\n          parent={node}\n          text={n}\n        />,\n      )\n    }\n\n    NODE_TO_INDEX.set(n, i)\n    NODE_TO_PARENT.set(n, node)\n  }\n\n  return children\n}\n\nexport default useChildren\n","import * as React from 'react'\nimport getDirection from 'direction'\nimport { Editor, Node, Range, Element as SlateElement } from '@editablejs/models'\n\nimport Text from './text'\nimport useChildren from '../hooks/use-children'\nimport { Editable, useEditableStatic, ElementAttributes } from '..'\nimport { useIsomorphicLayoutEffect } from '../hooks/use-isomorphic-layout-effect'\nimport {\n  NODE_TO_ELEMENT,\n  ELEMENT_TO_NODE,\n  NODE_TO_PARENT,\n  NODE_TO_INDEX,\n  EDITOR_TO_KEY_TO_ELEMENT,\n} from '../utils/weak-maps'\nimport { DATA_EDITABLE_INLINE, DATA_EDITABLE_NODE, DATA_EDITABLE_VOID } from '../utils/constants'\nimport { useElementDecorations } from '../hooks/use-decorate'\nimport { PlaceholderRender } from '../plugin/placeholder'\nimport { usePlaceholder } from '../hooks/use-placeholder'\n\n/**\n * Element.\n */\nconst Element = (props: {\n  element: SlateElement\n  selection: Range | null\n  renderPlaceholder?: PlaceholderRender\n}) => {\n  const { element, selection, renderPlaceholder } = props\n  const ref = React.useRef<HTMLElement>(null)\n  const editor = useEditableStatic()\n  const isInline = editor.isInline(element)\n  const key = Editable.findKey(editor, element)\n\n  const currentRenderPlaceholder = usePlaceholder(element)\n  let children: React.ReactNode = useChildren({\n    node: element,\n    selection,\n    renderPlaceholder: Editor.isEmpty(editor, element)\n      ? currentRenderPlaceholder ?? renderPlaceholder\n      : undefined,\n  })\n\n  // Attributes that the developer must mix into the element in their\n  // custom node renderer component.\n  const attributes: ElementAttributes = {\n    [DATA_EDITABLE_NODE]: 'element',\n    ref,\n  }\n\n  if (isInline) {\n    attributes[DATA_EDITABLE_INLINE] = true\n  }\n\n  // If it's a block node with inline children, add the proper `dir` attribute\n  // for text direction.\n  if (!isInline && Editor.hasInlines(editor, element)) {\n    const text = Node.string(element)\n    const dir = getDirection(text)\n\n    if (dir === 'rtl') {\n      attributes.dir = dir\n    }\n  }\n\n  // If it's a void node, wrap the children in extra void-specific elements.\n  if (Editor.isVoid(editor, element)) {\n    attributes[DATA_EDITABLE_VOID] = true\n\n    const Tag = isInline ? 'span' : 'div'\n    const [[text]] = Node.texts(element)\n\n    children = (\n      <Tag\n        style={{\n          height: '0',\n          color: 'transparent',\n          outline: 'none',\n        }}\n      >\n        <Text\n          renderPlaceholder={renderPlaceholder ?? currentRenderPlaceholder}\n          isLast={false}\n          parent={element}\n          text={text}\n        />\n      </Tag>\n    )\n\n    NODE_TO_INDEX.set(text, 0)\n    NODE_TO_PARENT.set(text, element)\n  }\n\n  // Update element-related weak maps with the DOM element ref.\n  useIsomorphicLayoutEffect(() => {\n    const KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor)\n    if (ref.current) {\n      KEY_TO_ELEMENT?.set(key, ref.current)\n      NODE_TO_ELEMENT.set(element, ref.current)\n      ELEMENT_TO_NODE.set(ref.current, element)\n    } else {\n      KEY_TO_ELEMENT?.delete(key)\n      NODE_TO_ELEMENT.delete(element)\n    }\n  })\n  const path = Editable.findPath(editor, element)\n\n  const newAttributes = editor.renderElementAttributes({ attributes, element })\n\n  let content = editor.renderElement({ attributes: newAttributes, children, element })\n\n  const decorates = useElementDecorations(element, path)\n\n  if (decorates.length > 0) {\n    content = decorates.reduceRight((children, decorate) => {\n      return decorate.renderElement({\n        node: element,\n        path,\n        children,\n      })\n    }, content)\n  }\n\n  return content\n}\n\nconst MemoizedElement = React.memo(Element, (prev, next) => {\n  return (\n    prev.element === next.element &&\n    prev.renderPlaceholder === next.renderPlaceholder &&\n    (prev.selection === next.selection ||\n      (!!prev.selection && !!next.selection && Range.equals(prev.selection, next.selection)))\n  )\n})\n\nexport default MemoizedElement\n","import * as React from 'react'\nimport { Element, Text as SlateText } from '@editablejs/models'\n\nimport Leaf from './leaf'\nimport { useIsomorphicLayoutEffect } from '../hooks/use-isomorphic-layout-effect'\nimport { NODE_TO_ELEMENT, ELEMENT_TO_NODE, EDITOR_TO_KEY_TO_ELEMENT } from '../utils/weak-maps'\nimport { useEditableStatic } from '../hooks/use-editable'\nimport { Editable } from '../plugin/editable'\nimport { DATA_EDITABLE_NODE } from '../utils/constants'\nimport { useTextDecorations } from '../hooks/use-decorate'\nimport { PlaceholderRender } from '../plugin/placeholder'\n\n/**\n * Text.\n */\nconst Text = (props: {\n  isLast: boolean\n  parent: Element\n  text: SlateText\n  renderPlaceholder?: PlaceholderRender\n}) => {\n  const { isLast, parent, text, renderPlaceholder } = props\n  const editor = useEditableStatic()\n  const ref = React.useRef<HTMLSpanElement>(null)\n  const key = Editable.findKey(editor, text)\n  const path = Editable.findPath(editor, text)\n  const decorates = useTextDecorations(text, path).map((d, index) => ({\n    ...d,\n    key: `__decorate__${index}`,\n  }))\n\n  const ranges = decorates\n    .map(({ ranges, key }) => ranges.map(range => ({ ...range, [key]: true })))\n    .flat()\n  const leaves = SlateText.decorations(text, ranges)\n\n  const decorateKeys = decorates.map(d => d.key)\n  const children = []\n  for (let i = 0; i < leaves.length; i++) {\n    const leaf = leaves[i]\n    let content = (\n      <Leaf\n        renderPlaceholder={renderPlaceholder}\n        isLast={isLast && i === leaves.length - 1}\n        key={`${key.id}-${i}`}\n        text={text}\n        leaf={leaf}\n        parent={parent}\n      />\n    )\n    for (const key of decorateKeys) {\n      if (key in leaf) {\n        const dec = decorates[decorateKeys.indexOf(key)].decorate.renderText({\n          node: text,\n          path,\n          children: content,\n        })\n        content = React.cloneElement(dec, { key })\n      }\n    }\n    children.push(content)\n  }\n  // Update element-related weak maps with the DOM element ref.\n  useIsomorphicLayoutEffect(() => {\n    const KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor)\n    if (ref.current) {\n      KEY_TO_ELEMENT?.set(key, ref.current)\n      NODE_TO_ELEMENT.set(text, ref.current)\n      ELEMENT_TO_NODE.set(ref.current, text)\n    } else {\n      KEY_TO_ELEMENT?.delete(key)\n      NODE_TO_ELEMENT.delete(text)\n    }\n  })\n\n  return (\n    <span {...{ [DATA_EDITABLE_NODE]: 'text' }} ref={ref}>\n      {children}\n    </span>\n  )\n}\n\nconst MemoizedText = React.memo(Text, (prev, next) => {\n  return (\n    next.parent === prev.parent &&\n    next.isLast === prev.isLast &&\n    next.text === prev.text &&\n    prev.renderPlaceholder === next.renderPlaceholder\n  )\n})\n\nexport default MemoizedText\n","import * as React from 'react'\nimport { Element, Text } from '@editablejs/models'\nimport String from './string'\nimport { useEditableStatic } from '../hooks/use-editable'\nimport { TextAttributes } from '../plugin/editable'\nimport { DATA_EDITABLE_LEAF, DATA_EDITABLE_PLACEHOLDER } from '../utils/constants'\nimport { PlaceholderRender } from '../plugin/placeholder'\n\n/**\n * Individual leaves in a text node with unique formatting.\n */\nconst Leaf = (props: {\n  isLast: boolean\n  parent: Element\n  leaf: Text\n  text: Text\n  renderPlaceholder?: PlaceholderRender\n}) => {\n  const { isLast, text, leaf, parent, renderPlaceholder } = props\n\n  let children = <String isLast={isLast} parent={parent} text={text} leaf={leaf} />\n\n  const editor = useEditableStatic()\n  if (renderPlaceholder) {\n    const placeholderComponent = editor.renderPlaceholder({\n      attributes: { [DATA_EDITABLE_PLACEHOLDER]: true },\n      node: text,\n      children: renderPlaceholder({ node: text }),\n    })\n    if (placeholderComponent)\n      children = (\n        <React.Fragment>\n          {placeholderComponent}\n          {children}\n        </React.Fragment>\n      )\n  }\n\n  // COMPAT: Having the `data-` attributes on these leaf elements ensures that\n  // in certain misbehaving browsers they aren't weirdly cloned/destroyed by\n  // contenteditable behaviors. (2019/05/08)\n  const attributes: TextAttributes = {\n    [DATA_EDITABLE_LEAF]: true,\n  }\n  const newAttributes = editor.renderLeafAttributes({ attributes, text })\n  return editor.renderLeaf({ attributes: newAttributes, children, text })\n}\n\nconst MemoizedLeaf = React.memo(Leaf, (prev, next) => {\n  return (\n    next.parent === prev.parent &&\n    prev.renderPlaceholder === next.renderPlaceholder &&\n    next.isLast === prev.isLast &&\n    next.text === prev.text\n  )\n})\n\nexport default MemoizedLeaf\n","import * as React from 'react'\nimport { Editor, Text, Path, Element, Node, CompositionText } from '@editablejs/models'\n\nimport { Editable } from '../plugin/editable'\nimport { useEditableStatic } from '../hooks/use-editable'\nimport {\n  DATA_EDITABLE_COMPOSITION,\n  DATA_EDITABLE_LENGTH,\n  DATA_EDITABLE_STRING,\n  DATA_EDITABLE_ZERO_WIDTH,\n} from '../utils/constants'\n\n/**\n * Leaf content strings.\n */\nconst String: React.FC<{\n  isLast: boolean\n  parent: Element\n  text: Text\n\n  leaf: Text\n}> = props => {\n  const { isLast, parent, text, leaf } = props\n  const editor = useEditableStatic()\n  const path = Editable.findPath(editor, text)\n  const parentPath = Path.parent(path)\n\n  // COMPAT: Render text inside void nodes with a zero-width space.\n  // So the node can contain selection but the text is not visible.\n  if (editor.isVoid(parent)) {\n    return <ZeroWidthString length={Node.string(parent).length} />\n  }\n\n  if (CompositionText.isCompositionText(text)) {\n    const { offset, text: compositionText } = text.composition\n    const content = text.text\n    const left = content.substring(0, offset)\n    const right = content.substring(offset)\n    return (\n      <>\n        {left && <TextString text={left} />}\n        <CompositionString text={compositionText} />\n        {right && <TextString text={right} />}\n      </>\n    )\n  }\n  // COMPAT: If this is the last text node in an empty block, render a zero-\n  // width space that will convert into a line break when copying and pasting\n  // to support expected plain text.\n  if (\n    leaf.text === '' &&\n    parent.children[parent.children.length - 1] === text &&\n    !editor.isInline(parent) &&\n    Editor.string(editor, parentPath) === ''\n  ) {\n    return <ZeroWidthString isLineBreak />\n  }\n\n  // COMPAT: If the text is empty, it's because it's on the edge of an inline\n  // node, so we render a zero-width space so that the selection can be\n  // inserted next to it still.\n  if (leaf.text === '') {\n    return <ZeroWidthString />\n  }\n\n  // COMPAT: Browsers will collapse trailing new lines at the end of blocks,\n  // so we need to add an extra trailing new lines to prevent that.\n  if (isLast && leaf.text.slice(-1) === '\\n') {\n    return <TextString isTrailing text={leaf.text} />\n  }\n  return <TextString text={leaf.text} />\n}\n\n/**\n * Leaf strings with text in them.\n */\nconst TextString = (props: { text: string; isTrailing?: boolean }) => {\n  const { text, isTrailing = false } = props\n\n  const getTextContent = () => {\n    return `${text ?? ''}${isTrailing ? '\\n' : ''}`\n  }\n\n  return <span {...{ [DATA_EDITABLE_STRING]: true }}>{getTextContent()}</span>\n}\n\nconst CompositionString = (props: { text: string }) => {\n  const { text } = props\n  return <u {...{ [DATA_EDITABLE_COMPOSITION]: true }}>{text}</u>\n}\n\n/**\n * Leaf strings without text, render as zero-width strings.\n */\n\nconst ZeroWidthString = (props: { length?: number; isLineBreak?: boolean }) => {\n  const { length = 0, isLineBreak = false } = props\n  return (\n    <span\n      {...{ [DATA_EDITABLE_ZERO_WIDTH]: isLineBreak ? 'n' : 'z', [DATA_EDITABLE_LENGTH]: length }}\n    >\n      {'\\uFEFF'}\n      {isLineBreak ? <br /> : null}\n    </span>\n  )\n}\n\nexport default String\n","import {\n  Editor,\n  Node,\n  Text,\n  Element,\n  Path,\n  Point,\n  Range,\n  Scrubber,\n  Transforms,\n  SelectionEdge,\n  Key,\n  DOMElement,\n  DOMNode,\n  DOMPoint,\n  DOMRange,\n  DOMSelection,\n  DOMStaticRange,\n  isDOMElement,\n  isDOMSelection,\n  isDOMNode,\n  isDOMText,\n} from '@editablejs/models'\n\nimport {\n  EDITOR_TO_ELEMENT,\n  ELEMENT_TO_NODE,\n  NODE_TO_INDEX,\n  NODE_TO_KEY,\n  NODE_TO_PARENT,\n  EDITOR_TO_WINDOW,\n  EDITOR_TO_KEY_TO_ELEMENT,\n  IS_COMPOSING,\n  NODE_TO_ELEMENT,\n} from '../utils/weak-maps'\nimport { normalizeDOMPoint, hasShadowRoot } from '../utils/dom'\nimport { IS_CHROME, IS_FIREFOX } from '../utils/environment'\nimport findNearbyNodes, { isAlignY } from '../utils/nearby'\nimport { getTextOffset } from '../utils/text'\nimport { getLineRectsByNode, getLineRectsByRange } from '../utils/selection'\nimport { Focused } from '../hooks/use-focused'\nimport { EventHandler, EventType } from './event'\nimport {\n  DATA_EDITABLE_COMPOSITION,\n  DATA_EDITABLE_INLINE,\n  DATA_EDITABLE_LEAF,\n  DATA_EDITABLE_LENGTH,\n  DATA_EDITABLE_NODE,\n  DATA_EDITABLE_PLACEHOLDER,\n  DATA_EDITABLE_STRING,\n  DATA_EDITABLE_VOID,\n  DATA_EDITABLE_ZERO_WIDTH,\n} from '../utils/constants'\nimport { getNativeEvent, isTouch } from '../utils/event'\nimport { ReadOnly } from '../hooks/use-read-only'\nimport scrollIntoView from 'scroll-into-view-if-needed'\n\nexport type BaseAttributes = Omit<React.HTMLAttributes<HTMLElement>, 'children'>\n\nexport interface ElementAttributes<T extends any = any> extends BaseAttributes {\n  [DATA_EDITABLE_NODE]: 'element'\n  [DATA_EDITABLE_INLINE]?: true\n  [DATA_EDITABLE_VOID]?: true\n  dir?: 'rtl'\n  ref: React.MutableRefObject<T>\n}\n\nexport interface TextAttributes extends BaseAttributes {\n  [DATA_EDITABLE_LEAF]?: true\n}\n\nexport type NodeAttributes = ElementAttributes | TextAttributes\n\nexport interface PlaceholderAttributes extends BaseAttributes {\n  [DATA_EDITABLE_PLACEHOLDER]: true\n}\n\nexport interface RenderElementAttributes<T extends Element = Element> {\n  element: T\n  attributes: ElementAttributes\n}\n\nexport interface RenderLeafAttributes<T extends Text = Text> {\n  text: T\n  attributes: TextAttributes\n}\n\n/**\n * `RenderElementProps` are passed to the `renderElement` handler.\n */\nexport interface RenderElementProps<T extends Element = Element, R extends any = any> {\n  children: any\n  element: T\n  attributes: ElementAttributes<R>\n}\n\n/**\n * `RenderLeafProps` are passed to the `renderLeaf` handler.\n */\nexport interface RenderLeafProps<T extends Text = Text> {\n  children: any\n  text: T\n  attributes: TextAttributes\n}\n\nexport interface RenderPlaceholderProps<T extends Node = Node> {\n  children: any\n  attributes: PlaceholderAttributes\n  node: T\n}\n\nexport interface SerializeHtmlOptions {\n  node: Node\n  attributes?: Record<string, any>\n  styles?: Record<string, any>\n}\n\nexport interface DeserializeHtmlOptions {\n  node: DOMNode\n  attributes?: Record<string, any>\n  markAttributes?: Record<string, any>\n  stripBreak?: true | ((text: string) => boolean)\n}\n\nexport interface SelectWordOptions {\n  at?: Range\n  edge?: SelectionEdge\n}\n\n/**\n * A React and DOM-specific version of the `Editor` interface.\n */\nexport interface Editable extends Editor {\n  blur(): void\n  focus(start?: boolean): void\n  copy(range?: Range): void\n  cut(range?: Range): void\n  selectWord: (options?: SelectWordOptions) => void\n  selectLine: (options?: SelectWordOptions) => void\n  insertFromClipboard(at?: Range): void\n  insertTextFromClipboard(at?: Range): void\n  insertFile(file: File, at?: Range): void\n  on: <T extends EventType>(type: T, handler: EventHandler<T>, prepend?: boolean) => void\n  once: <T extends EventType>(type: T, handler: EventHandler<T>, prepend?: boolean) => void\n  off: <T extends EventType>(type: T, handler: EventHandler<T>) => void\n  emit: <T extends EventType>(type: T, ...args: Parameters<EventHandler<T>>) => void\n  onKeydown: (event: KeyboardEvent) => void\n  onKeyup: (event: KeyboardEvent) => void\n  onFocus: () => void\n  onBlur: () => void\n  onPaste: (event: ClipboardEvent) => void\n  onCut: (event: ClipboardEvent) => void\n  onCopy: (event: ClipboardEvent) => void\n  onInput: (value: string) => void\n  onBeforeInput: (value: string) => void\n  onCompositionStart: (value: string) => void\n  onCompositionEnd: (value: string) => void\n  onSelectStart: () => void\n  onSelecting: () => void\n  onSelectEnd: () => void\n  onSelectionChange: () => void\n  onTouchHold: (event: TouchEvent) => void\n  onTouchTrack: () => void\n  onContextMenu: (event: MouseEvent) => void\n  onDestory: () => void\n  renderElementAttributes: (props: RenderElementAttributes) => ElementAttributes\n  renderLeafAttributes: (props: RenderLeafAttributes) => TextAttributes\n  renderElement: (props: RenderElementProps) => JSX.Element\n  renderLeaf: (props: RenderLeafProps) => JSX.Element\n  renderPlaceholder: (props: RenderPlaceholderProps) => JSX.Element | void | null\n  toDataTransfer: (range?: Range) => DataTransfer | null\n}\n\nexport const Editable = {\n  isEditor(value: any): value is Editable {\n    return !!value && Editor.isEditor(value) && 'onSelectionChange' in value\n  },\n  /**\n   * Check if the user is currently composing inside the editor.\n   */\n  isComposing(editor: Editor): boolean {\n    return !!IS_COMPOSING.get(editor)\n  },\n\n  /**\n   * 获取在选区内选中一行内容的节点以及所在行的索引\n   * @param editor\n   * @param options\n   * @returns\n   */\n  getSelectLine(\n    editor: Editor,\n    options: { range?: Range; match?: (element: Element) => boolean } = {},\n  ): [Element, number] | undefined {\n    const { range = editor.selection, match = () => true } = options\n    if (!range || Range.isCollapsed(range)) return\n    const start = Range.start(range)\n    const entry = Editor.above(editor, { at: start, match: n => Editor.isBlock(editor, n) })\n    if (!entry) return\n    const rangeLines = getLineRectsByRange(editor, range)\n    let [block, path] = entry\n    while (block) {\n      if (match(block)) {\n        const elLines = getLineRectsByNode(editor, block)\n        for (const rangeLine of rangeLines) {\n          const index = elLines.findIndex(\n            elLine =>\n              elLine.left === rangeLine.left &&\n              elLine.top === rangeLine.top &&\n              elLine.width === rangeLine.width,\n          )\n          if (~index) {\n            return [block, index]\n          }\n        }\n      }\n      const next = Editor.next(editor, { at: path, match: n => Editor.isBlock(editor, n) })\n      if (!next) return\n      const [n, p] = next\n      block = n as Element\n      path = p\n    }\n    return\n  },\n  /**\n   * 检查选区是否选中在内容一行的开始或者结尾\n   * @param editor\n   * @param options\n   * @returns\n   */\n  isSelectLineEdge(editor: Editor, options: { point?: Point; edge?: SelectionEdge } = {}): boolean {\n    const { point = editor.selection?.focus, edge = 'start' } = options\n    if (!point) return false\n    const entry = Editor.above(editor, { at: point, match: n => Editor.isBlock(editor, n) })\n    if (!entry) return false\n    const [block] = entry\n    const rangeLines = getLineRectsByRange(editor, { anchor: point, focus: point })\n    if (rangeLines.length === 0) return false\n    const rangeLine = rangeLines[0]\n    const lines = getLineRectsByNode(editor, block)\n    for (const line of lines) {\n      if (\n        ~['start', 'anchor'].indexOf(edge) &&\n        line.left === rangeLine.left &&\n        line.top === rangeLine.top\n      ) {\n        return true\n      } else if (\n        ~['end', 'focus'].indexOf(edge) &&\n        line.right === rangeLine.right &&\n        line.top === rangeLine.top\n      ) {\n        return true\n      }\n    }\n    return false\n  },\n\n  /**\n   * Return the host window of the current editor.\n   */\n  getWindow(editor: Editor): Window {\n    const window = EDITOR_TO_WINDOW.get(editor)\n    if (!window) {\n      throw new Error('Unable to find a host window element for this editor')\n    }\n    return window\n  },\n\n  /**\n   * Find a key for a Editor node.\n   */\n\n  findKey(editor: Editor, node: Node): Key {\n    let key = NODE_TO_KEY.get(node)\n\n    if (!key) {\n      key = new Key()\n      NODE_TO_KEY.set(node, key)\n    }\n\n    return key\n  },\n\n  /**\n   * Find the path of Editor node.\n   */\n\n  findPath(editor: Editor, node: Node): Path {\n    const path: Path = []\n    let child = node\n\n    while (true) {\n      const parent = NODE_TO_PARENT.get(child)\n\n      if (parent == null) {\n        if (Editor.isEditor(child)) {\n          return path\n        } else {\n          break\n        }\n      }\n\n      const i = NODE_TO_INDEX.get(child)\n\n      if (i == null) {\n        break\n      }\n\n      path.unshift(i)\n      child = parent\n    }\n\n    throw new Error(`Unable to find the path for Editor node: ${Scrubber.stringify(node)}`)\n  },\n\n  /**\n   * Find the DOM node that implements DocumentOrShadowRoot for the editor.\n   */\n\n  findDocumentOrShadowRoot(editor: Editor): Document | ShadowRoot {\n    const el = Editable.toDOMNode(editor, editor)\n    const root = el.getRootNode()\n\n    if (\n      (root instanceof Document || root instanceof ShadowRoot) &&\n      (root as any).getSelection != null\n    ) {\n      return root\n    }\n\n    return el.ownerDocument\n  },\n\n  /**\n   * Check if the editor is focused.\n   */\n  isFocused(editor: Editor): boolean {\n    return Focused.is(editor)\n  },\n\n  /**\n   * Check if the editor is in read-only mode.\n   */\n\n  isReadOnly(editor: Editor): boolean {\n    return ReadOnly.is(editor)\n  },\n\n  /**\n   * Blur the editor.\n   */\n\n  blur(editor: Editable): void {\n    editor.blur()\n  },\n\n  /**\n   * Focus the editor.\n   */\n  focus(editor: Editable): void {\n    editor.focus()\n  },\n\n  deselect(editor: Editor): void {\n    const { selection } = editor\n    if (selection) {\n      Transforms.deselect(editor)\n    }\n  },\n\n  /**\n   * Check if a DOM node is within the editor.\n   */\n  hasDOMNode(editor: Editor, target: DOMNode): boolean {\n    const editorEl = Editable.toDOMNode(editor, editor)\n    let targetEl\n\n    // COMPAT: In Firefox, reading `target.nodeType` will throw an error if\n    // target is originating from an internal \"restricted\" element (e.g. a\n    // stepper arrow on a number input). (2018/05/04)\n    // https://github.com/ianstormtaylor/slate/issues/1819\n    try {\n      targetEl = (isDOMElement(target) ? target : target.parentElement) as HTMLElement\n    } catch (err: any) {\n      if (!err.message.includes('Permission denied to access property \"nodeType\"')) {\n        throw err\n      }\n    }\n\n    if (!targetEl) {\n      return false\n    }\n\n    return targetEl.closest(`[${DATA_EDITABLE_NODE}=\"editor\"]`) === editorEl\n  },\n\n  /**\n   * Find the native DOM element from a Editor node.\n   */\n\n  toDOMNode(editor: Editor, node: Node): HTMLElement {\n    const KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor)\n    const offsetNode = Editor.isEditor(node)\n      ? EDITOR_TO_ELEMENT.get(editor)\n      : KEY_TO_ELEMENT?.get(Editable.findKey(editor, node))\n\n    if (!offsetNode) {\n      throw new Error(`Cannot resolve a DOM node from Editor node: ${Scrubber.stringify(node)}`)\n    }\n\n    return offsetNode\n  },\n\n  /**\n   * Find a native DOM selection point from a Editor point.\n   */\n  toDOMPoint(editor: Editor, point: Point): DOMPoint {\n    const [node] = Editor.node(editor, point.path)\n    const el = Editable.toDOMNode(editor, node)\n    let domPoint: DOMPoint | undefined\n\n    // If we're inside a void node, force the offset to 0, otherwise the zero\n    // width spacing character will result in an incorrect offset of 1\n    if (Editor.void(editor, { at: point })) {\n      point = { path: point.path, offset: 0 }\n    }\n\n    // For each leaf, we need to isolate its content, which means filtering\n    // to its direct text and zero-width spans. (We have to filter out any\n    // other siblings that may have been rendered alongside them.)\n    const selector = `[${DATA_EDITABLE_STRING}], [${DATA_EDITABLE_COMPOSITION}], [${DATA_EDITABLE_ZERO_WIDTH}]`\n    const texts = Array.from(el.querySelectorAll(selector))\n    let start = 0\n\n    for (const text of texts) {\n      const offsetNode = text.childNodes[0] as HTMLElement\n\n      if (offsetNode == null || offsetNode.textContent == null) {\n        continue\n      }\n\n      const { length } = offsetNode.textContent\n      const attr = text.getAttribute(DATA_EDITABLE_LENGTH)\n      const trueLength = attr == null ? length : parseInt(attr, 10)\n      const end = start + trueLength\n\n      if (point.offset <= end) {\n        const offset = Math.min(length, Math.max(0, point.offset - start))\n        domPoint = [offsetNode, offset]\n        break\n      }\n\n      start = end\n    }\n\n    if (!domPoint) {\n      throw new Error(`Cannot resolve a DOM point from Editor point: ${Scrubber.stringify(point)}`)\n    }\n\n    return domPoint\n  },\n\n  /**\n   * Find a native DOM range from a Editor `range`.\n   *\n   * Notice: the returned range will always be ordinal regardless of the direction of Editor `range` due to DOM API limit.\n   *\n   * there is no way to create a reverse DOM Range using Range.setStart/setEnd\n   * according to https://dom.spec.whatwg.org/#concept-range-bp-set.\n   */\n  toDOMRange(editor: Editor, range: Range): DOMRange {\n    const { anchor, focus } = range\n    const isBackward = Range.isBackward(range)\n    const domAnchor = Editable.toDOMPoint(editor, anchor)\n    const domFocus = Range.isCollapsed(range) ? domAnchor : Editable.toDOMPoint(editor, focus)\n\n    const window = Editable.getWindow(editor)\n    const domRange = window.document.createRange()\n    const [startNode, startOffset] = isBackward ? domFocus : domAnchor\n    const [endNode, endOffset] = isBackward ? domAnchor : domFocus\n\n    // A editor Point at zero-width Leaf always has an offset of 0 but a native DOM selection at\n    // zero-width node has an offset of 1 so we have to check if we are in a zero-width node and\n    // adjust the offset accordingly.\n    const startEl = (isDOMElement(startNode) ? startNode : startNode.parentElement) as HTMLElement\n    const isStartAtZeroWidth = !!startEl.getAttribute(DATA_EDITABLE_ZERO_WIDTH)\n    const endEl = (isDOMElement(endNode) ? endNode : endNode.parentElement) as HTMLElement\n    const isEndAtZeroWidth = !!endEl.getAttribute(DATA_EDITABLE_ZERO_WIDTH)\n\n    domRange.setStart(startNode, isStartAtZeroWidth ? 1 : startOffset)\n    domRange.setEnd(endNode, isEndAtZeroWidth ? 1 : endOffset)\n    return domRange\n  },\n\n  /**\n   * Find a Editor node from a native DOM `element`.\n   */\n  toEditorNode(editor: Editor, offsetNode: DOMNode): Node {\n    let domEl = isDOMElement(offsetNode) ? offsetNode : offsetNode.parentElement\n\n    if (domEl && !domEl.hasAttribute(DATA_EDITABLE_NODE)) {\n      domEl = domEl.closest(`[${DATA_EDITABLE_NODE}]`)\n    }\n\n    const node = domEl ? ELEMENT_TO_NODE.get(domEl as HTMLElement) : null\n\n    if (!node) {\n      throw new Error(`Cannot resolve a Editor node from DOM node: ${domEl}`)\n    }\n\n    return node\n  },\n\n  findLowestDOMElements(editor: Editor, node: Node) {\n    const domNode = Editable.toDOMNode(editor, node)\n    if (Editor.isVoid(editor, node)) return [domNode]\n    const nodes = domNode.querySelectorAll(\n      `[${DATA_EDITABLE_STRING}], [${DATA_EDITABLE_COMPOSITION}], [${DATA_EDITABLE_ZERO_WIDTH}]`,\n    )\n    return Array.from(nodes)\n  },\n\n  findClosestPoint(editor: Editor, domNode: DOMNode, x: number, y: number): Point | null {\n    const domEl = isDOMElement(domNode) ? domNode : domNode.parentElement\n    if (!domEl) return null\n    const elements: DOMElement[] = []\n    let element: DOMElement | null = domEl.hasAttribute(DATA_EDITABLE_NODE)\n      ? domEl\n      : domEl.closest(`[${DATA_EDITABLE_NODE}]`)\n\n    const addToElements = (node: Node) => {\n      if (!NODE_TO_ELEMENT.get(node)) return\n      const children = Editable.findLowestDOMElements(editor, node)\n      for (const child of children) {\n        if (~elements.indexOf(child)) continue\n        elements.push(child)\n      }\n    }\n\n    if (!element) {\n      const nodes = Node.nodes(editor)\n      for (const [node] of nodes) {\n        addToElements(node)\n      }\n    } else {\n      const node = Editable.toEditorNode(editor, element)\n      if (Text.isText(node) || Editor.isVoid(editor, node)) {\n        addToElements(node)\n      } else {\n        if (!Editor.isSolidVoid(editor, node)) {\n          const rect = element.getBoundingClientRect()\n          const reverse = x < rect.left + rect.width / 2\n          const adjacent = (reverse ? Editor.previous : Editor.next)(editor, {\n            at: Editable.findPath(editor, node),\n          })\n          if (adjacent) {\n            addToElements(adjacent[0])\n          }\n        } else {\n          const isGrid = Editor.isGrid(editor, node)\n          const nodes = Editor.nodes(editor, {\n            at: Editable.findPath(editor, node),\n            match: n => (isGrid && Editor.isGridCell(editor, n)) || Text.isText(n),\n            mode: 'highest',\n          })\n          for (const [child] of nodes) {\n            if (Editor.isBlock(editor, child)) {\n              elements.push(Editable.toDOMNode(editor, child))\n            } else addToElements(child)\n          }\n        }\n      }\n    }\n    let top = y,\n      left = x\n    const nodes = findNearbyNodes(elements, x, y)\n    if (!nodes) return null\n    let offsetNode: DOMElement | null = null\n    if (isDOMNode(nodes)) {\n      offsetNode = nodes\n    } else {\n      const { top: nearbyTop, left: nearbyLeft, right: nearbyRight, below: nearbyBelow } = nodes\n\n      if (nearbyLeft && nearbyBelow) {\n        if (isAlignY(nearbyBelow.rect, nearbyLeft.rect)) {\n          offsetNode = nearbyBelow.node\n          top = nearbyBelow.rect.top\n        } else {\n          offsetNode = nearbyLeft.node\n          left = nearbyLeft.rect.right\n        }\n      } else if (nearbyRight && nearbyBelow) {\n        if (isAlignY(nearbyBelow.rect, nearbyRight.rect)) {\n          offsetNode = nearbyBelow.node\n          top = nearbyBelow.rect.top\n        } else {\n          offsetNode = nearbyRight.node\n          left = nearbyRight.rect.left\n        }\n      } else if (nearbyLeft) {\n        offsetNode = nearbyLeft.node\n        if (left <= nearbyLeft.rect.left) left = nearbyLeft.rect.left\n        else if (left >= nearbyLeft.rect.right) left = nearbyLeft.rect.right\n        else {\n          top = nearbyLeft.rect.top\n        }\n      } else if (nearbyRight) {\n        offsetNode = nearbyRight.node\n        if (left <= nearbyRight.rect.left) left = nearbyRight.rect.left\n        else if (left >= nearbyRight.rect.right) left = nearbyRight.rect.right\n        else {\n          top = nearbyRight.rect.top\n        }\n      } else if (nearbyBelow) {\n        if (left < nearbyBelow.rect.left) {\n          left = nearbyBelow.rect.left\n        } else if (left > nearbyBelow.rect.right) {\n          left = nearbyBelow.rect.right\n        }\n        top = nearbyBelow.rect.top\n        offsetNode = nearbyBelow.node\n      } else if (nearbyTop) {\n        offsetNode = nearbyTop.node\n        if (left < nearbyTop.rect.left) {\n          left = nearbyTop.rect.left\n        } else if (left > nearbyTop.rect.right) {\n          left = nearbyTop.rect.right\n        }\n        top = nearbyTop.rect.bottom\n      }\n    }\n    if (!offsetNode) return null\n    const node = Editable.toEditorNode(editor, offsetNode)\n    if (Text.isText(node)) {\n      const path = Editable.findPath(editor, node)\n      if (node.text.length === 0) {\n        return {\n          path,\n          offset: 0,\n        }\n      }\n      const textNodes = Editable.findLowestDOMElements(editor, node)\n      let startOffset = 0\n      for (let s = 0; s < textNodes.length; s++) {\n        const textNode = textNodes[s]\n        if (textNode === offsetNode) break\n        startOffset += (textNode.textContent ?? '').length\n      }\n      const textNode = isDOMText(offsetNode) ? offsetNode : offsetNode.firstChild\n      if (!isDOMText(textNode)) return null\n      const content = textNode.textContent ?? ''\n      const offset = getTextOffset(textNode, left, top, 0, content.length, content.length)\n      return {\n        path,\n        offset: startOffset + offset,\n      }\n    } else if (Element.isElement(node)) {\n      const point = Editable.toEditorPoint(editor, [offsetNode, 0], {\n        exactMatch: false,\n        suppressThrow: true,\n      })\n      if (!point) return Editor.start(editor, Editable.findPath(editor, node))\n      return point\n    }\n    return null\n  },\n  /**\n   * Get the target point from a DOM `event`.\n   */\n  findEventPoint(editor: Editor, event: any): Point | null {\n    event = getNativeEvent(event)\n    const { clientX: x, clientY: y } = event\n\n    if (x == null || y == null) {\n      throw new Error(`Cannot resolve a Editor range from a DOM event: ${event}`)\n    }\n    let target = event.target\n    if (isTouch(event)) {\n      target = document.elementFromPoint(event.clientX, event.clientY)\n    }\n    return Editable.findClosestPoint(editor, target, x, y)\n  },\n\n  findPreviousLinePoint(editor: Editor, at?: Range): Point | null {\n    const { selection } = editor\n    if (!at && selection) at = selection\n    if (!at) return null\n    const startPoint = Range.start(at)\n    const endPoint = Range.end(at)\n    const startRange = Editable.toDOMRange(editor, { anchor: startPoint, focus: startPoint })\n    const endRange = Editable.toDOMRange(editor, { anchor: endPoint, focus: endPoint })\n\n    const startRects = startRange.getClientRects()\n    const endRects = endRange.getClientRects()\n\n    const block = Editor.above(editor, {\n      at: at.focus,\n      match: n => Editor.isBlock(editor, n),\n    })\n    let top = endRects[0].top\n    let isFind = false\n\n    let isSameLine = true\n\n    let prevBlock = block\n    let domBlock: DOMElement | null = null\n    while (prevBlock && !isFind) {\n      const [block, path] = prevBlock\n      domBlock = Editable.toDOMNode(editor, block)\n      const lowestElements = Editable.findLowestDOMElements(editor, block)\n      for (let l = lowestElements.length - 1; l >= 0 && !isFind; l--) {\n        const lowestElement = lowestElements[l]\n        const rects = lowestElement.getClientRects()\n        for (let i = 0; i < rects.length; i++) {\n          const rect = rects[i]\n          if (rect.height === 0) continue\n          if (rect.bottom <= top) {\n            isFind = true\n            top = rect.bottom - rect.height / 2\n            break\n          }\n        }\n      }\n      if (!isFind) {\n        isSameLine = false\n        prevBlock = Editor.previous(editor, {\n          at: path,\n          match: n => Editor.isBlock(editor, n),\n        })\n      }\n    }\n    if (!domBlock) return null\n    return Editable.findClosestPoint(\n      editor,\n      domBlock,\n      isFind && !isSameLine ? startRects[0].x : 0,\n      top,\n    )\n  },\n\n  findLineEdgePoint(\n    editor: Editor,\n    { at, edge = 'start' }: { at?: Range; edge?: 'start' | 'end' } = {},\n  ): Point | null {\n    const { selection } = editor\n    if (!at && selection) at = selection\n    if (!at) return null\n    const isStart = edge === 'start'\n    const point = isStart ? Range.start(at) : Range.end(at)\n    const range = Editable.toDOMRange(editor, {\n      anchor: point,\n      focus: point,\n    })\n    range.collapse(isStart)\n    const rects = range.getClientRects()\n    const rect = rects[rects.length - 1]\n    const bottom = rect.top + rect.height / 2\n    const block = Editor.above(editor, {\n      at: point,\n      match: n => Editor.isBlock(editor, n),\n    })\n    if (!block) return null\n    const domBlock = Editable.toDOMNode(editor, block[0])\n    return Editable.findClosestPoint(editor, domBlock, isStart ? -99999 : 99999, bottom)\n  },\n\n  findNextLinePoint(editor: Editor, at?: Range): Point | null {\n    const { selection } = editor\n    if (!at && selection) at = selection\n    if (!at) return null\n    const startPoint = Range.start(at)\n    const endPoint = Range.end(at)\n    const startRange = Editable.toDOMRange(editor, { anchor: startPoint, focus: startPoint })\n    const endRange = Editable.toDOMRange(editor, { anchor: endPoint, focus: endPoint })\n\n    const startRects = startRange.getClientRects()\n    const endRects = endRange.getClientRects()\n\n    let blockEntry = Editor.above(editor, {\n      at: at.focus,\n      match: n => Editor.isBlock(editor, n),\n    })\n    let bottom = endRects[0].bottom\n    let isFind = false\n    let isSameLine = true\n    let domBlock: DOMElement | null = null\n    while (blockEntry && !isFind) {\n      const [block, path] = blockEntry\n      domBlock = Editable.toDOMNode(editor, block)\n      const lowestElements = Editable.findLowestDOMElements(editor, block)\n      for (let l = 0; l < lowestElements.length && !isFind; l++) {\n        const lowestElement = lowestElements[l]\n        const rects = lowestElement.getClientRects()\n        for (let i = 0; i < rects.length; i++) {\n          const rect = rects[i]\n          if (rect.height === 0) continue\n          if (rect.top >= bottom) {\n            isFind = true\n            bottom = rect.top + rect.height / 2\n            break\n          }\n        }\n      }\n      if (!isFind) {\n        blockEntry = Editor.next(editor, {\n          at: path,\n          match: n => Editor.isBlock(editor, n),\n        })\n        isSameLine = false\n      }\n    }\n    if (!domBlock) return null\n\n    return Editable.findClosestPoint(\n      editor,\n      domBlock,\n      isFind && !isSameLine ? startRects[0].x : 99999,\n      bottom,\n    )\n  },\n\n  findTextOffsetOnLine(editor: Editor, point: Point) {\n    const blockEntry = Editor.above(editor, {\n      match: n => Editor.isBlock(editor, n),\n      at: point,\n    })\n    const data = {\n      text: '',\n      offset: 0,\n    }\n    if (!blockEntry) {\n      throw new Error(`Cannot resolve a Editor block from a point: ${point}`)\n    }\n    const textNodes = Node.texts(blockEntry[0])\n    let isFindOffset = false\n    for (const [textNode, textPath] of textNodes) {\n      let { text } = textNode\n      const path = blockEntry[1].concat(textPath)\n      const [parent] = Editor.parent(editor, path)\n      if (parent && Editor.isVoid(editor, parent)) {\n        text = ''\n      }\n      if (Path.equals(path, point.path)) {\n        data.offset += point.offset\n        isFindOffset = true\n      } else if (!isFindOffset) {\n        data.offset += text.length\n      }\n      data.text += text\n    }\n    return data\n  },\n\n  findPointOnLine(editor: Editor, path: Path, offset: number, moveNext: boolean = false) {\n    const blockEntry = Editor.above(editor, {\n      match: n => Editor.isBlock(editor, n),\n      at: path,\n    })\n    if (!blockEntry) {\n      throw new Error(`Cannot resolve a Editor block from a path: ${path}`)\n    }\n    const textNodes = Node.texts(blockEntry[0])\n    let findOffset = 0\n    for (const [textNode, textPath] of textNodes) {\n      let { text } = textNode\n      const path = blockEntry[1].concat(textPath)\n      const [parent, parentPath] = Editor.parent(editor, path)\n      const isVoid = parent && Editor.isVoid(editor, parent)\n      if (isVoid) {\n        text = ' '\n      }\n      const textLength = text.length\n      const totalOffset = findOffset + textLength\n      if (totalOffset >= offset) {\n        if (moveNext && offset > 0 && totalOffset === offset) {\n          const next = Editor.next(editor, {\n            at: isVoid ? parentPath : path,\n          })\n          if (next) {\n            return {\n              path: next[1],\n              offset: 0,\n            }\n          }\n        }\n        return { path, offset: textLength - (totalOffset - offset) }\n      } else {\n        findOffset += textLength\n      }\n    }\n    return { path, offset }\n  },\n\n  /**\n   * Find a Editor point from a DOM selection's `offsetNode` and `domOffset`.\n   */\n  toEditorPoint<T extends boolean>(\n    editor: Editor,\n    domPoint: DOMPoint,\n    options: {\n      exactMatch: T\n      suppressThrow: T\n    },\n  ): T extends true ? Point | null : Point {\n    const { exactMatch, suppressThrow } = options\n    const [nearestNode, nearestOffset] = exactMatch ? domPoint : normalizeDOMPoint(domPoint)\n    const parentNode = nearestNode.parentNode as DOMElement\n    let textNode: DOMElement | null = null\n    let offset = 0\n\n    if (parentNode) {\n      const editorEl = Editable.toDOMNode(editor, editor)\n      const potentialVoidNode = parentNode.closest(`[${DATA_EDITABLE_VOID}]`)\n      // Need to ensure that the closest void node is actually a void node\n      // within this editor, and not a void node within some parent editor. This can happen\n      // if this editor is within a void node of another editor (\"nested editors\", like in\n      // the \"Editable Voids\" example on the docs site).\n      const voidNode =\n        potentialVoidNode && editorEl.contains(potentialVoidNode) ? potentialVoidNode : null\n      let leafNode = parentNode.closest(`[${DATA_EDITABLE_LEAF}]`)\n      let offsetNode: DOMElement | null = null\n\n      // Calculate how far into the text node the `nearestNode` is, so that we\n      // can determine what the offset relative to the text node is.\n      if (leafNode) {\n        textNode = leafNode.closest(`[${DATA_EDITABLE_NODE}=\"text\"]`)\n\n        if (textNode) {\n          const window = Editable.getWindow(editor)\n          const range = window.document.createRange()\n          range.setStart(textNode, 0)\n          range.setEnd(nearestNode, nearestOffset)\n\n          const contents = range.cloneContents()\n          const removals = [\n            ...Array.prototype.slice.call(\n              contents.querySelectorAll(`[${DATA_EDITABLE_ZERO_WIDTH}]`),\n            ),\n          ]\n\n          removals.forEach(el => {\n            el!.parentNode!.removeChild(el)\n          })\n\n          // COMPAT: Edge has a bug where Range.prototype.toString() will\n          // convert \\n into \\r\\n. The bug causes a loop when slate-react\n          // attempts to reposition its cursor to match the native position. Use\n          // textContent.length instead.\n          // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\n          offset = contents.textContent!.length\n          offsetNode = textNode\n        }\n      } else if (voidNode) {\n        // For void nodes, the element with the offset key will be a cousin, not an\n        // ancestor, so find it by going down from the nearest void parent.\n        leafNode = voidNode.querySelector(`[${DATA_EDITABLE_LEAF}]`)!\n\n        // COMPAT: In read-only editors the leaf is not rendered.\n        if (!leafNode) {\n          offset = 1\n        } else {\n          textNode = leafNode.closest(`[${DATA_EDITABLE_NODE}=\"text\"]`)!\n          offsetNode = leafNode\n          offset = offsetNode.textContent!.length\n          offsetNode.querySelectorAll(`[${DATA_EDITABLE_ZERO_WIDTH}]`).forEach(el => {\n            offset -= el.textContent!.length\n          })\n        }\n      }\n\n      if (\n        offsetNode &&\n        offset === offsetNode.textContent!.length &&\n        // COMPAT: If the parent node is a Editor zero-width space, editor is\n        // because the text node should have no characters. However, during IME\n        // composition the ASCII characters will be prepended to the zero-width\n        // space, so subtract 1 from the offset to account for the zero-width\n        // space character.\n        (parentNode.hasAttribute(DATA_EDITABLE_ZERO_WIDTH) ||\n          // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\\n'\n          // when the document ends with a new-line character. This results in the offset\n          // length being off by one, so we need to subtract one to account for this.\n          (IS_FIREFOX && offsetNode.textContent?.endsWith('\\n\\n')))\n      ) {\n        offset--\n      }\n    }\n\n    if (!textNode) {\n      if (suppressThrow) {\n        return null as T extends true ? Point | null : Point\n      }\n      throw new Error(`Cannot resolve a Editor point from DOM point: ${domPoint}`)\n    }\n\n    // COMPAT: If someone is clicking from one Editor editor into another,\n    // the select event fires twice, once for the old editor's `element`\n    // first, and then afterwards for the correct `element`. (2017/03/03)\n    const editorNode = Editable.toEditorNode(editor, textNode!)\n    const path = Editable.findPath(editor, editorNode)\n    return { path, offset } as T extends true ? Point | null : Point\n  },\n\n  /**\n   * Find a Editor range from a DOM range or selection.\n   */\n  toEditorRange<T extends boolean>(\n    editor: Editor,\n    domRange: DOMRange | DOMStaticRange | DOMSelection,\n    options: {\n      exactMatch: T\n      suppressThrow: T\n    },\n  ): T extends true ? Range | null : Range {\n    const { exactMatch, suppressThrow } = options\n    const el = isDOMSelection(domRange) ? domRange.anchorNode : domRange.startContainer\n    let anchorNode\n    let anchorOffset\n    let focusNode\n    let focusOffset\n    let isCollapsed\n\n    if (el) {\n      if (isDOMSelection(domRange)) {\n        anchorNode = domRange.anchorNode\n        anchorOffset = domRange.anchorOffset\n        focusNode = domRange.focusNode\n        focusOffset = domRange.focusOffset\n        // COMPAT: There's a bug in chrome that always returns `true` for\n        // `isCollapsed` for a Selection that comes from a ShadowRoot.\n        // (2020/08/08)\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n        if (IS_CHROME && hasShadowRoot()) {\n          isCollapsed =\n            domRange.anchorNode === domRange.focusNode &&\n            domRange.anchorOffset === domRange.focusOffset\n        } else {\n          isCollapsed = domRange.isCollapsed\n        }\n      } else {\n        anchorNode = domRange.startContainer\n        anchorOffset = domRange.startOffset\n        focusNode = domRange.endContainer\n        focusOffset = domRange.endOffset\n        isCollapsed = domRange.collapsed\n      }\n    }\n\n    if (anchorNode == null || focusNode == null || anchorOffset == null || focusOffset == null) {\n      throw new Error(`Cannot resolve a Editor range from DOM range: ${domRange}`)\n    }\n\n    const anchor = Editable.toEditorPoint(editor, [anchorNode, anchorOffset], {\n      exactMatch,\n      suppressThrow,\n    })\n    if (!anchor) {\n      return null as T extends true ? Range | null : Range\n    }\n\n    const focus = isCollapsed\n      ? anchor\n      : Editable.toEditorPoint(editor, [focusNode, focusOffset], {\n          exactMatch,\n          suppressThrow,\n        })\n    if (!focus) {\n      return null as T extends true ? Range | null : Range\n    }\n\n    let range: Range = { anchor: anchor as Point, focus: focus as Point }\n    // if the selection is a hanging range that ends in a void\n    // and the DOM focus is an Element\n    // (meaning that the selection ends before the element)\n    // unhang the range to avoid mistakenly including the void\n    if (\n      Range.isExpanded(range) &&\n      Range.isForward(range) &&\n      isDOMElement(focusNode) &&\n      Editor.void(editor, { at: range.focus, mode: 'highest' })\n    ) {\n      range = Editor.unhangRange(editor, range, { voids: true })\n    }\n\n    return range as unknown as T extends true ? Range | null : Range\n  },\n\n  toRelativePosition(editor: Editor, x: number, y: number): [number, number] {\n    const container = Editable.toDOMNode(editor, editor)\n    const rootRect = container.getBoundingClientRect()\n\n    return [x - rootRect.left, y - rootRect.top]\n  },\n\n  reverseRelativePosition(editor: Editor, x: number, y: number): [number, number] {\n    const container = Editable.toDOMNode(editor, editor)\n    const rootRect = container.getBoundingClientRect()\n    return [x + rootRect.left, y + rootRect.top]\n  },\n\n  scrollIntoView(editor: Editor, range = editor.selection) {\n    if (!range) return\n    const domRange = Editable.toDOMRange(editor, range)\n    const focusEl = domRange.endContainer.parentElement!\n    scrollIntoView(focusEl, {\n      scrollMode: 'if-needed',\n    })\n  },\n}\n","import { Ancestor, Editor, Node, Key } from '@editablejs/models'\n\n/**\n * Two weak maps that allow us rebuild a path given a node. They are populated\n * at render time such that after a render occurs we can always backtrack.\n */\n\nexport const NODE_TO_INDEX: WeakMap<Node, number> = new WeakMap()\nexport const NODE_TO_PARENT: WeakMap<Node, Ancestor> = new WeakMap()\n\n/**\n * Weak maps that allow us to go between Slate nodes and DOM nodes. These\n * are used to resolve DOM event-related logic into Slate actions.\n */\nexport const EDITOR_TO_WINDOW: WeakMap<Editor, Window> = new WeakMap()\nexport const EDITOR_TO_ELEMENT: WeakMap<Editor, HTMLElement> = new WeakMap()\nexport const EDITOR_TO_INPUT: WeakMap<Editor, HTMLTextAreaElement> = new WeakMap()\nexport const EDITOR_TO_SHADOW: WeakMap<Editor, ShadowRoot | null> = new WeakMap()\nexport const ELEMENT_TO_NODE: WeakMap<HTMLElement, Node> = new WeakMap()\nexport const NODE_TO_ELEMENT: WeakMap<Node, HTMLElement> = new WeakMap()\nexport const NODE_TO_KEY: WeakMap<Node, Key> = new WeakMap()\nexport const EDITOR_TO_KEY_TO_ELEMENT: WeakMap<Editor, WeakMap<Key, HTMLElement>> = new WeakMap()\nexport const EDITOR_TO_SELECTION_RECTS = new WeakMap<Editor, DOMRect[]>()\n\n/**\n * Weak maps for storing editor-related state.\n */\nexport const IS_CLICKING: WeakMap<Editor, boolean> = new WeakMap()\nexport const IS_COMPOSING: WeakMap<Editor, boolean> = new WeakMap()\nexport const IS_ON_COMPOSITION_END: WeakMap<Editor, boolean> = new WeakMap()\nexport const IS_SHIFT_PRESSED: WeakMap<Editor, boolean> = new WeakMap()\nexport const IS_MOUSEDOWN: WeakMap<Editor, boolean> = new WeakMap()\nexport const IS_TOUCHMOVING: WeakMap<Editor, boolean> = new WeakMap()\nexport const IS_TOUCHING: WeakMap<Editor, boolean> = new WeakMap()\nexport const IS_TOUCH_HOLD: WeakMap<Editor, boolean> = new WeakMap()\n/**\n * Weak map for associating the context `onChange` context with the plugin.\n */\nexport const NODE_TO_RESTORE_DOM = new WeakMap<Node, () => void>()\n\nexport const IS_PASTE_TEXT: WeakMap<Editor, boolean> = new WeakMap()\n","// COMPAT: This is required to prevent TypeScript aliases from doing some very\n// weird things for Slate's types with the same name as globals. (2019/11/27)\nimport {\n  DOMPoint,\n  isDOMElement,\n  DOMElement,\n  DOMNode,\n  isDOMComment,\n  isDOMHTMLElement,\n} from '@editablejs/models'\nimport { Constants } from './constants'\nimport { CAN_USE_DOM } from './environment'\n\n/**\n * Normalize a DOM point so that it always refers to a text node.\n */\n\nexport const normalizeDOMPoint = (domPoint: DOMPoint): DOMPoint => {\n  let [node, offset] = domPoint\n\n  // If it's an element node, its offset refers to the index of its children\n  // including comment nodes, so try to find the right text child node.\n  if (isDOMElement(node) && node.childNodes.length) {\n    let isLast = offset === node.childNodes.length\n    let index = isLast ? offset - 1 : offset\n    ;[node, index] = getEditableChildAndIndex(node, index, isLast ? 'backward' : 'forward')\n    // If the editable child found is in front of input offset, we instead seek to its end\n    isLast = index < offset\n\n    // If the node has children, traverse until we have a leaf node. Leaf nodes\n    // can be either text nodes, or other void DOM nodes.\n    while (isDOMElement(node) && node.childNodes.length) {\n      const i = isLast ? node.childNodes.length - 1 : 0\n      node = getEditableChild(node, i, isLast ? 'backward' : 'forward')\n    }\n\n    // Determine the new offset inside the text node.\n    offset = isLast && node.textContent != null ? node.textContent.length : 0\n  }\n\n  // Return the node and offset.\n  return [node, offset]\n}\n\n/**\n * Determines wether the active element is nested within a shadowRoot\n */\n\nexport const hasShadowRoot = () => {\n  return !!(window.document.activeElement && window.document.activeElement.shadowRoot)\n}\n\n/**\n * Get the nearest editable child and index at `index` in a `parent`, preferring\n * `direction`.\n */\n\nexport const getEditableChildAndIndex = (\n  parent: DOMElement,\n  index: number,\n  direction: 'forward' | 'backward',\n): [DOMNode, number] => {\n  const { childNodes } = parent\n  let child = childNodes[index]\n  let i = index\n  let triedForward = false\n  let triedBackward = false\n\n  // While the child is a comment node, or an element node with no children,\n  // keep iterating to find a sibling non-void, non-comment node.\n  while (isDOMComment(child) || (isDOMElement(child) && child.childNodes.length === 0)) {\n    if (triedForward && triedBackward) {\n      break\n    }\n\n    if (i >= childNodes.length) {\n      triedForward = true\n      i = index - 1\n      direction = 'backward'\n      continue\n    }\n\n    if (i < 0) {\n      triedBackward = true\n      i = index + 1\n      direction = 'forward'\n      continue\n    }\n\n    child = childNodes[i]\n    index = i\n    i += direction === 'forward' ? 1 : -1\n  }\n\n  return [child, index]\n}\n\n/**\n * Get the nearest editable child at `index` in a `parent`, preferring\n * `direction`.\n */\n\nexport const getEditableChild = (\n  parent: DOMElement,\n  index: number,\n  direction: 'forward' | 'backward',\n): DOMNode => {\n  const [child] = getEditableChildAndIndex(parent, index, direction)\n  return child\n}\n\nexport const isEditableDOMElement = (value: any): boolean => {\n  if (isDOMHTMLElement(value)) {\n    return ['INPUT', 'TEXTAREA'].indexOf(value.nodeName) > -1 || value.isContentEditable\n  }\n  return false\n}\n\nexport const canForceTakeFocus = () => {\n  if (!CAN_USE_DOM) return true\n  const activeElement = document.activeElement\n  if (isEditableDOMElement(activeElement)) return false\n  return true\n}\n\nexport const inAbsoluteDOMElement = (value: any): boolean => {\n  if (isDOMHTMLElement(value)) {\n    let node: HTMLElement | null = value\n    while (node) {\n      const attributeNames = node.getAttributeNames()\n      if (attributeNames.some(name => Constants.dataNode === name)) return false\n      const styles = getComputedStyle(node)\n      if (~['absolute', 'fixed'].indexOf(styles.position)) {\n        return true\n      }\n      node = node.parentElement\n    }\n  }\n  return false\n}\n","import * as React from 'react'\n\nexport const IS_REACT_VERSION_17_OR_ABOVE = parseInt(React.version.split('.')[0], 10) >= 17\n\nexport const IS_IOS =\n  typeof navigator !== 'undefined' &&\n  typeof window !== 'undefined' &&\n  /iPad|iPhone|iPod/.test(navigator.userAgent) &&\n  !(window as any).MSStream\n\nexport const IS_APPLE = typeof navigator !== 'undefined' && /Mac OS X/.test(navigator.userAgent)\n\nexport const IS_FIREFOX =\n  typeof navigator !== 'undefined' && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent)\n\nexport const IS_SAFARI =\n  typeof navigator !== 'undefined' && /Version\\/[\\d\\.]+.*Safari/.test(navigator.userAgent)\n\n// \"modern\" Edge was released at 79.x\nexport const IS_EDGE_LEGACY =\n  typeof navigator !== 'undefined' &&\n  /Edge?\\/(?:[0-6][0-9]|[0-7][0-8])(?:\\.)/i.test(navigator.userAgent)\n\nexport const IS_CHROME = typeof navigator !== 'undefined' && /Chrome/i.test(navigator.userAgent)\n\n// Native `beforeInput` events don't work well with react on Chrome 75\n// and older, Chrome 76+ can use `beforeInput` though.\nexport const IS_CHROME_LEGACY =\n  typeof navigator !== 'undefined' &&\n  /Chrome?\\/(?:[0-7][0-5]|[0-6][0-9])(?:\\.)/i.test(navigator.userAgent)\n\n// Firefox did not support `beforeInput` until `v87`.\nexport const IS_FIREFOX_LEGACY =\n  typeof navigator !== 'undefined' &&\n  /^(?!.*Seamonkey)(?=.*Firefox\\/(?:[0-7][0-9]|[0-8][0-6])(?:\\.)).*/i.test(navigator.userAgent)\n\n// qq browser\nexport const IS_QQBROWSER =\n  typeof navigator !== 'undefined' && /.*QQBrowser/.test(navigator.userAgent)\n\n// UC mobile browser\nexport const IS_UC_MOBILE =\n  typeof navigator !== 'undefined' && /.*UCBrowser/.test(navigator.userAgent)\n\n// Wechat browser\nexport const IS_WECHATBROWSER =\n  typeof navigator !== 'undefined' && /.*Wechat/.test(navigator.userAgent)\n\n// Check if DOM is available as React does internally.\n// https://github.com/facebook/react/blob/master/packages/shared/ExecutionEnvironment.js\nexport const CAN_USE_DOM = !!(\n  typeof window !== 'undefined' &&\n  typeof window.document !== 'undefined' &&\n  typeof window.document.createElement !== 'undefined'\n)\n\n// COMPAT: Firefox/Edge Legacy don't support the `beforeinput` event\n// Chrome Legacy doesn't support `beforeinput` correctly\nexport const HAS_BEFORE_INPUT_SUPPORT =\n  !IS_CHROME_LEGACY &&\n  !IS_EDGE_LEGACY &&\n  // globalThis is undefined in older browsers\n  typeof globalThis !== 'undefined' &&\n  globalThis.InputEvent &&\n  // @ts-ignore The `getTargetRanges` property isn't recognized.\n  typeof globalThis.InputEvent.prototype.getTargetRanges === 'function'\n\n/**\n * Touch devices\n */\nexport const isTouchDevice = CAN_USE_DOM && 'ontouchstart' in document.documentElement\n","interface NearbyNode {\n  node: Element\n  rect: DOMRect\n}\n\n/**\n * 是否在一个节点前面\n * @param rect\n * @param node\n * @param otherNode\n * @returns\n */\nexport const isPrecedingY = (rect: DOMRect, node: Node, other: NearbyNode) => {\n  return (\n    rect.bottom > other.rect.bottom ||\n    (rect.top === other.rect.bottom &&\n      node.compareDocumentPosition(other.node) === Node.DOCUMENT_POSITION_PRECEDING)\n  )\n}\n\nexport const isFollowingY = (rect: DOMRect, node: Node, other: NearbyNode) => {\n  return (\n    rect.top < other.rect.top ||\n    (rect.top === other.rect.top &&\n      node.compareDocumentPosition(other.node) === Node.DOCUMENT_POSITION_FOLLOWING)\n  )\n}\n\nexport const isPrecedingX = (rect: DOMRect, node: Node, other: NearbyNode) => {\n  return (\n    rect.right > other.rect.right ||\n    (rect.right === other.rect.right &&\n      node.compareDocumentPosition(other.node) === Node.DOCUMENT_POSITION_PRECEDING)\n  )\n}\n\nexport const isFollowingX = (rect: DOMRect, node: Node, other: NearbyNode) => {\n  return (\n    rect.left < other.rect.left ||\n    (rect.left === other.rect.left &&\n      node.compareDocumentPosition(other.node) === Node.DOCUMENT_POSITION_FOLLOWING)\n  )\n}\n\n/**\n * 是否垂直对齐\n * @param rect\n * @param other\n * @param scale\n * @returns\n */\nexport const isAlignY = (rect: DOMRect, other: DOMRect, scale = 0.4) => {\n  if (rect.bottom === other.bottom) return true\n  // 未在水平上\n  if (rect.top > other.bottom || other.top > rect.bottom) return false\n  const minHeight = Math.min(other.height, rect.height)\n  const innerHeight = Math.min(rect.bottom, other.bottom) - Math.max(rect.top, other.top)\n  // 超过多少比例在水平上\n  return 0 === minHeight || innerHeight / minHeight > scale\n}\n\n/**\n * 判断 x 在 rect 中是否处于 left 与 right 之间\n * @param x\n * @param rect\n * @returns\n */\nexport const isBetweenX = (x: number, rect: DOMRect) => {\n  return x >= rect.left && x <= rect.right\n}\n\n/**\n * 判断 y 在 rect 中是否处于 top 与 bottom 之间\n * @param y\n * @param rect\n * @returns\n */\nexport const isBetweenY = (y: number, rect: DOMRect) => {\n  return y >= rect.top && y <= rect.bottom\n}\n\n/**\n * 获取 x 在 rect 中 left 与 right 之间最小的距离\n * @param x\n * @param rect\n * @returns\n */\nexport const getMinXInRect = (x: number, rect: DOMRect) => {\n  return Math.min(Math.abs(x - rect.left), Math.abs(x - rect.right))\n}\n\nexport const onNearbyY = (\n  x: number,\n  rect: DOMRect,\n  node: Node,\n  nearbyNode: NearbyNode,\n  preceding = true,\n) => {\n  if (isAlignY(rect, nearbyNode.rect)) {\n    const topBetween = isBetweenX(x, nearbyNode.rect)\n    const isBetween = isBetweenX(x, rect)\n    const topMin = getMinXInRect(x, nearbyNode.rect)\n    const min = getMinXInRect(x, rect)\n    if (!topBetween && (isBetween || min < topMin)) {\n      return true\n    }\n    return false\n  } else if (preceding) {\n    return isPrecedingY(rect, node, nearbyNode)\n  } else {\n    return isFollowingY(rect, node, nearbyNode)\n  }\n}\n\ntype NearbyNodes = {\n  top: NearbyNode | null\n  below: NearbyNode | null\n  left: NearbyNode | null\n  right: NearbyNode | null\n}\n\n/**\n * 查找附近的节点\n * @param nodes\n * @param x\n * @param y\n * @returns\n */\nconst findNearbyNodes = (nodes: Element[], x: number, y: number): Element | NearbyNodes | null => {\n  const closerNode: NearbyNodes = {\n    top: null,\n    below: null,\n    left: null,\n    right: null,\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    const child = nodes[i]\n    const rects = child.getClientRects()\n    for (let r = 0; r < rects.length; r++) {\n      const rect = rects[r]\n      // 刚好在区域内\n      if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {\n        return child\n      }\n      // 点击位置在区域 top上方\n      else if (y < rect.top) {\n        if (!closerNode.below || onNearbyY(x, rect, child, closerNode.below, false)) {\n          closerNode.below = {\n            rect,\n            node: child,\n          }\n        }\n      }\n      // 点击区域在 bottom 上方\n      else if (y > rect.bottom) {\n        if (!closerNode.top || onNearbyY(x, rect, child, closerNode.top)) {\n          closerNode.top = {\n            rect,\n            node: child,\n          }\n        }\n        if (closerNode.left && isPrecedingX(rect, child, closerNode.left)) {\n          closerNode.left = {\n            rect,\n            node: child,\n          }\n        }\n      } else if (\n        isBetweenY(y, rect) &&\n        x > rect.left &&\n        (!closerNode.left || isPrecedingX(rect, child, closerNode.left))\n      ) {\n        closerNode.left = {\n          rect,\n          node: child,\n        }\n      } else if (\n        isBetweenY(y, rect) &&\n        x < rect.right &&\n        (!closerNode.right || isFollowingX(rect, child, closerNode.right))\n      ) {\n        closerNode.right = {\n          rect,\n          node: child,\n        }\n      }\n    }\n  }\n  return closerNode\n}\n\nexport default findNearbyNodes\n","import { nextBreak, previousBreak } from '@editablejs/breaker'\n\n/**\n * @zh-CN 获取字符串索引处的向前或向后字符\n * @param text 文本\n * @param offset 索引\n * @param backward 是否取向后的字符，默认 false\n * @returns 字符串索引处的上或下个字符\n */\nexport const getCharFromGraphemeBreaker = (text: string, offset: number, backward = false) => {\n  if (offset < 0 || offset > text.length) {\n    return ''\n  }\n  let value\n  if (backward) {\n    value = previousBreak(text, offset)\n    return text.substring(value, offset)\n  } else {\n    value = nextBreak(text, offset)\n    return text.substring(offset, value)\n  }\n}\n\n/**\n * 获取字符串索引处的向后的字符索引\n * @param text 文本\n * @param offset 索引\n * @returns 向后的字符索引\n */\nexport const getCharOffsetBackward = (text: string, offset: number) => {\n  return getCharFromGraphemeBreaker(text, offset, true).length || 1\n}\n\n/**\n * 获取字符串索引处的向前的字符索引\n * @param text 文本\n * @param offset 索引\n * @returns 向前的字符索引\n */\nexport const getCharOffsetForward = (text: string, offset: number) => {\n  return getCharFromGraphemeBreaker(text, offset).length || 1\n}\n\n/**\n * 字形断路器\n * 获取字符串中的字符范围，Unicode字符范围不确定（高代理、低代理、私有代理字符存在）\n * @param text 文本\n * @param offset 当前索引\n * @returns [start, end]\n */\nexport const getCharRange = (text: string, offset: number) => {\n  let i = 0\n  for (; i <= offset; ) {\n    const end = i + getCharOffsetForward(text, i)\n    if (end > offset) return [i, end]\n    i = end\n  }\n  return [i, i + Math.min(text.length, 1)]\n}\n\nconst isSpace = (char: string) => /\\s/.test(char)\n// http://www.unicode.org/charts/\nconst isIdeograph = (char: string) =>\n  /[\\u3040-\\u30ff\\u3400-\\u4dbf\\u4e00-\\u9fff\\uf900-\\ufaff\\uff66-\\uff9f\\u3131-\\uD79D]/.test(char)\n// http://www.unicode.org/charts/\n// https://zh.wikipedia.org/zh-cn/Unicode%E5%AD%97%E7%AC%A6%E5%88%97%E8%A1%A8\nconst isSpecialCharacters = (char: string) =>\n  /[\\u0021-\\u002F\\u003A-\\u0040\\u005B-\\u0060\\u007B-\\u007E\\u00A1-\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65\\uFFE5]/.test(\n    char,\n  )\n\nconst equalOfCharacterType = (char: string, other: string) => {\n  return (\n    !!char &&\n    !!other &&\n    !isSpace(char) &&\n    !isSpecialCharacters(char) &&\n    !isSpace(other) &&\n    !isSpecialCharacters(other) &&\n    isIdeograph(char) === isIdeograph(other)\n  )\n}\n\ninterface Segment {\n  segment: string\n  index: number\n  input: string\n  isWordLike: boolean\n}\n\ndeclare global {\n  interface Window {\n    Intl: {\n      Segmenter?: new (\n        locale?: string,\n        options?: { granularity: 'word' | 'sentence' | 'line' },\n      ) => {\n        segment: (text: string) => Iterable<Segment>\n      }\n    }\n  }\n}\n\nexport const splitTextOfWord = (text: string, callback?: (segments: Segment[]) => Segment) => {\n  // split word\n  const Segmenter = window.Intl.Segmenter\n  if (Segmenter && isIdeograph(text)) {\n    const segments: Segment[] = Array.from(\n      new Segmenter(undefined, { granularity: 'word' }).segment(text),\n    )\n    if (segments.length > 0) {\n      const { segment, index } = callback ? callback(segments) : segments[segments.length - 1]\n      return { text: segment, offset: index }\n    }\n  }\n  return { text, offset: 0 }\n}\n\nexport const getWordBackward = (text: string, offset: number) => {\n  let currentChar = getCharFromGraphemeBreaker(text, offset, true)\n  let backwardOffset = offset - 1\n  for (; backwardOffset >= 0; ) {\n    const backwardChar = getCharFromGraphemeBreaker(text, backwardOffset, true)\n    if (equalOfCharacterType(currentChar, backwardChar)) {\n      backwardOffset -= backwardChar.length\n    } else break\n  }\n  if (offset - backwardOffset > 1) {\n    const wordText = text.substring(backwardOffset, offset)\n    const { offset: wordOffset } = splitTextOfWord(wordText)\n    backwardOffset += wordOffset\n  }\n  return text.substring(backwardOffset < 0 ? 0 : backwardOffset, offset)\n}\n\nexport const getWordOffsetBackward = (text: string, offset: number) => {\n  return offset - getWordBackward(text, offset).length\n}\n\nexport const getWordForward = (text: string, offset: number) => {\n  let currentChar = getCharFromGraphemeBreaker(text, offset)\n  let forwardOffset = offset + 1\n  for (; forwardOffset < text.length; ) {\n    const forwardChar = getCharFromGraphemeBreaker(text, forwardOffset)\n    if (equalOfCharacterType(currentChar, forwardChar)) {\n      forwardOffset += forwardChar.length\n    } else break\n  }\n  if (forwardOffset - offset > 1) {\n    const newText = text.substring(offset, forwardOffset)\n    const { text: wordText, offset: wordOffset } = splitTextOfWord(newText, segments => segments[0])\n    forwardOffset = offset + wordOffset + wordText.length\n  }\n  return text.substring(offset, forwardOffset > text.length ? text.length : forwardOffset)\n}\n\nexport const getWordOffsetForward = (text: string, offset: number) => {\n  return offset + getWordForward(text, offset).length\n}\n\nexport const getWordRange = (text: string, offset: number) => {\n  if (!text) return [0, 0]\n  offset = Math.min(offset, text.length)\n\n  let previousChar = getCharFromGraphemeBreaker(text, offset, true)\n  let nextChar = getCharFromGraphemeBreaker(text, offset)\n\n  let backwardOffset = offset - 1\n  let forwardOffset = offset + 1\n  if (!nextChar) {\n    return [offset, offset]\n  }\n  if (previousChar && equalOfCharacterType(previousChar, nextChar)) {\n    for (; backwardOffset >= 0; ) {\n      const backwardChar = getCharFromGraphemeBreaker(text, backwardOffset, true)\n      if (equalOfCharacterType(previousChar, backwardChar)) {\n        backwardOffset -= backwardChar.length\n      } else break\n    }\n  } else {\n    backwardOffset = offset\n  }\n\n  for (; forwardOffset < text.length; ) {\n    const forwardChar = getCharFromGraphemeBreaker(text, forwardOffset)\n    if (equalOfCharacterType(nextChar, forwardChar)) {\n      forwardOffset += forwardChar.length\n    } else break\n  }\n  // split word\n  if (forwardOffset - backwardOffset > 1) {\n    const newText = text.substring(backwardOffset, forwardOffset)\n    const { text: wordText, offset: wordOffset } = splitTextOfWord(newText, segments => {\n      for (let i = segments.length - 1; i >= 0; i--) {\n        const segment = segments[i]\n        const wordStart = segment.index + backwardOffset\n        if (offset >= wordStart && offset < wordStart + segment.segment.length) {\n          return segment\n        }\n      }\n      return segments[0]\n    })\n    backwardOffset += wordOffset\n    forwardOffset = wordText.length + backwardOffset\n  }\n  return [backwardOffset, forwardOffset]\n}\n\n/**\n * @zh-CN 获取在Text节点处鼠标点击坐标时的字符索引\n * @param node Text Node\n * @param x\n * @param y\n * @param start\n * @param end\n * @param length\n * @returns\n *\n */\nexport const getTextOffset = (\n  node: Text,\n  x: number,\n  y: number,\n  start: number,\n  end: number,\n  length: number,\n): number => {\n  const range = document.createRange()\n  if (end - start > 1) {\n    const mid = Math.floor((start + end) / 2)\n    try {\n      range.setStart(node, mid)\n      range.setEnd(node, Math.max(Math.min(mid, length), 0))\n    } catch (e) {\n      return start\n    }\n    const rects = range.getClientRects()\n    if (rects.length === 0) {\n      return start\n    }\n    for (const rect of rects) {\n      if (y < rect.top) {\n        return getTextOffset(node, x, y, start, mid, length)\n      } else if (y > rect.bottom) {\n        return getTextOffset(node, x, y, mid, end, length)\n      } else if (x <= rect.left + rect.width) {\n        return getTextOffset(node, x, y, start, mid, length)\n      }\n    }\n    return getTextOffset(node, x, y, mid, end, length)\n  }\n  const [rStart, rEnd] = getCharRange(node.textContent || '', start)\n  try {\n    range.setStart(node, rStart)\n    range.setEnd(node, Math.max(Math.min(rEnd, length), 0))\n  } catch (err) {\n    return rStart\n  }\n  const rects = range.getClientRects()\n  if (rects.length === 0) return rStart\n\n  for (const rect of rects) {\n    if (rect.width === 0) continue\n    if (y < rect.top) {\n      return rStart\n    } else if (y > rect.bottom) {\n      return rEnd\n    } else if (x <= rect.left + rect.width / 2) {\n      return rStart\n    }\n  }\n  return rEnd\n}\n","import {\n  Editor,\n  Node,\n  Range,\n  Element,\n  NodeEntry,\n  Path,\n  DOMElement,\n  DOMRange,\n  isDOMElement,\n} from '@editablejs/models'\nimport { Editable } from '../plugin/editable'\nimport {\n  DATA_EDITABLE_COMPOSITION,\n  DATA_EDITABLE_NODE,\n  DATA_EDITABLE_STRING,\n  DATA_EDITABLE_ZERO_WIDTH,\n} from './constants'\n\ninterface LineRectangle {\n  top: number\n  height: number\n  bottom: number\n  left: number\n  right: number\n}\n\n/**\n * Splits the rectangles into lines based on their positions.\n * @param rects\n */\nconst splitRectsIntoLines = (rects: DOMRect[] | DOMRectList) => {\n  const lines: Map<LineRectangle, DOMRect[]> = new Map()\n  if (rects.length === 0) return lines\n\n  const lineKeys: LineRectangle[] = []\n\n  /**\n   * Finds the line that the rectangle belongs to.\n   * @param rect\n   */\n  const findLineKey = (rect: DOMRect) => {\n    for (const lineKey of lineKeys) {\n      const { right } = lineKey\n      const previousRects = lines.get(lineKey)\n      const lastRect = previousRects\n        ? previousRects\n            .concat()\n            .reverse()\n            .find(p => p.width > 0) ?? previousRects[previousRects.length - 1]\n        : null\n      if (isRectInLine(rect, lineKey) && rect.left <= (lastRect ? lastRect.right : right) + 1) {\n        return lineKey\n      }\n    }\n    return null\n  }\n\n  // Loop through each rectangle and find its line\n  for (let r = 0; r < rects.length; r++) {\n    const rect = rects[r]\n    const key = findLineKey(rect)\n    if (key) {\n      lines.get(key)?.push(rect)\n    } else {\n      const lineRect = {\n        top: rect.top,\n        height: rect.height,\n        bottom: rect.bottom,\n        left: rect.left,\n        right: rect.right,\n      }\n      lines.set(lineRect, [rect])\n      lineKeys.push(lineRect)\n    }\n  }\n\n  // Find the minimum top, maximum bottom, and maximum right for each line\n  for (const [line, rects] of lines) {\n    // If there's only one rectangle in the line, skip\n    if (rects.length === 1) continue\n\n    let minTop = line.top,\n      maxBottom = line.bottom,\n      maxRight = line.right\n\n    // Compare each rectangle\n    for (const rect of rects) {\n      const { top, bottom, right } = rect\n      if (top < minTop) minTop = top\n      if (bottom > maxBottom) maxBottom = bottom\n      if (right > maxRight && rect.width > 0) maxRight = right\n    }\n    line.top = minTop\n    line.bottom = maxBottom\n    line.right = maxRight\n  }\n  return lines\n}\n\n/**\n * Calculates the height of a node based on line height and font size\n * @param el The DOM element to calculate height for\n * @returns The calculated height\n */\nconst calculateElementHeight = (el: DOMElement) => {\n  const { lineHeight, fontSize } = window.getComputedStyle(el)\n\n  // TODO: Handle pt, em, rem units\n\n  let height = 0\n  // Ends with px\n  if (lineHeight.endsWith('px')) {\n    height = parseFloat(lineHeight)\n    return height\n  }\n  // Ends with %\n  else if (lineHeight.endsWith('%')) {\n    height = parseInt(lineHeight, 10) / 100\n  }\n  // Number\n  else if (/^\\d+(\\.\\d+)?$/.test(lineHeight)) {\n    height = parseFloat(lineHeight)\n  } else {\n    return el.getBoundingClientRect().height\n  }\n\n  let size = 0\n  if (fontSize.endsWith('px')) {\n    size = parseInt(fontSize, 10)\n  }\n\n  return height * size\n}\n\n/**\n * Resets the DOMRect of an element to the specified height\n * @param rect The DOMRect to reset\n * @param height The new height for the rect\n * @returns The reset DOMRect\n */\nconst resetElementRect = (rect: DOMRect, height: number) => {\n  const oldHeight = rect.height\n  if (oldHeight >= height) return rect\n  const top = rect.top + (oldHeight - height) / 2\n  return new DOMRect(rect.left, top, rect.width, height)\n}\n\n/**\n * Check if a given DOMRect intersects with a given line defined by its top, bottom, and height values\n * @param {DOMRect} rect - The DOMRect to check\n * @param {Object} line - An object with top, bottom, and height properties representing the line\n * @return {Boolean} - True if the rect intersects with the line, false otherwise\n */\nconst isRectInLine = (rect: DOMRect, line: Record<'top' | 'bottom' | 'height', number>) => {\n  const deltaEdge = rect.height / 3\n  return (\n    // Check if the rect is fully contained within the line\n    (rect.top >= line.top &&\n      (rect.bottom <= line.bottom ||\n        // Check if the top of the rect is in the line and the overflow of the bottom is within 2/3\n        rect.top + deltaEdge < line.bottom ||\n        // Check if the bottom of the rect is within 2/3 from the top of the line and the top of the rect is above the bottom of the line\n        (rect.top <= line.top + line.height / 3 && rect.bottom > line.top))) ||\n    // Check if the rect covers the height of the line and the line is within the top and bottom of the rect\n    (rect.top <= line.top &&\n      (rect.bottom >= line.bottom ||\n        // Check if the top of the rect is above or equal to the top of the line and the bottom of the rect is within 2/3 of the line\n        rect.bottom - deltaEdge > line.top)) ||\n    // Check if the bottom of the rect is within 2/3 from the bottom of the line and the top of the rect is above the bottom of the line\n    (rect.bottom <= line.bottom &&\n      rect.bottom >= line.bottom - line.height / 3 &&\n      rect.top < line.bottom)\n  )\n}\n/**\n * Find the maximum position in the line of the top position in the el node\n * @param editor - The Editor instance\n * @param element - The DOM element\n * @param top - The top position\n * @param bottom - The bottom position\n * @returns - Object containing the line rect information\n */\nconst matchHighest = (editor: Editor, element: DOMElement, top: number, bottom: number) => {\n  const lineRect = {\n    top,\n    height: bottom - top,\n    bottom,\n  }\n\n  /**\n   * Compare the height of the current rect with the line rect\n   * and update the line rect with the highest values\n   * @param rect - The current rect\n   */\n  const compareHeight = (rect: DOMRect) => {\n    if (isRectInLine(rect, lineRect)) {\n      const newTop = lineRect.top < rect.top ? lineRect.top : rect.top\n      const newBottom = lineRect.bottom > rect.bottom ? lineRect.bottom : rect.bottom\n      lineRect.height = newBottom - newTop\n      lineRect.top = newTop\n      lineRect.bottom = newBottom\n    }\n  }\n\n  /**\n   * Recursively find the child nodes of the element and compare their rects\n   * @param element - The DOM element\n   */\n  const match = (element: DOMElement) => {\n    for (const child of element.childNodes) {\n      if (isDOMElement(child)) {\n        const hasNode = child.hasAttribute(DATA_EDITABLE_NODE)\n        const node = hasNode ? Editable.toEditorNode(editor, child) : null\n        if (node) {\n          if (Element.isElement(node)) {\n            if (editor.isVoid(node)) {\n              const rect = resetElementRect(\n                child.getBoundingClientRect(),\n                calculateElementHeight(child),\n              )\n              compareHeight(rect)\n            } else if (editor.isInline(node)) {\n              const height = calculateElementHeight(child)\n              const rects = child.getClientRects()\n              for (let r = 0; r < rects.length; r++) {\n                const rect = resetElementRect(rects[r], height)\n                compareHeight(rect)\n              }\n            } else {\n              match(child)\n            }\n          } else {\n            const nodes = child.querySelectorAll(\n              `[${DATA_EDITABLE_STRING}], [${DATA_EDITABLE_COMPOSITION}], [${DATA_EDITABLE_ZERO_WIDTH}]`,\n            )\n            nodes.forEach(node => {\n              const height = calculateElementHeight(node)\n              const rects = node.getClientRects()\n              for (let r = 0; r < rects.length; r++) {\n                const rect = resetElementRect(rects[r], height)\n                compareHeight(rect)\n              }\n            })\n          }\n        } else {\n          match(child)\n        }\n      }\n    }\n  }\n\n  match(element)\n  return lineRect\n}\n/**\n * Get the line rectangles of a given node in an editor.\n * @param editor The editor instance.\n * @param node The node to get line rectangles of.\n * @param minWidth The minimum width of the line rectangles. Default value is 4.\n * @returns An array of DOMRect objects representing the line rectangles.\n */\nexport const getLineRectsByNode = (editor: Editor, node: Node, minWidth = 4) => {\n  const path = Editable.findPath(editor, node)\n  const block: NodeEntry | undefined =\n    Editor.isBlock(editor, node) && path.length === 1\n      ? [node, path]\n      : Editor.above<Element>(editor, {\n          at: path,\n          match: n => Editor.isBlock(editor, n),\n          mode: 'highest',\n        })\n  if (!block) return []\n  const domEl = Editable.toDOMNode(editor, block[0])\n  const domRect = domEl.getBoundingClientRect()\n  const range = document.createRange()\n  range.selectNodeContents(Editable.toDOMNode(editor, node))\n  const lines = splitRectsIntoLines(range.getClientRects())\n  const lineRects: DOMRect[] = []\n  for (const [line, rects] of lines) {\n    let width = line.right - line.left\n    const lineRect = matchHighest(editor, domEl, line.top, line.bottom)\n    line.top = lineRect.top\n    line.height = lineRect.height\n    line.bottom = lineRect.bottom\n    // 空节点的宽度给个最小值\n    if (width < 1 && domRect.left === rects[0].left) {\n      width = minWidth\n    }\n    lineRects.push(new DOMRect(rects[0].left, line.top, width, line.height))\n  }\n  return lineRects\n}\n\n/**\n * Get DOMRect objects split by line within range\n * @param editor\n * @param range\n * @param minWidth minimum width of empty node, default to 4\n * @returns array of DOMRect objects\n */\nexport const getLineRectsByRange = (editor: Editor, range: Range, minWidth = 4) => {\n  const anchor = Range.start(range)\n  const focus = Range.end(range)\n  // 开始位置的 block节点\n  const anchorEntry = Editor.above<Element>(editor, {\n    at: anchor,\n    match: n => Editor.isBlock(editor, n),\n    mode: 'lowest',\n  })\n  // 结束位置的 block 节点\n  const focusEntry = Editor.above<Element>(editor, {\n    at: focus,\n    match: n => Editor.isBlock(editor, n),\n    mode: 'lowest',\n  })\n  if (!anchorEntry || !focusEntry) return []\n\n  const blockRects: DOMRect[] = []\n  const rectMap: Map<\n    DOMRect,\n    {\n      dom: DOMElement\n      element: Element\n    }\n  > = new Map()\n\n  let [startBlock, startPath] = anchorEntry\n  let [_, endPath] = focusEntry\n  const ranges: DOMRange[] = []\n  let isStart = true\n  let next: NodeEntry<Element> | undefined = anchorEntry\n  while (next) {\n    const [nextBlock, nextPath] = next as NodeEntry<Element>\n    const element = Editable.toDOMNode(editor, nextBlock)\n    const rect = element.getBoundingClientRect()\n    rectMap.set(rect, {\n      dom: element,\n      element: nextBlock,\n    })\n    blockRects.push(rect)\n\n    if (Path.equals(nextPath, endPath)) break\n    if (!isStart) {\n      const range = document.createRange()\n      range.selectNodeContents(element)\n      ranges.push(range)\n    } else {\n      isStart = false\n    }\n    next = Editor.next<Element>(editor, {\n      at: nextPath,\n      match: n => Editor.isBlock(editor, n),\n    })\n  }\n  if (Path.equals(startPath, endPath)) {\n    ranges.unshift(Editable.toDOMRange(editor, range))\n  } else {\n    ranges.unshift(\n      Editable.toDOMRange(editor, {\n        anchor,\n        focus: Editor.end(editor, {\n          path: startPath,\n          offset: startBlock.children.length,\n        }),\n      }),\n    )\n    ranges.push(\n      Editable.toDOMRange(editor, {\n        anchor: Editor.start(editor, {\n          path: endPath,\n          offset: 0,\n        }),\n        focus,\n      }),\n    )\n  }\n\n  // 拆分的行\n  const rects: DOMRect[] = []\n  for (const range of ranges) {\n    rects.push(...range.getClientRects())\n  }\n  const lines = splitRectsIntoLines(rects)\n  const lineRects: DOMRect[] = []\n  let prevLineRect: DOMRect | null = null\n  for (const [line, rects] of lines) {\n    // 找到对应行所在的 element\n    const blockRect = blockRects.find(\n      r =>\n        isRectInLine(r, line) &&\n        (line.left >= r.left || Math.abs(line.left - r.left) < 1) &&\n        (line.right <= r.right || Math.abs(line.right - r.right) < 1),\n    )\n    const block = blockRect ? rectMap.get(blockRect) : null\n\n    let width = line.right - line.left\n    if (block) {\n      const { dom, element } = block\n      const lineRect = matchHighest(editor, dom, line.top, line.bottom)\n      line.top = lineRect.top\n      line.height = lineRect.height\n      // 空节点的宽度给个最小值\n      if (\n        dom &&\n        Editor.isEmpty(editor, element) &&\n        width < 1 &&\n        dom.getBoundingClientRect().left === line.left\n      ) {\n        width = minWidth\n      }\n    }\n    // 去除行与行直接多余覆盖部分\n    if (prevLineRect && prevLineRect.bottom > line.top) {\n      const diffVal = prevLineRect.bottom - line.top\n      line.top += diffVal\n      line.height -= diffVal\n    }\n    const lineRect = new DOMRect(rects[0].left, line.top, width, line.height)\n\n    prevLineRect = lineRect\n    lineRects.push(lineRect)\n  }\n  return lineRects\n}\n","import { Editor } from '@editablejs/models'\nimport create, { StoreApi, UseBoundStore, useStore } from 'zustand'\nimport { Editable } from '../plugin/editable'\nimport { useEditableStatic } from './use-editable'\n\ninterface FocusedStore {\n  isFocused: boolean\n}\n\nconst EDITABLE_TO_FOCUSED_STORE = new WeakMap<Editor, UseBoundStore<StoreApi<FocusedStore>>>()\n\nconst getStore = (editor: Editor) => {\n  let store = EDITABLE_TO_FOCUSED_STORE.get(editor)\n  if (!store) {\n    store = create<FocusedStore>(() => ({\n      isFocused: false,\n    }))\n    EDITABLE_TO_FOCUSED_STORE.set(editor, store)\n    store.subscribe(({ isFocused }) => {\n      if (!Editable.isEditor(editor)) return\n\n      if (isFocused) {\n        editor.onFocus()\n      } else {\n        editor.onBlur()\n      }\n    })\n  }\n\n  return store\n}\n\nexport const useFocused = (): [boolean, (isFocused: boolean) => void] => {\n  const editor = useEditableStatic()\n  const store = getStore(editor)\n  const isFocused = useStore(store, state => state.isFocused)\n\n  return [\n    isFocused,\n    (isFocused: boolean) => {\n      store.setState({ isFocused })\n    },\n  ]\n}\n\nexport const Focused = {\n  is: (editor: Editor) => {\n    const store = getStore(editor)\n    return store.getState().isFocused\n  },\n}\n","export const composeEventHandlers = <E>(\n  originalEventHandler?: (event: E) => void,\n  ourEventHandler?: (event: E) => void,\n  { checkForDefaultPrevented = true } = {},\n) => {\n  return function handleEvent(event: E) {\n    originalEventHandler?.(event)\n\n    if (checkForDefaultPrevented === false || !(event as unknown as Event).defaultPrevented) {\n      return ourEventHandler?.(event)\n    }\n  }\n}\n\nexport const isTouchEvent = (event: any): event is TouchEvent => {\n  return typeof window.TouchEvent !== 'undefined' && event instanceof TouchEvent\n}\n\nexport const isTouch = (event: any): event is Touch => {\n  return typeof window.Touch !== 'undefined' && event instanceof Touch\n}\n\nexport const isMouseEvent = (event: any): event is MouseEvent => {\n  return event instanceof MouseEvent\n}\n\nexport const getNativeEvent = (event: any) => {\n  const { nativeEvent } = event\n  event = nativeEvent ?? event\n  if (isTouchEvent(event)) {\n    return event.touches[0] || event.changedTouches[0]\n  }\n  return event\n}\n","import { Editor } from '@editablejs/models'\nimport create, { StoreApi, UseBoundStore, useStore } from 'zustand'\nimport { useEditableStatic } from './use-editable'\n\ninterface ReadOnlyStore {\n  isReadOnly: boolean\n}\n\nconst EDITABLE_TO_FOCUSED_STORE = new WeakMap<Editor, UseBoundStore<StoreApi<ReadOnlyStore>>>()\n\nconst getStore = (editor: Editor) => {\n  let store = EDITABLE_TO_FOCUSED_STORE.get(editor)\n  if (!store) {\n    store = create<ReadOnlyStore>(() => ({\n      isReadOnly: false,\n    }))\n    EDITABLE_TO_FOCUSED_STORE.set(editor, store)\n  }\n\n  return store\n}\n\nexport const useReadOnly = (): [boolean, (isReadOnly: boolean) => void] => {\n  const editor = useEditableStatic()\n  const store = getStore(editor)\n  const isReadOnly = useStore(store, state => state.isReadOnly)\n\n  return [\n    isReadOnly,\n    (isReadOnly: boolean) => {\n      store.setState({ isReadOnly })\n    },\n  ]\n}\n\nexport const ReadOnly = {\n  is: (editor: Editor) => {\n    const store = getStore(editor)\n    return store.getState().isReadOnly\n  },\n}\n","import * as React from 'react'\nimport { CAN_USE_DOM } from '../utils/environment'\n\n/**\n * Prevent warning on SSR by falling back to useEffect when DOM isn't available\n */\n\nexport const useIsomorphicLayoutEffect = CAN_USE_DOM ? React.useLayoutEffect : React.useEffect\n","import * as React from 'react'\nimport { Text, Path, Range, Element } from '@editablejs/models'\nimport { useStore } from 'zustand'\nimport { Decorate, ElementDecorate, getDecorateStore, TextDecorate } from '../plugin/decorate'\nimport { useEditableStatic } from './use-editable'\n\nexport const useDecorateStore = () => {\n  const editor = useEditableStatic()\n  return React.useMemo(() => {\n    return getDecorateStore(editor)\n  }, [editor])\n}\n\nexport const useTextDecorations = (text: Text, path: Path) => {\n  const store = useDecorateStore()\n  const decorations = useStore(store, state => state.decorations)\n  return React.useMemo(() => {\n    return decorations.reduce<{ decorate: TextDecorate; ranges: Range[] }[]>((acc, decorate) => {\n      if (!Decorate.isTextDecorate(decorate)) return acc\n      const ranges = decorate.match(text, path)\n      if (ranges.length > 0) {\n        acc.push({ decorate, ranges })\n      }\n      return acc\n    }, [])\n  }, [decorations, text, path])\n}\n\nexport const useElementDecorations = (element: Element, path: Path) => {\n  const store = useDecorateStore()\n  const decorations = useStore(store, state => state.decorations)\n  return React.useMemo(() => {\n    return decorations.reduce<ElementDecorate[]>((acc, decorate) => {\n      if (Decorate.isTextDecorate(decorate)) return acc\n      if (decorate.match(element, path)) {\n        acc.push(decorate)\n      }\n      return acc\n    }, [])\n  }, [decorations, element, path])\n}\n","// Import necessary dependencies and models from @editablejs\nimport * as React from 'react'\nimport { Editor, Range, Node, Path, Text, Element } from '@editablejs/models'\n\n// Import the create and StoreApi from zustand\nimport create, { StoreApi, UseBoundStore } from 'zustand'\n\n// Define interface for properties passed to the render function of a text decoration\nexport interface DecorateRenderProps<T = Node> {\n  node: T\n  path: Path\n  children: React.ReactElement\n}\n\n// Define BaseDecorate interface with a key property that is optional\nexport interface BaseDecorate {\n  key?: string\n}\n\n// Define TextDecorate interface with match and renderText functions\nexport interface TextDecorate extends BaseDecorate {\n  match: (node: Text, path: Path) => Range[]\n  renderText: (props: DecorateRenderProps<Text>) => React.ReactElement\n}\n\n// Define ElementDecorate interface with match and renderElement functions\nexport interface ElementDecorate extends BaseDecorate {\n  match: (node: Element, path: Path) => boolean\n  renderElement: (props: DecorateRenderProps<Element>) => React.ReactElement\n}\n\n// Define a type for decorations which can either be a TextDecorate or an ElementDecorate\nexport type Decorate = TextDecorate | ElementDecorate\n\n// Define DecorateStore interface with decorations property\nexport interface DecorateStore {\n  decorations: Decorate[]\n}\n\n// Define a WeakMap to store Editor instances and their associated decoration stores\nconst EDITOR_TO_DECORATE_STORE = new WeakMap<Editor, UseBoundStore<StoreApi<DecorateStore>>>()\n\n// Function to retrieve the decoration store for a given Editor instance\nexport const getDecorateStore = (editor: Editor) => {\n  let store = EDITOR_TO_DECORATE_STORE.get(editor)\n  if (!store) {\n    store = create<DecorateStore>(() => ({\n      decorations: [],\n    }))\n    EDITOR_TO_DECORATE_STORE.set(editor, store)\n  }\n  return store\n}\n\n// Helper function to determine if a decoration is specified by its key or by its reference\nconst predicate = (decorate: Decorate | string) => {\n  const isKey = typeof decorate === 'string'\n  return (d: Decorate) => {\n    return isKey ? d.key === decorate : d === decorate\n  }\n}\n\n// Object to handle adding, removing, and checking the presence of decorations in a given Editor instance\nexport const Decorate = {\n  // Check if a given value is a TextDecorate\n  isTextDecorate: (value: any): value is TextDecorate => {\n    return value && typeof value.match === 'function' && typeof value.renderText === 'function'\n  },\n\n  // Add a decoration to the decorations array of a given Editor instance\n  create: (editor: Editor, decorate: Decorate) => {\n    const store = getDecorateStore(editor)\n    store.setState(state => ({\n      decorations: [...state.decorations, decorate],\n    }))\n  },\n\n  // Remove\n  remove: (editor: Editor, decorate: Decorate | string) => {\n    const store = getDecorateStore(editor)\n    store.setState(state => ({\n      decorations: state.decorations.filter(d => !predicate(decorate)(d)),\n    }))\n  },\n\n  has: (editor: Editor, decorate: Decorate | string) => {\n    const store = getDecorateStore(editor)\n    return store.getState().decorations.some(predicate(decorate))\n  },\n}\n","import * as React from 'react'\nimport { Editor, Node } from '@editablejs/models'\nimport { useStore } from 'zustand'\nimport { Placeholder } from '../plugin/placeholder'\nimport { useEditableStatic } from './use-editable'\nimport { useIsomorphicLayoutEffect } from './use-isomorphic-layout-effect'\nimport { Editable } from '../plugin/editable'\n\nexport const usePlaceholderStore = () => {\n  const editor = useEditableStatic()\n  return React.useMemo(() => {\n    return Placeholder.getStore(editor)\n  }, [editor])\n}\n\nexport const usePlaceholders = () => {\n  const store = usePlaceholderStore()\n  const placeholders = useStore(store, state => state.placeholders)\n  return placeholders\n}\n\nexport const usePlaceholder = (node: Node) => {\n  const editor = useEditableStatic()\n  const store = usePlaceholderStore()\n  const actives = useStore(store, state => state.actives)\n  useIsomorphicLayoutEffect(() => {\n    if (Editor.isEmpty(editor, node)) {\n      Placeholder.update(editor, [node, Editable.findPath(editor, node)])\n      return () => {\n        store.setState(({ actives }) => {\n          return {\n            actives: actives.filter(d => d.entry[0] !== node),\n          }\n        })\n      }\n    }\n  }, [store, node, editor])\n\n  return React.useMemo(() => {\n    return actives.find(d => d.entry[0] === node)?.render\n  }, [actives, node])\n}\n","import * as React from 'react'\nimport { Editor, Node, NodeEntry, Range } from '@editablejs/models'\nimport create, { UseBoundStore, StoreApi } from 'zustand'\nimport { Editable } from './editable'\n\nexport interface RenderPlaceholderProps {\n  node: Node\n}\nexport type PlaceholderRender = (props: RenderPlaceholderProps) => React.ReactNode\n\nexport type PlaceholderSubscribe = (entry: NodeEntry) => PlaceholderRender | void\n\nconst PLACEHOLDER_IS_ALONE = new WeakMap<PlaceholderSubscribe, boolean>()\nexport interface ActivePlaceholder {\n  entry: NodeEntry\n  alone: boolean\n  render: PlaceholderRender\n  placeholder: PlaceholderSubscribe\n}\n\nexport interface PlaceholderStore {\n  placeholders: PlaceholderSubscribe[]\n  actives: ActivePlaceholder[]\n}\n\nconst EDITOR_TO_PLACEHOLDER_STORE = new WeakMap<\n  Editable,\n  UseBoundStore<StoreApi<PlaceholderStore>>\n>()\n\nconst getPlaceholderStore = (editor: Editable) => {\n  let store = EDITOR_TO_PLACEHOLDER_STORE.get(editor)\n  if (!store) {\n    store = create<PlaceholderStore>(() => ({\n      placeholders: [],\n      actives: [],\n    }))\n    EDITOR_TO_PLACEHOLDER_STORE.set(editor, store)\n  }\n  return store\n}\n\nexport const Placeholder = {\n  getStore: getPlaceholderStore,\n\n  isAlone: (fn: PlaceholderSubscribe) => {\n    return PLACEHOLDER_IS_ALONE.get(fn) ?? false\n  },\n\n  subscribe: (editor: Editable, fn: PlaceholderSubscribe, alone = false) => {\n    const store = getPlaceholderStore(editor)\n    PLACEHOLDER_IS_ALONE.set(fn, alone)\n\n    store.setState(state => ({\n      placeholders: [...state.placeholders.filter(d => d !== fn), fn],\n    }))\n\n    return () => {\n      store.setState(state => ({\n        placeholders: state.placeholders.filter(d => d !== fn),\n      }))\n      PLACEHOLDER_IS_ALONE.delete(fn)\n    }\n  },\n\n  update: (editor: Editable, entry: NodeEntry) => {\n    const store = getPlaceholderStore(editor)\n    const state = store.getState()\n    let render: PlaceholderRender | null = null\n    let placeholder: PlaceholderSubscribe | null = null\n    const aloneActive = state.actives.find(d => d.alone && d.entry[0] === entry[0])\n    if (aloneActive) {\n      const r = aloneActive.placeholder(entry)\n      if (r) {\n        render = r\n        placeholder = aloneActive.placeholder\n      }\n    }\n    // 没有以编辑器为placeholder的情况下，才会去找其他的placeholder\n    else {\n      const hasEditorPlaceholder = state.actives.some(d => d.entry[0] === editor)\n      const placeholders = state.placeholders.sort(a => (Placeholder.isAlone(a) ? 1 : 0))\n      for (let i = placeholders.length - 1; i >= 0; i--) {\n        placeholder = placeholders[i]\n        if (!Placeholder.isAlone(placeholder) && hasEditorPlaceholder) continue\n        const r = placeholder(entry)\n        if (r) {\n          render = r\n          break\n        }\n      }\n    }\n\n    const actives = state.actives.filter(d => {\n      if (!d.alone || (d.entry[0] === entry[0] && render)) return false\n      return Editor.isEmpty(editor, d.entry[0])\n    })\n\n    if (render && placeholder) {\n      actives.push({\n        entry,\n        alone: Placeholder.isAlone(placeholder),\n        render,\n        placeholder,\n      })\n    }\n    store.setState({ actives })\n    return render\n  },\n\n  refresh: (editor: Editable) => {\n    const isReadOnly = Editable.isReadOnly(editor)\n    const store = getPlaceholderStore(editor)\n    if (isReadOnly) {\n      store.setState({ actives: [] })\n    } else if (Editor.isEmpty(editor, editor)) {\n      Placeholder.update(editor, [editor, []])\n    } else if (editor.selection && Range.isCollapsed(editor.selection)) {\n      const nodes = Editor.nodes(editor, {\n        at: editor.selection,\n      })\n      for (const entry of nodes) {\n        if (Editor.isEmpty(editor, entry[0])) {\n          return Placeholder.update(editor, entry)\n        }\n      }\n      store.setState(({ actives }) => {\n        return {\n          actives: actives.filter(d => {\n            if (!d.alone) return false\n            return Editor.isEmpty(editor, d.entry[0])\n          }),\n        }\n      })\n    } else {\n      store.setState(({ actives }) => ({\n        actives: actives.filter(d => d.alone),\n      }))\n    }\n  },\n}\n","import * as React from 'react'\n\nexport const NodeSelectedContext = React.createContext<boolean>(false)\n\n/**\n * Get the current `selected` state of an element.\n */\nexport const useNodeSelected = (): boolean => {\n  return React.useContext(NodeSelectedContext)\n}\n","import * as React from 'react'\n\nexport const NodeFocusedContext = React.createContext<boolean>(false)\n\n/**\n * Get the current `focused` state of an element.\n */\nexport const useNodeFocused = (): boolean => {\n  return React.useContext(NodeFocusedContext)\n}\n","import * as React from 'react'\nimport { Grid } from '@editablejs/models'\n\nexport const GridContext = React.createContext<Grid | null>(null)\n\nexport const useGrid = (): Grid | null => {\n  return React.useContext(GridContext)\n}\n","import * as React from 'react'\n\nimport { cancellablePromise, useCancellablePromises } from './use-cancellable-promises'\n\nconst useMultipleClick = (options: {\n  onClick?: (event: React.MouseEvent) => void\n  onMultipleClick: (event: React.MouseEvent, count: number) => boolean | void\n}) => {\n  const { onClick, onMultipleClick } = options\n  const api = useCancellablePromises()\n  const pointRef = React.useRef<{ x: number; y: number }>()\n  const countRef = React.useRef(0)\n\n  const isSamePoint = (event: React.MouseEvent | MouseEvent | Touch) => {\n    const point = pointRef.current\n    return point\n      ? Math.abs(event.clientY - point.y) < 10 && Math.abs(event.clientX - point.x) < 10\n      : false\n  }\n\n  const clear = () => {\n    api.clearPendingPromises()\n    pointRef.current = undefined\n  }\n\n  const handleMultipleClick = (event: React.MouseEvent) => {\n    if (event.button === 2) return\n    const point = pointRef.current\n    if (point) {\n      if (isSamePoint(event)) {\n        api.clearPendingPromises()\n        countRef.current += 1\n        if (onMultipleClick(event, countRef.current) === false) {\n          clear()\n          return\n        }\n      } else {\n        clear()\n      }\n    } else {\n      countRef.current = 1\n      pointRef.current = {\n        x: event.clientX,\n        y: event.clientY,\n      }\n    }\n    if (countRef.current === 1 && onMultipleClick(event, 1) === false) {\n      clear()\n    } else {\n      const waitForClick = cancellablePromise(api.delay(500))\n      api.appendPendingPromise(waitForClick)\n      return waitForClick.promise\n        .then(() => {\n          api.removePendingPromise(waitForClick)\n          if (onClick) onClick(event)\n          pointRef.current = undefined\n        })\n        .catch(errorInfo => {\n          api.removePendingPromise(waitForClick)\n          if (!errorInfo.isCanceled) {\n            throw errorInfo.error\n          }\n        })\n    }\n  }\n\n  return { handleMultipleClick, isSamePoint }\n}\n\nexport { useMultipleClick }\n","import * as React from 'react'\n\nexport interface CellablePromise<T> {\n  promise: Promise<T>\n  cancel: () => void\n}\n\nconst cancellablePromise = <T>(promise: Promise<T>) => {\n  let isCanceled = false\n\n  const wrappedPromise = new Promise((resolve, reject) => {\n    promise.then(\n      value => (isCanceled ? reject({ isCanceled, value }) : resolve(value)),\n      error => reject({ isCanceled, error }),\n    )\n  })\n\n  return {\n    promise: wrappedPromise,\n    cancel: () => (isCanceled = true),\n  }\n}\n\nconst noop = () => {}\n\nconst delay = (n: number) => new Promise(resolve => setTimeout(resolve, n))\n\nconst useCancellablePromises = <T>() => {\n  const pendingPromises = React.useRef<CellablePromise<T>[]>([])\n\n  const appendPendingPromise = (promise: CellablePromise<T>) =>\n    (pendingPromises.current = [...pendingPromises.current, promise])\n\n  const removePendingPromise = (promise: CellablePromise<T>) =>\n    (pendingPromises.current = pendingPromises.current.filter(p => p !== promise))\n\n  const clearPendingPromises = () => pendingPromises.current.map(p => p.cancel())\n\n  const api = {\n    pendingPromises,\n    appendPendingPromise,\n    removePendingPromise,\n    clearPendingPromises,\n    delay,\n    noop,\n  }\n\n  return api\n}\n\nexport { useCancellablePromises, cancellablePromise }\n","import * as React from 'react'\nimport ReactDOM from 'react-dom'\nimport { useIsomorphicLayoutEffect } from '../hooks/use-isomorphic-layout-effect'\n\nexport interface ShadowRect {\n  left: number\n  top: number\n  width: number\n  height: number\n  color?: string\n  style?: React.CSSProperties\n}\n\ntype ShadowBlockProps = {\n  rect: ShadowRect\n} & React.HTMLAttributes<HTMLDivElement>\n\nexport const ShadowBlockDefault: React.FC<ShadowBlockProps & React.RefAttributes<HTMLDivElement>> =\n  React.forwardRef<HTMLDivElement, ShadowBlockProps>(({ children, rect, style, ...props }, ref) => (\n    <div\n      ref={ref}\n      style={{\n        position: 'absolute',\n        top: rect.top,\n        left: rect.left,\n        width: rect.width,\n        height: rect.height,\n        // 数值为单数的情况下，两组重合位置会有阴影\n        // transform: `translateX(${rect.left || 0}px) translateY(${rect.top || 0}px)`,\n        opacity: 1,\n        backgroundColor: `${rect.color || 'transparent'}`,\n        zIndex: 1,\n        ...style,\n      }}\n      {...props}\n    >\n      {children}\n    </div>\n  ))\n\nShadowBlockDefault.displayName = 'ShadowBlock'\n\nexport const ShadowBlock = React.memo(ShadowBlockDefault, (prev, next) => {\n  return (\n    prev.rect.left === next.rect.left &&\n    prev.rect.top === next.rect.top &&\n    prev.rect.width === next.rect.width &&\n    prev.rect.height === next.rect.height &&\n    prev.rect.color === next.rect.color &&\n    prev.children === next.children\n  )\n})\n\ninterface ShadowContainerProps {\n  children?: React.ReactNode\n}\n\nconst ShadowContainer: React.FC<ShadowContainerProps & React.RefAttributes<ShadowRoot>> =\n  React.forwardRef<ShadowRoot, ShadowContainerProps>(({ children }, ref) => {\n    const [root, setRoot] = React.useState<ShadowRoot>()\n    const containerRef = React.useRef<HTMLDivElement>(null)\n\n    useIsomorphicLayoutEffect(() => {\n      if (!containerRef.current || containerRef.current.shadowRoot) return\n      const root = containerRef.current.attachShadow({ mode: 'open' })\n      setRoot(root)\n    }, [])\n\n    React.useImperativeHandle(ref, () => root!, [root])\n\n    return (\n      <div ref={containerRef} style={{ position: 'absolute', zIndex: 2, top: 0, left: 0 }}>\n        {root &&\n          ReactDOM.createPortal(<div style={{ pointerEvents: 'none' }}>{children}</div>, root)}\n      </div>\n    )\n  })\n\nShadowContainer.displayName = 'Shadow'\n\nexport default ShadowContainer\n","import * as React from 'react'\nimport { Range } from '@editablejs/models'\nimport { useEditableStatic } from '../hooks/use-editable'\nimport { useFocused } from '../hooks/use-focused'\nimport { useIsomorphicLayoutEffect } from '../hooks/use-isomorphic-layout-effect'\nimport { IS_MOUSEDOWN } from '../utils/weak-maps'\nimport {\n  useSelectionDrawingEnabled,\n  useSelectionDrawingRects,\n  useSelectionDrawingSelection,\n  useSelectionDrawingStyle,\n} from '../hooks/use-selection-drawing'\nimport { isTouchDevice } from '../utils/environment'\nimport { useReadOnly } from '../hooks/use-read-only'\nimport { ShadowBlock } from './shadow'\n\ninterface CaretProps {\n  timeout?: number | false\n}\n\nconst CaretComponent: React.FC<CaretProps> = React.memo(({ timeout = 530 }) => {\n  const editor = useEditableStatic()\n\n  const [focused] = useFocused()\n\n  const timer = React.useRef<number>()\n\n  const ref = React.useRef<HTMLDivElement>(null)\n\n  const [readOnly] = useReadOnly()\n\n  const enabled = useSelectionDrawingEnabled()\n  const selection = useSelectionDrawingSelection()\n  const rects = useSelectionDrawingRects()\n  const style = useSelectionDrawingStyle()\n\n  const caretWidth = isTouchDevice ? style.touchWidth : style.caretWidth\n  const caretColor = isTouchDevice ? style.touchColor : style.caretColor\n\n  const rect = React.useMemo(() => {\n    if (!selection || rects.length === 0 || !focused || !Range.isCollapsed(selection)) return null\n    return rects[0].toJSON()\n  }, [focused, rects, selection])\n\n  const clearActive = React.useCallback(() => {\n    clearTimeout(timer.current)\n  }, [])\n\n  const setOpacity = (opacity?: number) => {\n    const elRef = ref.current\n    if (elRef) {\n      elRef.style.opacity =\n        opacity !== undefined ? String(opacity) : elRef.style.opacity === '1' ? '0' : '1'\n    }\n  }\n\n  const active = React.useCallback(\n    (opacity?: number) => {\n      clearActive()\n      if (!rect || timeout === false) return\n      if (IS_MOUSEDOWN.get(editor)) {\n        setOpacity(1)\n      } else {\n        setOpacity(opacity)\n      }\n      timer.current = setTimeout(() => {\n        active()\n      }, timeout)\n    },\n    [clearActive, editor, rect, timeout],\n  )\n\n  useIsomorphicLayoutEffect(() => {\n    if (readOnly) {\n      clearActive()\n    } else active(1)\n    return () => clearActive()\n  }, [editor, readOnly, active, clearActive])\n\n  if (!enabled || readOnly) return null\n\n  return (\n    <ShadowBlock\n      rect={\n        rect\n          ? Object.assign({}, rect, { width: caretWidth, color: caretColor })\n          : { width: 0, height: 0, top: 0, left: 0 }\n      }\n      ref={ref}\n      style={{ willChange: 'opacity, transform', opacity: rect ? 1 : 0 }}\n    />\n  )\n})\nCaretComponent.displayName = 'CaretComponent'\nexport { CaretComponent }\n","import * as React from 'react'\nimport { useStore } from 'zustand'\nimport { SelectionDrawing } from '../plugin/selection-drawing'\nimport { EDITOR_TO_SELECTION_RECTS } from '../utils/weak-maps'\nimport { useEditableStatic } from './use-editable'\nimport { useIsomorphicLayoutEffect } from './use-isomorphic-layout-effect'\n\nexport const useSelectionDrawingStore = () => {\n  const editor = useEditableStatic()\n  return React.useMemo(() => {\n    return SelectionDrawing.getStore(editor)\n  }, [editor])\n}\n\nexport const useSelectionDrawingStyle = () => {\n  const store = useSelectionDrawingStore()\n  return useStore(store, state => state.style)\n}\n\nexport const useSelectionDrawingSelection = () => {\n  const store = useSelectionDrawingStore()\n  return useStore(store, state => state.selection)\n}\n\nexport const useSelectionDrawingRects = () => {\n  const editor = useEditableStatic()\n  const selection = useSelectionDrawingSelection()\n  const [rects, setRects] = React.useState<DOMRect[]>([])\n  useIsomorphicLayoutEffect(() => {\n    const rects = selection ? SelectionDrawing.toRects(editor, selection) : []\n    EDITOR_TO_SELECTION_RECTS.set(editor, rects)\n    setRects(rects)\n  }, [editor, selection])\n\n  return rects\n}\n\nexport const useSelectionDrawingEnabled = () => {\n  const store = useSelectionDrawingStore()\n  return useStore(store, state => state.enabled)\n}\n","import create, { StoreApi, UseBoundStore } from 'zustand'\nimport { Selection, Range, Editor } from '@editablejs/models'\nimport { getLineRectsByRange } from '../utils/selection'\nimport { Editable } from './editable'\n\nexport interface SelectionDrawingStyle {\n  /**\n   * 拖蓝聚焦颜色\n   */\n  focusColor?: string\n  /**\n   * 拖蓝失焦颜色\n   */\n  blurColor?: string\n  /**\n   * 光标颜色\n   */\n  caretColor?: string\n  /**\n   * 光标宽度\n   */\n  caretWidth?: number\n  /**\n   * 拖拽光标的颜色\n   */\n  dragColor?: string\n  /**\n   * 触摸光标的颜色\n   */\n  touchColor?: string\n  /**\n   * 触摸光标的宽度\n   */\n  touchWidth?: number\n}\n\nexport interface SelectionDrawingStore {\n  style: SelectionDrawingStyle\n  selection: Selection | null\n  enabled: boolean\n}\n\nconst EDITOR_TO_SELECTION_DRAWING_STORE = new WeakMap<\n  Editor,\n  UseBoundStore<StoreApi<SelectionDrawingStore>>\n>()\n\nconst getStore = (editor: Editor) => {\n  let store = EDITOR_TO_SELECTION_DRAWING_STORE.get(editor)\n  if (!store) {\n    store = create<SelectionDrawingStore>(() => ({\n      style: {\n        focusColor: 'rgba(0,127,255,0.3)',\n\n        blurColor: 'rgba(136, 136, 136, 0.3)',\n\n        caretColor: '#000',\n\n        caretWidth: 1,\n\n        dragColor: 'rgb(37, 99, 235)',\n\n        touchWidth: 2,\n\n        touchColor: 'rgb(37, 99, 235)',\n      },\n      selection: null,\n      rects: null,\n      enabled: true,\n    }))\n    EDITOR_TO_SELECTION_DRAWING_STORE.set(editor, store)\n  }\n  return store\n}\n\nexport const SelectionDrawing = {\n  getStore,\n\n  setStyle: (editor: Editor, style: Partial<SelectionDrawingStyle>) => {\n    const store = getStore(editor)\n    store.setState(state => ({ ...state, style }))\n  },\n\n  setSelection: (editor: Editor, selection: Selection | null) => {\n    const store = getStore(editor)\n    store.setState(state => ({ ...state, selection }))\n  },\n\n  setEnabled: (editor: Editor, enabled: boolean) => {\n    const store = getStore(editor)\n    store.setState(state => ({ ...state, enabled }))\n  },\n\n  toRects(editor: Editor, range: Range, relative = true) {\n    let rects: DOMRect[] = []\n    if (Range.isCollapsed(range)) {\n      const domRange = Editable.toDOMRange(editor, range)\n      const clientRects = domRange.getClientRects()\n      if (clientRects.length > 1) {\n        rects = [clientRects[clientRects.length - 1]]\n      } else {\n        rects = [domRange.getBoundingClientRect()]\n      }\n    } else {\n      rects = getLineRectsByRange(editor, range)\n    }\n\n    return relative\n      ? rects.map(r => {\n          const [x, y] = Editable.toRelativePosition(editor, r.left, r.top)\n          r.x = x\n          r.y = y\n          return r\n        })\n      : rects\n  },\n}\n","import * as React from 'react'\nimport { Range } from '@editablejs/models'\nimport { useFocused } from '../hooks/use-focused'\nimport {\n  useSelectionDrawingSelection,\n  useSelectionDrawingRects,\n  useSelectionDrawingEnabled,\n  useSelectionDrawingStyle,\n} from '../hooks/use-selection-drawing'\nimport { ShadowBlock } from './shadow'\nimport { isTouchDevice } from '../utils/environment'\n\ninterface SelectionProps {}\n\nconst SelectionComponent: React.FC<SelectionProps> = () => {\n  const selection = useSelectionDrawingSelection()\n  const rects = useSelectionDrawingRects()\n  const enabled = useSelectionDrawingEnabled()\n  const style = useSelectionDrawingStyle()\n  const [focused] = useFocused()\n  if (!enabled || !selection || Range.isCollapsed(selection)) return null\n\n  return (\n    <>\n      {rects.map((rect, index) => {\n        return (\n          <ShadowBlock\n            key={`sel-${index}`}\n            rect={Object.assign({}, rect.toJSON(), {\n              color: isTouchDevice || focused ? style.focusColor : style.blurColor,\n            })}\n          />\n        )\n      })}\n    </>\n  )\n}\n\nexport { SelectionComponent }\n","import { Range } from '@editablejs/models'\nimport * as React from 'react'\nimport { Editable } from '../plugin/editable'\nimport {\n  EDITOR_TO_INPUT,\n  IS_COMPOSING,\n  IS_MOUSEDOWN,\n  IS_PASTE_TEXT,\n  IS_TOUCHING,\n} from '../utils/weak-maps'\nimport { useFocused } from '../hooks/use-focused'\nimport { ShadowBlock, ShadowRect } from './shadow'\nimport { useIsomorphicLayoutEffect } from '../hooks/use-isomorphic-layout-effect'\nimport { useEditableStatic } from '../hooks/use-editable'\nimport {\n  useSelectionDrawingSelection,\n  useSelectionDrawingRects,\n} from '../hooks/use-selection-drawing'\nimport { ReadOnly, useReadOnly } from '../hooks/use-read-only'\nimport { composeEventHandlers } from '../utils/event'\nimport { useEffect } from 'react'\n\ninterface InputProps {\n  autoFocus?: boolean\n}\n\nconst InputComponent: React.FC<InputProps> = ({ autoFocus }) => {\n  const editor = useEditableStatic()\n  const inputRef = React.useRef<HTMLTextAreaElement>(null)\n  const [focused, setFocused] = useFocused()\n  const [readOnly] = useReadOnly()\n\n  const [rect, setRect] = React.useState<ShadowRect | null>(null)\n\n  useIsomorphicLayoutEffect(() => {\n    if (inputRef.current) EDITOR_TO_INPUT.set(editor, inputRef.current)\n    return () => {\n      EDITOR_TO_INPUT.delete(editor)\n    }\n  }, [editor])\n\n  useEffect(() => {\n    if (autoFocus) {\n      editor.focus()\n      Editable.scrollIntoView(editor)\n    }\n  }, [editor, autoFocus])\n\n  const handleKeydown = (event: React.KeyboardEvent) => {\n    const { nativeEvent } = event\n    if (Editable.isComposing(editor) && nativeEvent.isComposing === false) {\n      IS_COMPOSING.set(editor, false)\n    }\n\n    if (event.defaultPrevented || Editable.isComposing(editor)) {\n      return\n    }\n    editor.onKeydown(nativeEvent)\n  }\n\n  const handleKeyup = (event: React.KeyboardEvent) => {\n    const { nativeEvent } = event\n    editor.onKeyup(nativeEvent)\n  }\n\n  const handleBlur = () => {\n    if (!IS_MOUSEDOWN.get(editor) && !IS_TOUCHING.get(editor)) setFocused(false)\n  }\n\n  const handleFocus = () => {\n    setFocused(true)\n  }\n\n  const handleBeforeInput = (event: React.FormEvent<HTMLTextAreaElement>) => {\n    const textarea = event.target\n    if (!(textarea instanceof HTMLTextAreaElement)) return\n    const { value } = textarea\n    editor.onBeforeInput(value)\n  }\n\n  const handleInput = (event: React.FormEvent<HTMLTextAreaElement>) => {\n    const textarea = event.target\n    if (!(textarea instanceof HTMLTextAreaElement)) return\n    const value = textarea.value\n    if (!IS_COMPOSING.get(editor)) {\n      textarea.value = ''\n    }\n    editor.onInput(value)\n  }\n\n  const handleCompositionStart = (ev: React.CompositionEvent) => {\n    const { data } = ev.nativeEvent\n    editor.onCompositionStart(data)\n  }\n\n  const handleCompositionEnd = (event: React.CompositionEvent) => {\n    const textarea = event.target\n    if (!(textarea instanceof HTMLTextAreaElement)) return\n    const value = textarea.value\n    textarea.value = ''\n    editor.onCompositionEnd(value)\n  }\n\n  const handlePaste = (event: React.ClipboardEvent) => {\n    composeEventHandlers(\n      (event: React.ClipboardEvent) => {\n        if (ReadOnly.is(editor)) {\n          event.preventDefault()\n        }\n      },\n      event => {\n        const { nativeEvent } = event\n        const isPasteText = IS_PASTE_TEXT.get(editor)\n        event.preventDefault()\n        const e = new ClipboardEvent(isPasteText ? 'pasteText' : 'paste', nativeEvent)\n        editor.onPaste(e)\n      },\n    )(event)\n  }\n\n  const selection = useSelectionDrawingSelection()\n  const rects = useSelectionDrawingRects()\n\n  useIsomorphicLayoutEffect(() => {\n    if (!selection || !focused || rects.length === 0) return setRect(null)\n    if (Range.isCollapsed(selection)) {\n      setRect(rects[0].toJSON())\n    } else {\n      const rect = rects[rects.length - 1].toJSON()\n      rect.left = rect.left + rect.width\n      return setRect(rect)\n    }\n  }, [focused, rects, selection])\n\n  return (\n    <ShadowBlock\n      rect={Object.assign({}, rect, { color: 'transparent', width: 1 })}\n      style={{ opacity: 0, outline: 'none', caretColor: 'transparent', overflow: 'hidden' }}\n    >\n      <textarea\n        ref={inputRef}\n        rows={1}\n        style={{\n          fontSize: 'inherit',\n          lineHeight: 1,\n          padding: 0,\n          border: 'none',\n          whiteSpace: 'nowrap',\n          width: '1em',\n          overflow: 'auto',\n          resize: 'vertical',\n        }}\n        readOnly={readOnly}\n        onKeyDown={handleKeydown}\n        onKeyUp={handleKeyup}\n        onBeforeInput={handleBeforeInput}\n        onInput={handleInput}\n        onCompositionStart={handleCompositionStart}\n        onCompositionEnd={handleCompositionEnd}\n        onBlur={handleBlur}\n        onFocus={handleFocus}\n        onPaste={handlePaste}\n      />\n    </ShadowBlock>\n  )\n}\n\nexport { InputComponent }\n","import * as React from 'react'\nimport { useEditableStatic } from './use-editable'\nimport { Drag, DragStore } from '../plugin/drag'\nimport { useStore } from 'zustand'\n\nexport const useDragStore = () => {\n  const editor = useEditableStatic()\n  const store = React.useMemo(() => {\n    return Drag.getStore(editor)\n  }, [editor])\n  return store\n}\n\n/**\n * 是否拖拽中\n * @returns\n */\nexport const useDragging = () => {\n  const store = useDragStore()\n\n  const drag = useStore(store, state => state.drag !== null)\n\n  return React.useMemo(() => drag, [drag])\n}\n\nexport const useDragType = () => {\n  const store = useDragStore()\n\n  const type = useStore(store, state => state.drag?.type ?? null)\n\n  return React.useMemo(() => type, [type])\n}\n\n/**\n * 拖拽到的目标\n * @returns\n */\nexport const useDragTo = () => {\n  const store = useDragStore()\n  const drag = useStore(store, state => state.drag)\n\n  return React.useMemo(() => drag?.to ?? null, [drag])\n}\n\n/**\n * 当前拖拽的鼠标位置\n * @returns\n */\nexport const useDragPosition = () => {\n  const store = useDragStore()\n  const drag = useStore(store, state => state.drag)\n\n  return React.useMemo(() => drag?.position ?? null, [drag])\n}\n\n/**\n * 当前拖拽的数据\n * @returns\n */\nexport const useDragData = () => {\n  const store = useDragStore()\n  const drag = useStore(store, state => state.drag)\n\n  return React.useMemo(() => drag?.data ?? 0, [drag])\n}\n\nexport const useDragMethods = () => {\n  const editor = useEditableStatic()\n\n  const setDrag = React.useCallback(\n    (drag: Partial<DragStore['drag']>) => {\n      Drag.setDrag(editor, drag)\n    },\n    [editor],\n  )\n\n  const getDrag = React.useCallback(() => {\n    return Drag.getDrag(editor)\n  }, [editor])\n\n  return React.useMemo(() => ({ setDrag, getDrag }), [setDrag, getDrag])\n}\n","import create, { StoreApi, UseBoundStore } from 'zustand'\nimport { Editor, Range, Element, Path, Selection } from '@editablejs/models'\nimport { Editable } from './editable'\n\nexport interface DragStore {\n  drag: {\n    type: 'block' | 'text'\n    /**\n     * 拖拽的开始位置\n     */\n    from: Range | Path\n    /**\n     * 拖拽到目标位置\n     */\n    to: Selection | Path\n    /**\n     * 拖拽的数据\n     */\n    data: DataTransfer\n    /**\n     * 当前鼠标位置\n     */\n    position: Record<'x' | 'y', number>\n  } | null\n}\n\nconst EDITOR_TO_DRAG_STORE = new WeakMap<Editor, UseBoundStore<StoreApi<DragStore>>>()\n\nconst getDragStore = (editor: Editor) => {\n  let store = EDITOR_TO_DRAG_STORE.get(editor)\n  if (!store) {\n    store = create<DragStore>(() => ({\n      drag: null,\n    }))\n    EDITOR_TO_DRAG_STORE.set(editor, store)\n  }\n  return store\n}\n\n/**\n * 拖拽相关状态操作\n */\nexport const Drag = {\n  getStore: getDragStore,\n\n  getDrag: (editor: Editor) => {\n    const store = getDragStore(editor)\n    const { drag } = store.getState()\n    return drag\n  },\n\n  setDrag: (editor: Editor, drag: Partial<DragStore['drag']>) => {\n    const store = getDragStore(editor)\n    store.setState(state => {\n      return {\n        drag: drag === null ? null : Object.assign({}, state.drag, drag),\n      }\n    })\n  },\n\n  clear: (editor: Editor) => {\n    const store = getDragStore(editor)\n    store.setState({ drag: null })\n  },\n\n  toBlockPath: (editor: Editor) => {\n    const drag = Drag.getDrag(editor)\n    if (!drag || drag.type !== 'block') return\n    const { to, position } = drag\n    if (!to) return\n    const entry = Editor.above(editor, {\n      at: Path.isPath(to) ? to : to.focus,\n      match: n => Element.isElement(n),\n      mode: 'lowest',\n    })\n    if (!entry) return\n    const element = Editable.toDOMNode(editor, entry[0])\n    const rect = element.getBoundingClientRect()\n    const { y, height } = rect\n    const { y: pY } = position\n    if (pY > y + height / 2) {\n      return Path.next(entry[1])\n    } else {\n      return entry[1]\n    }\n  },\n}\n","import * as React from 'react'\nimport { Editor, Element, Path, GridCell } from '@editablejs/models'\nimport { useDragPosition, useDragTo, useDragType } from '../hooks/use-drag'\nimport { useEditableStatic } from '../hooks/use-editable'\nimport { useSelectionDrawingStyle } from '../hooks/use-selection-drawing'\nimport { Editable } from '../plugin/editable'\nimport { SelectionDrawing } from '../plugin/selection-drawing'\nimport { ShadowBlock } from './shadow'\n\nexport const DragCaretComponent = React.memo(() => {\n  const editor = useEditableStatic()\n  const dragTo = useDragTo()\n  const dragType = useDragType()\n  const dragPosition = useDragPosition()\n  const rects = React.useMemo(() => {\n    if (!dragTo || !dragPosition) return null\n    if (dragType === 'block') {\n      const entry = Editor.above(editor, {\n        at: dragTo,\n        match: n => Element.isElement(n),\n        mode: 'lowest',\n      })\n      if (!entry) return null\n      const element = Editable.toDOMNode(editor, entry[0])\n      const rect = element.getBoundingClientRect()\n      let { x, y } = rect\n      const { height, width } = rect\n      const { y: pY } = dragPosition\n      const space = 1\n      // bottom\n      if (pY > y + height / 2) {\n        y += height + space\n      }\n      // find previous sibling\n      else {\n        const previous = Editor.previous(editor, {\n          at: entry[1],\n          match: (n, p) => {\n            if (!Element.isElement(n)) return false\n            const gridCell = GridCell.find(editor, entry[1])\n            if (!gridCell) return true\n            const matchCell = GridCell.find(editor, p)\n            if (!matchCell) return false\n\n            return Path.equals(gridCell[1], matchCell[1])\n          },\n          mode: 'lowest',\n        })\n        if (previous) {\n          const previousElement = Editable.toDOMNode(editor, previous[0])\n          const previousRect = previousElement.getBoundingClientRect()\n          y = previousRect.y + previousRect.height + space\n        } else {\n          y -= space\n        }\n      }\n      const [rx, ry] = Editable.toRelativePosition(editor, x, y)\n      return [new DOMRect(rx, ry, width, 2)]\n    }\n\n    return SelectionDrawing.toRects(editor, Editor.range(editor, dragTo))\n  }, [dragPosition, dragTo, dragType, editor])\n\n  const { dragColor, caretWidth } = useSelectionDrawingStyle()\n  if (!rects || rects.length === 0) return null\n  if (dragType === 'block') {\n    return (\n      <ShadowBlock\n        rect={Object.assign({}, rects[0].toJSON(), {\n          color: dragColor,\n        })}\n      />\n    )\n  }\n  return (\n    <ShadowBlock\n      rect={Object.assign({}, rects[0].toJSON(), {\n        width: caretWidth,\n        color: dragColor,\n      })}\n    />\n  )\n})\n\nDragCaretComponent.displayName = 'DragCaretComponent'\n","import React from 'react'\nimport { useSlotComponents } from '../hooks/use-slot'\n\nexport const Slots = React.memo(() => {\n  const slots = useSlotComponents()\n  return (\n    <>\n      {slots.map(({ component: Component, props }, index) => (\n        <Component key={index} {...props} />\n      ))}\n    </>\n  )\n})\nSlots.displayName = 'Slots'\n","import React from 'react'\nimport { useStore } from 'zustand'\nimport shallow from 'zustand/shallow'\nimport { Slot } from '../plugin/solt'\nimport { useEditableStatic } from './use-editable'\n\nexport const useSlotStore = () => {\n  const editor = useEditableStatic()\n  return React.useMemo(() => Slot.getStore(editor), [editor])\n}\n\nexport const useSlotComponents = () => {\n  const store = useSlotStore()\n  return useStore(store, state => state.components, shallow)\n}\n\nexport const useSlotActive = (component: React.FC) => {\n  const components = useSlotComponents()\n  const editor = useEditableStatic()\n  const slot = components.find(c => c.component === component)\n  return React.useMemo(() => {\n    return [\n      slot?.props.active ?? false,\n      (active: boolean) => {\n        Slot.update(editor, { active }, c => c === component)\n      },\n    ] as const\n  }, [editor, slot, component])\n}\n","import merge from 'lodash.merge'\nimport * as React from 'react'\nimport create, { StoreApi, UseBoundStore } from 'zustand'\nimport { Editor } from '@editablejs/models'\n\nexport interface SlotComponentProps {\n  active?: boolean\n}\n\nexport interface SlotState<T extends SlotComponentProps> {\n  component: React.FC\n  props: T\n}\n\nexport interface SlotStore<T extends SlotComponentProps> {\n  components: SlotState<T>[]\n}\n\nconst EDITOR_TO_SLOTS_STORE = new WeakMap<\n  Editor,\n  UseBoundStore<StoreApi<SlotStore<SlotComponentProps>>>\n>()\n\nconst getStore = (editor: Editor) => {\n  let store = EDITOR_TO_SLOTS_STORE.get(editor)\n  if (!store) {\n    store = create<SlotStore<SlotComponentProps>>(() => ({\n      components: [],\n    }))\n    EDITOR_TO_SLOTS_STORE.set(editor, store)\n  }\n  return store\n}\n\nexport const Slot = {\n  getStore,\n\n  mount<T extends SlotComponentProps>(editor: Editor, component: React.FC<T>, props: T = {} as T) {\n    const store = getStore(editor)\n    store.setState(state => {\n      const { components } = state\n      if (components.some(c => c.component === component)) return state\n      return {\n        components: [...components, { component, props } as SlotState<T>],\n      }\n    })\n  },\n\n  unmount(editor: Editor, component: React.FC) {\n    const store = getStore(editor)\n    store.setState(state => {\n      const { components } = state\n      if (!components.some(c => c.component === component)) return state\n      return {\n        components: components.filter(c => c.component !== component),\n      }\n    })\n  },\n\n  update: <T extends SlotComponentProps>(\n    editor: Editor,\n    props: Partial<T>,\n    predicate: (value: React.FC<T>, index: number) => boolean = () => true,\n  ) => {\n    const store = getStore(editor)\n    store.setState(state => {\n      const { components } = state\n      return {\n        components: components.map((c, index) => {\n          if (!predicate(c.component, index)) return c\n          return { ...c, props: merge(c.props, props) }\n        }),\n      }\n    })\n  },\n}\n","import * as React from 'react'\nimport { Range } from '@editablejs/models'\nimport { useEditableStatic } from '../hooks/use-editable'\nimport { useFocused } from '../hooks/use-focused'\nimport {\n  useSelectionDrawingSelection,\n  useSelectionDrawingRects,\n  useSelectionDrawingEnabled,\n  useSelectionDrawingStyle,\n} from '../hooks/use-selection-drawing'\nimport { isTouchDevice } from '../utils/environment'\nimport { IS_TOUCHING, IS_TOUCHMOVING, IS_TOUCH_HOLD } from '../utils/weak-maps'\nimport { ShadowBlock } from './shadow'\n\ninterface TouchPointProps {\n  onAnchorTouchStart?: (e: React.TouchEvent) => void\n  onFocusTouchStart?: (e: React.TouchEvent) => void\n}\n\nconst TouchPointComponent: React.FC<TouchPointProps> = React.memo(\n  ({ onAnchorTouchStart, onFocusTouchStart }) => {\n    const selection = useSelectionDrawingSelection()\n    const rects = useSelectionDrawingRects()\n    const enabled = useSelectionDrawingEnabled()\n    const style = useSelectionDrawingStyle()\n    const editor = useEditableStatic()\n\n    if (\n      rects.length === 0 ||\n      !isTouchDevice ||\n      !enabled ||\n      !selection ||\n      IS_TOUCHING.get(editor) ||\n      (!IS_TOUCHMOVING.get(editor) && Range.isCollapsed(selection))\n    )\n      return null\n    const anchor = rects[0]\n    const focus = rects[rects.length - 1]\n\n    const baseStyle: React.CSSProperties = {\n      position: 'absolute',\n      width: 12,\n      height: 12,\n      borderRadius: '100%',\n      overscrollBehavior: 'none',\n      background: style.dragColor,\n    }\n\n    return (\n      <>\n        <ShadowBlock\n          rect={Object.assign({}, anchor.toJSON(), {\n            color: style.dragColor,\n            width: 2,\n            left: anchor.left - 1,\n          })}\n          style={{\n            zIndex: 2,\n          }}\n        >\n          <div\n            onTouchStart={onAnchorTouchStart}\n            style={{\n              ...baseStyle,\n              top: -10,\n              left: -5,\n            }}\n          />\n        </ShadowBlock>\n        <ShadowBlock\n          rect={Object.assign({}, focus.toJSON(), {\n            color: style.dragColor,\n            width: 2,\n            left: focus.right - 1,\n          })}\n          style={{\n            zIndex: 2,\n          }}\n        >\n          <div\n            onTouchStart={onFocusTouchStart}\n            style={{\n              ...baseStyle,\n              bottom: -10,\n              right: -5,\n            }}\n          />\n        </ShadowBlock>\n      </>\n    )\n  },\n)\nTouchPointComponent.displayName = 'TouchPointComponent'\nexport { TouchPointComponent }\n","import * as React from 'react'\nimport { Descendant, Node, Editor, Scrubber } from '@editablejs/models'\nimport create, { StoreApi, UseBoundStore } from 'zustand'\nimport { Editable } from '../plugin/editable'\nimport { EditableStore, EditableStoreContext } from '../hooks/use-editable'\nimport { useIsomorphicLayoutEffect } from '../hooks/use-isomorphic-layout-effect'\n\nconst EDITABLE_TO_STORE = new WeakMap<Editable, UseBoundStore<StoreApi<EditableStore>>>()\n\nexport const EditableProvider = (props: {\n  editor: Editable\n  value?: Descendant[]\n  children: React.ReactNode\n  onChange?: (value: Descendant[]) => void\n}) => {\n  const {\n    editor,\n    children,\n    value = [{ type: 'paragraph', children: [{ text: '' }] }],\n    onChange,\n    ...rest\n  } = props\n\n  const store = React.useMemo(() => {\n    const store = EDITABLE_TO_STORE.get(editor)\n    if (store) {\n      return store\n    }\n    if (!Node.isNodeList(value)) {\n      throw new Error(\n        `[Editable] value is invalid! Expected a list of elements` +\n          `but got: ${Scrubber.stringify(value)}`,\n      )\n    }\n    if (!Editor.isEditor(editor)) {\n      throw new Error(`[Editable] editor is invalid! you passed:` + `${Scrubber.stringify(editor)}`)\n    }\n    editor.children = value\n    Object.assign(editor, rest)\n    const newStore = create<EditableStore>(() => ({\n      editor: [editor],\n    }))\n    EDITABLE_TO_STORE.set(editor, newStore)\n    editor.normalizeNode([editor, []])\n    return newStore\n  }, [editor, value, rest])\n\n  useIsomorphicLayoutEffect(() => {\n    const handleChange = () => {\n      if (onChange) {\n        onChange(editor.children)\n      }\n      store.setState({\n        editor: [editor],\n      })\n    }\n    editor.on('change', handleChange)\n    return () => {\n      editor.off('change', handleChange)\n    }\n  }, [editor, onChange])\n\n  return (\n    <EditableStoreContext.Provider\n      value={{\n        store,\n        editor,\n      }}\n    >\n      {children}\n    </EditableStoreContext.Provider>\n  )\n}\n","import * as React from 'react'\nimport { Path, Grid, GridSelection } from '@editablejs/models'\nimport { Editable } from '../plugin/editable'\nimport { useEditableStatic } from './use-editable'\nimport { useGrid } from './use-grid'\nimport { useIsomorphicLayoutEffect } from './use-isomorphic-layout-effect'\nimport { useNodeFocused } from './use-node-focused'\n\nconst useGridSelection = () => {\n  const editor = useEditableStatic()\n  const grid = useGrid()\n  // selection\n  const [selection, setSelection] = React.useState<GridSelection | null>(null)\n  const nodeFocused = useNodeFocused()\n\n  useIsomorphicLayoutEffect(() => {\n    if (grid && nodeFocused) {\n      const selection = Grid.getSelection(editor, [grid, Editable.findPath(editor, grid)])\n      if (selection) {\n        setSelection(prev => {\n          if (\n            !prev ||\n            !Path.equals(prev.start, selection.start) ||\n            !Path.equals(prev.end, selection.end)\n          ) {\n            const path = Editable.findPath(editor, grid)\n            const startPath = path.concat(selection.start)\n            const endPath = path.concat(selection.end)\n            const edgeSelection = Grid.edges(editor, [grid, path], selection)\n            const { start: tableStart, end: tableEnd } = Grid.span(\n              editor,\n              [grid, path],\n              edgeSelection,\n            )\n            const selStart = path.concat(tableStart)\n            const selEnd = path.concat(tableEnd)\n            // 有合并的单元格时选择区域会变大，所以需要重新select\n            if (!Path.equals(startPath, selStart) || !Path.equals(endPath, selEnd)) {\n              Grid.select(editor, [grid, path], edgeSelection)\n              return prev\n            }\n            return selection\n          }\n          return prev\n        })\n        return\n      }\n    }\n    setSelection(null)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [editor, editor.selection, nodeFocused])\n\n  return selection\n}\n\nexport { useGridSelection }\n","import * as React from 'react'\nimport { GridCell, Grid } from '@editablejs/models'\nimport { Editable } from '../plugin/editable'\nimport { useEditableStatic } from './use-editable'\nimport { useGrid } from './use-grid'\nimport { useGridSelection } from './use-grid-selection'\nimport { useIsomorphicLayoutEffect } from './use-isomorphic-layout-effect'\n\nconst useGridSelectionRect = () => {\n  const editor = useEditableStatic()\n\n  const grid = useGrid()\n\n  const selection = useGridSelection()\n\n  const [rect, setRect] = React.useState<DOMRect | null>(null)\n\n  useIsomorphicLayoutEffect(() => {\n    if (!selection || !grid) return setRect(null)\n    const { start, end } = GridCell.edges(selection)\n    if (GridCell.equal(start, end)) return setRect(null)\n    const path = Editable.findPath(editor, grid)\n    const startCell = Grid.getCell(editor, path, start)\n    if (!startCell) return setRect(null)\n    const endCell = Grid.getCell(editor, path, end)\n    if (!endCell) return setRect(null)\n    const startEl = Editable.toDOMNode(editor, startCell[0])\n    const endEl = Editable.toDOMNode(editor, endCell[0])\n    const tableEl = Editable.toDOMNode(editor, grid)\n    const tableRect = tableEl.getBoundingClientRect()\n    const startRect = startEl.getBoundingClientRect()\n    const endRect = endEl.getBoundingClientRect()\n    const width =\n      endRect.left < startRect.left\n        ? startRect.right - endRect.left\n        : endRect.right - startRect.left\n    const height = Math.max(endRect.bottom - startRect.top, startRect.height)\n    const top = startRect.top - tableRect.top\n    const left = Math.min(startRect.left - tableRect.left, endRect.left - tableRect.left)\n    setRect(new DOMRect(left, top, width, height))\n  }, [editor, selection, grid])\n\n  return rect\n}\n\nexport { useGridSelectionRect }\n","import * as React from 'react'\nimport { GridSelected, Grid } from '@editablejs/models'\nimport { Editable } from '../plugin/editable'\nimport { useEditableStatic } from './use-editable'\nimport { useGrid } from './use-grid'\nimport { useGridSelection } from './use-grid-selection'\n\nconst defaultSelected = {\n  rows: [],\n  cols: [],\n  rowFull: false,\n  colFull: false,\n  allFull: false,\n  cells: [],\n  count: 0,\n}\n\nconst useGridSelected = () => {\n  const editor = useEditableStatic()\n\n  const grid = useGrid()\n\n  const selection = useGridSelection()\n\n  const selected: GridSelected = React.useMemo(() => {\n    if (!grid) return defaultSelected\n    const sel = Grid.getSelected(editor, Editable.findPath(editor, grid), selection ?? undefined)\n    return sel ?? defaultSelected\n  }, [editor, selection, grid])\n\n  return selected\n}\n\nexport { useGridSelected }\n","import ReactDOM from 'react-dom'\nimport {\n  Editor,\n  Node,\n  Path,\n  Operation,\n  Transforms,\n  Range,\n  Point,\n  List,\n  Key,\n} from '@editablejs/models'\nimport { Editable, RenderElementProps, RenderLeafProps } from './editable'\nimport {\n  EDITOR_TO_KEY_TO_ELEMENT,\n  NODE_TO_KEY,\n  IS_SHIFT_PRESSED,\n  EDITOR_TO_INPUT,\n  EDITOR_TO_SHADOW,\n} from '../utils/weak-maps'\nimport { findCurrentLineRange } from '../utils/lines'\nimport { EventEmitter } from './event'\nimport { Placeholder } from './placeholder'\nimport { Focused } from '../hooks/use-focused'\nimport { canForceTakeFocus } from '../utils/dom'\nimport { withInput } from './with-input'\nimport { withKeydown } from './with-keydown'\nimport { withNormalizeNode } from './with-normalize-node'\nimport { withDataTransfer } from './with-data-transfer'\nimport { getWordRange } from '../utils/text'\nimport { ReadOnly } from '../hooks/use-read-only'\n\n/**\n * `withEditable` adds React and DOM specific behaviors to the editor.\n *\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\n * this plugin.\n *\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\n */\nexport const withEditable = <T extends Editor>(editor: T) => {\n  const e = editor as T & Editable\n\n  withInput(e)\n\n  withKeydown(e)\n\n  withNormalizeNode(e)\n\n  withDataTransfer(e)\n\n  const { apply, onChange, deleteBackward, deleteForward } = e\n\n  // The WeakMap which maps a key to a specific HTMLElement must be scoped to the editor instance to\n  // avoid collisions between editors in the DOM that share the same value.\n  EDITOR_TO_KEY_TO_ELEMENT.set(e, new WeakMap())\n\n  e.deleteForward = unit => {\n    const { selection } = editor\n\n    if (selection && Range.isCollapsed(selection)) {\n      const [cell] = Editor.nodes(editor, {\n        match: n => e.isGridCell(n),\n      })\n\n      if (cell) {\n        const [, cellPath] = cell\n        const end = Editor.end(editor, cellPath)\n        if (Point.equals(selection.anchor, end)) {\n          return\n        }\n      }\n    }\n    deleteForward(unit)\n  }\n\n  e.deleteBackward = unit => {\n    const { selection } = editor\n\n    if (selection && Range.isCollapsed(selection)) {\n      const [cell] = Editor.nodes(editor, {\n        match: n => e.isGridCell(n),\n      })\n\n      if (cell) {\n        const [, cellPath] = cell\n        const start = Editor.start(editor, cellPath)\n\n        if (Point.equals(selection.anchor, start)) {\n          return\n        }\n      }\n      const list = List.above(e)\n      if (list && Editor.isStart(e, selection.focus, list[1])) {\n        List.unwrapList(e)\n        return\n      }\n    }\n    if (unit !== 'line') {\n      return deleteBackward(unit)\n    }\n\n    if (selection && Range.isCollapsed(selection)) {\n      const parentBlockEntry = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at: selection,\n      })\n\n      if (parentBlockEntry) {\n        const [, parentBlockPath] = parentBlockEntry\n        const parentElementRange = Editor.range(editor, parentBlockPath, selection.anchor)\n\n        const currentLineRange = findCurrentLineRange(e, parentElementRange)\n\n        if (!Range.isCollapsed(currentLineRange)) {\n          Transforms.delete(editor, { at: currentLineRange })\n        }\n      }\n    }\n  }\n\n  // This attempts to reset the NODE_TO_KEY entry to the correct value\n  // as apply() changes the object reference and hence invalidates the NODE_TO_KEY entry\n  e.apply = (op: Operation) => {\n    const matches: [Path, Key][] = []\n\n    switch (op.type) {\n      case 'insert_text':\n      case 'remove_text':\n      case 'set_node':\n      case 'split_node': {\n        matches.push(...getMatches(e, op.path))\n        break\n      }\n\n      case 'set_selection': {\n        break\n      }\n\n      case 'insert_node':\n      case 'remove_node': {\n        matches.push(...getMatches(e, Path.parent(op.path)))\n        break\n      }\n\n      case 'merge_node': {\n        const prevPath = Path.previous(op.path)\n        matches.push(...getMatches(e, prevPath))\n        break\n      }\n\n      case 'move_node': {\n        const commonPath = Path.common(Path.parent(op.path), Path.parent(op.newPath))\n        matches.push(...getMatches(e, commonPath))\n        break\n      }\n    }\n\n    apply(op)\n\n    for (const [path, key] of matches) {\n      const [node] = Editor.node(e, path)\n      NODE_TO_KEY.set(node, key)\n    }\n    if (!Editable.isFocused(e) && canForceTakeFocus()) {\n      e.focus()\n    }\n  }\n\n  e.on = (type, handler, prepend) => {\n    EventEmitter.on(e, type, handler, prepend)\n  }\n\n  e.off = (type, handler) => {\n    EventEmitter.off(e, type, handler)\n  }\n\n  e.once = (type, handler, prepend) => {\n    EventEmitter.on(e, type, handler, prepend)\n  }\n\n  e.emit = (type, ...args) => {\n    EventEmitter.emit(e, type, ...args)\n  }\n\n  let prevSelection: Range | null = null\n  let prevAnchorNode: Node | null = null\n  let prevFocusNode: Node | null = null\n\n  e.onChange = () => {\n    if (\n      ((!prevSelection || !e.selection) && prevSelection !== e.selection) ||\n      (prevSelection &&\n        e.selection &&\n        (!Range.equals(prevSelection, e.selection) ||\n          prevAnchorNode !== Node.get(e, e.selection.anchor.path) ||\n          prevFocusNode !== Node.get(e, e.selection.focus.path)))\n    ) {\n      e.onSelectionChange()\n      prevSelection = e.selection ? Object.assign({}, e.selection) : null\n      prevAnchorNode = e.selection ? Node.get(e, e.selection.anchor.path) : null\n      prevFocusNode = e.selection ? Node.get(e, e.selection.focus.path) : null\n    }\n    Placeholder.refresh(e)\n    onChange()\n    e.emit('change')\n  }\n\n  e.blur = (): void => {\n    const shadow = EDITOR_TO_SHADOW.get(editor)\n    const textarea = EDITOR_TO_INPUT.get(editor)\n    if (textarea && shadow && shadow.activeElement !== textarea) {\n      textarea.blur()\n    }\n  }\n  /**\n   * Focus the editor.\n   */\n  e.focus = (start): void => {\n    if (!editor.selection) {\n      const path = Editable.findPath(e, e)\n      const point = start ? Editor.start(e, path) : Editor.end(e, path)\n      Transforms.select(e, point)\n    } else if (start === true) {\n      const path = Editable.findPath(e, e)\n      Transforms.select(e, Editor.start(e, path))\n    } else if (start === false) {\n      const path = Editable.findPath(e, e)\n      Transforms.select(e, Editor.end(e, path))\n    }\n\n    const shadow = EDITOR_TO_SHADOW.get(editor)\n    const textarea = EDITOR_TO_INPUT.get(editor)\n    if (textarea && shadow && shadow.activeElement !== textarea) {\n      textarea.focus({ preventScroll: true })\n    }\n  }\n\n  e.selectWord = (options = {}) => {\n    const { at, edge = 'focus' } = options\n    if (at) {\n      Transforms.select(e, at)\n    }\n    const { selection } = e\n    if (!selection) return\n    const point = ['focus', 'end'].includes(edge) ? Range.end(selection) : Range.start(selection)\n    const { text, offset } = Editable.findTextOffsetOnLine(e, point)\n    if (text) {\n      const { path } = point\n      const [startOffset, endOffset] = getWordRange(text, offset)\n      Transforms.select(e, {\n        anchor: Editable.findPointOnLine(e, path, startOffset, true),\n        focus: Editable.findPointOnLine(e, path, endOffset),\n      })\n      e.onSelectEnd()\n    }\n  }\n\n  e.selectLine = (options = {}) => {\n    const { at, edge = 'focus' } = options\n    if (at) {\n      Transforms.select(e, at)\n    }\n    const { selection } = e\n    if (!selection) return\n    const point = ['focus', 'end'].includes(edge) ? Range.end(selection) : Range.start(selection)\n    const { path } = point\n    const node = Node.get(e, path)\n    let linePath = path\n    if (!Editor.isBlock(e, node)) {\n      const block = Editor.above(e, {\n        match: n => Editor.isBlock(e, n),\n        at: path,\n      })\n\n      linePath = block?.[1] ?? path.slice(0, 1)\n    }\n\n    const range = Editor.range(e, linePath)\n    Transforms.select(e, range)\n    e.onSelectEnd()\n  }\n\n  e.onKeyup = (event: KeyboardEvent) => {\n    if (event.key.toLowerCase() === 'shift') {\n      IS_SHIFT_PRESSED.set(editor, false)\n    }\n    e.emit('keyup', event)\n  }\n\n  e.onFocus = () => {\n    e.focus()\n    Placeholder.refresh(e)\n    e.emit('focus')\n  }\n\n  e.onBlur = () => {\n    Placeholder.refresh(e)\n    e.emit('blur')\n  }\n\n  e.onSelectStart = () => {\n    e.emit('selectstart')\n  }\n\n  e.onSelecting = () => {\n    e.emit('selecting')\n  }\n\n  e.onSelectEnd = () => {\n    e.emit('selectend')\n  }\n\n  e.onSelectionChange = () => {\n    e.emit('selectionchange')\n  }\n\n  e.onTouchHold = event => {\n    e.emit('touchhold', event)\n  }\n\n  e.onTouchTrack = () => {\n    e.emit('touchtrack')\n  }\n\n  e.onContextMenu = event => {\n    e.emit('contextmenu', event)\n  }\n\n  e.onDestory = () => {\n    e.emit('destory')\n  }\n\n  e.renderElementAttributes = ({ attributes }) => {\n    return attributes\n  }\n\n  e.renderLeafAttributes = ({ attributes }) => {\n    return attributes\n  }\n\n  e.renderElement = (props: RenderElementProps) => {\n    const { attributes, children, element } = props\n    const Tag = e.isInline(element) ? 'span' : 'div'\n    return <Tag {...attributes}>{children}</Tag>\n  }\n\n  e.renderLeaf = (props: RenderLeafProps) => {\n    const { attributes, children } = props\n    return <span {...attributes}>{children}</span>\n  }\n\n  e.renderPlaceholder = ({ attributes, children }) => {\n    return (\n      <span\n        style={{\n          pointerEvents: 'none',\n          userSelect: 'none',\n          width: '100%',\n        }}\n      >\n        <span\n          style={{\n            position: 'absolute',\n            opacity: '0.333',\n            width: 'fit-content',\n            whiteSpace: 'nowrap',\n            textIndent: 'initial',\n            textOverflow: 'ellipsis',\n            maxWidth: '100%',\n            overflow: 'hidden',\n          }}\n          {...attributes}\n        >\n          {children}\n        </span>\n      </span>\n    )\n  }\n\n  const { insertBreak } = e\n\n  e.insertBreak = () => {\n    const { selection } = editor\n\n    if (!Editable.isEditor(editor) || !selection || Range.isExpanded(selection)) {\n      insertBreak()\n      return\n    }\n    const entrie = List.above(editor)\n    if (!entrie) {\n      insertBreak()\n      return\n    }\n    List.splitList(editor)\n  }\n\n  e.insertFile = (_, range) => {\n    if (range) {\n      Transforms.select(e, range)\n    }\n  }\n\n  return e\n}\n\nconst getMatches = (e: Editable, path: Path) => {\n  const matches: [Path, Key][] = []\n  for (const [n, p] of Editor.levels(e, { at: path })) {\n    const key = Editable.findKey(e, n)\n    matches.push([p, key])\n  }\n  return matches\n}\n","/**\n * Utilities for single-line deletion\n */\n\nimport { Range, Editor } from '@editablejs/models'\nimport { Editable } from '../plugin/editable'\n\nconst doRectsIntersect = (rect: DOMRect, compareRect: DOMRect) => {\n  const middle = (compareRect.top + compareRect.bottom) / 2\n\n  return rect.top <= middle && rect.bottom >= middle\n}\n\nconst areRangesSameLine = (editor: Editable, range1: Range, range2: Range) => {\n  const rect1 = Editable.toDOMRange(editor, range1).getBoundingClientRect()\n  const rect2 = Editable.toDOMRange(editor, range2).getBoundingClientRect()\n\n  return doRectsIntersect(rect1, rect2) && doRectsIntersect(rect2, rect1)\n}\n\n/**\n * A helper utility that returns the end portion of a `Range`\n * which is located on a single line.\n *\n * @param {Editor} editor The editor object to compare against\n * @param {Range} parentRange The parent range to compare against\n * @returns {Range} A valid portion of the parentRange which is one a single line\n */\nexport const findCurrentLineRange = (editor: Editable, parentRange: Range): Range => {\n  const parentRangeBoundary = Editor.range(editor, Range.end(parentRange))\n  const positions = Array.from(Editor.positions(editor, { at: parentRange }))\n\n  let left = 0\n  let right = positions.length\n  let middle = Math.floor(right / 2)\n\n  if (areRangesSameLine(editor, Editor.range(editor, positions[left]), parentRangeBoundary)) {\n    return Editor.range(editor, positions[left], parentRangeBoundary)\n  }\n\n  if (positions.length < 2) {\n    return Editor.range(editor, positions[positions.length - 1], parentRangeBoundary)\n  }\n\n  while (middle !== positions.length && middle !== left) {\n    if (areRangesSameLine(editor, Editor.range(editor, positions[middle]), parentRangeBoundary)) {\n      right = middle\n    } else {\n      left = middle\n    }\n\n    middle = Math.floor((left + right) / 2)\n  }\n\n  return Editor.range(editor, positions[right], parentRangeBoundary)\n}\n","export type Listener = (...args: any[]) => void\n\nexport class Emitter {\n  static listenerCount(emitter: Emitter, type: string | number): number {\n    return emitter.listenerCount(type)\n  }\n\n  static defaultMaxListeners: number = 10\n\n  events: Record<string | number, Listener | Listener[]> = {}\n\n  maxListeners: number | undefined = undefined\n\n  eventsCount = 0\n\n  listenerCount(type: string | number): number {\n    const evlistener = this.events[type]\n\n    if (typeof evlistener === 'function') {\n      return 1\n    } else if (evlistener !== undefined) {\n      return evlistener.length\n    }\n\n    return 0\n  }\n\n  eventNames(): Array<string | number> {\n    return Object.keys(this.events)\n  }\n\n  setMaxListeners(count: number): this {\n    this.maxListeners = count\n    return this\n  }\n\n  getMaxListeners(): number {\n    return this.maxListeners ?? Emitter.defaultMaxListeners\n  }\n\n  emit(type: string | number, ...args: any[]): boolean {\n    const handler = this.events[type]\n\n    if (handler === undefined) return false\n\n    if (typeof handler === 'function') {\n      handler(...args)\n    } else {\n      const len = handler.length\n      for (let i = 0; i < len; ++i) handler[i](...args)\n    }\n\n    return true\n  }\n\n  on(type: string | number, listener: Listener, prepend = false): this {\n    let existing = this.events[type]\n    if (existing === undefined) {\n      // Optimize the case of one listener. Don't need the extra array object.\n      this.events[type] = listener\n      ++this.eventsCount\n    } else {\n      if (typeof existing === 'function') {\n        // Adding the second element, need to change to array.\n        existing = this.events[type] = prepend ? [listener, existing] : [existing, listener]\n        // If we've already got an array, just append.\n      } else if (prepend) {\n        existing.unshift(listener)\n      } else {\n        existing.push(listener)\n      }\n\n      // Check for listener leak\n      const maxCount = this.getMaxListeners()\n      if (maxCount > 0 && existing.length > maxCount) {\n        // No error code for this since it is a Warning\n        // eslint-disable-next-line no-restricted-syntax\n        const e = new Error(\n          'Possible EventEmitter memory leak detected. ' +\n            existing.length +\n            ' ' +\n            String(type) +\n            ' listeners ' +\n            'added. Use emitter.setMaxListeners() to ' +\n            'increase limit',\n        )\n        console.warn(e)\n      }\n    }\n\n    return this\n  }\n\n  off(type: string | number, listener: Listener): this {\n    const list = this.events[type]\n    if (list === undefined) return this\n\n    if (list === listener) {\n      if (--this.eventsCount === 0) this.events = {}\n      else {\n        delete this.events[type]\n      }\n    } else if (typeof list !== 'function') {\n      let position = -1\n\n      for (let i = list.length - 1; i >= 0; i--) {\n        if (list[i] === listener) {\n          position = i\n          break\n        }\n      }\n\n      if (position < 0) return this\n\n      if (position === 0) list.shift()\n      else {\n        list.splice(position, 1)\n      }\n\n      if (list.length === 1) this.events[type] = list[0]\n    }\n\n    return this\n  }\n\n  once(type: string | number, listener: Listener, prepend = false): this {\n    const wrapper = (...args: any[]) => {\n      this.off(type, wrapper)\n      listener(...args)\n    }\n    return this.on(type, wrapper, prepend)\n  }\n}\n","import { Editable } from './editable'\nimport { Emitter } from './emitter'\n\nconst EDITOR_TO_EVENT: WeakMap<Editable, Emitter> = new WeakMap()\n\ntype EventEndingKey<\n  Set,\n  Needle extends string,\n  Key extends keyof Set = keyof Set,\n> = Key extends `${Needle}${infer _X}` ? (_X extends `` ? never : _X) : never\n\ntype EndingKey = EventEndingKey<Editable, 'on'>\n\nexport type EventType = Lowercase<EndingKey>\n\nexport type EventHandler<\n  T extends EventType,\n  Key extends EndingKey = EndingKey,\n> = Key extends `${Lowercase<Key>}`\n  ? never\n  : T extends Lowercase<Key>\n  ? Editable[`on${Key}`]\n  : never\n\nexport const EventEmitter = {\n  get: (editor: Editable) => {\n    let event = EDITOR_TO_EVENT.get(editor)\n    if (!event) {\n      event = new Emitter()\n      EDITOR_TO_EVENT.set(editor, event)\n    }\n    return event\n  },\n  on: <T extends EventType>(\n    editor: Editable,\n    type: T,\n    handler: EventHandler<T>,\n    prepend = false,\n  ) => {\n    EventEmitter.get(editor).on(type, handler, prepend)\n  },\n\n  off: <T extends EventType>(editor: Editable, type: T, handler: EventHandler<T>) => {\n    EventEmitter.get(editor).off(type, handler)\n  },\n\n  once: <T extends EventType>(\n    editor: Editable,\n    type: T,\n    handler: EventHandler<T>,\n    prepend = false,\n  ) => {\n    EventEmitter.get(editor).once(type, handler, prepend)\n  },\n\n  emit: <T extends EventType>(editor: Editable, type: T, ...args: Parameters<EventHandler<T>>) => {\n    EventEmitter.get(editor).emit(type, ...args)\n  },\n}\n","import { CompositionText, Editor, Transforms, Range, Text } from '@editablejs/models'\nimport { IS_COMPOSING } from '../utils/weak-maps'\nimport { Editable } from './editable'\n\nexport const withInput = <T extends Editor>(editor: T) => {\n  const e = editor as T & Editable\n\n  e.onInput = (value: string) => {\n    if (!editor.selection) return\n    if (Editable.isComposing(editor)) {\n      const { selection, marks } = editor\n      let [node, path] = Editor.node(editor, selection)\n      if (marks) {\n        // 使用零宽字符绕过slate里面不能插入空字符的问题。组合输入法完成后会删除掉\n        const compositionText: CompositionText = {\n          text: '\\u200b',\n          ...marks,\n          composition: {\n            text: value,\n            offset: 0,\n            isEmpty: true,\n          },\n        }\n        Transforms.insertNodes(editor, compositionText)\n        e.marks = null\n      } else if (Text.isText(node)) {\n        const composition = CompositionText.isCompositionText(node) ? node.composition : null\n        const offset = composition?.offset ?? Range.start(selection).offset\n\n        Transforms.setNodes<CompositionText>(\n          editor,\n          {\n            composition: {\n              ...composition,\n              text: value,\n              offset,\n            },\n          },\n          { at: path },\n        )\n        const point = { path, offset: offset + value.length }\n        Transforms.select(editor, {\n          anchor: point,\n          focus: point,\n        })\n      }\n    } else {\n      editor.insertText(value)\n    }\n    e.emit('input', value)\n  }\n\n  e.onBeforeInput = value => {\n    e.emit('beforeinput', value)\n  }\n\n  e.onCompositionStart = data => {\n    if (editor.selection && Range.isExpanded(editor.selection)) {\n      Editor.deleteFragment(editor)\n    }\n    IS_COMPOSING.set(editor, true)\n    e.emit('compositionstart', data)\n  }\n\n  e.onCompositionEnd = (value: string) => {\n    const { selection } = editor\n    if (!selection) return\n    const [node, path] = Editor.node(editor, selection)\n    if (Text.isText(node)) {\n      const composition = CompositionText.isCompositionText(node) ? node.composition : null\n      Transforms.setNodes<CompositionText>(\n        editor,\n        {\n          composition: undefined,\n        },\n        { at: path },\n      )\n      const point = { path, offset: composition?.offset ?? selection.anchor.offset }\n      const range = composition?.isEmpty\n        ? {\n            anchor: { path, offset: 0 },\n            focus: { path, offset: 1 },\n          }\n        : point\n      Transforms.select(editor, range)\n\n      IS_COMPOSING.set(editor, false)\n      Transforms.insertText(editor, value)\n    }\n    e.emit('compositionend', value)\n  }\n\n  return e\n}\n","import { Editor, Transforms, Node, Range } from '@editablejs/models'\nimport getDirection from 'direction'\nimport Hotkeys from '../utils/hotkeys'\nimport { getWordOffsetBackward, getWordOffsetForward } from '../utils/text'\nimport { IS_PASTE_TEXT, IS_SHIFT_PRESSED } from '../utils/weak-maps'\nimport { Editable } from './editable'\n\nexport const withKeydown = <T extends Editor>(editor: T) => {\n  const e = editor as T & Editable\n\n  e.onKeydown = (event: KeyboardEvent) => {\n    e.emit('keydown', event)\n    if (event.defaultPrevented) return\n    const { selection } = editor\n    const element = editor.children[selection !== null ? selection.focus.path[0] : 0]\n    const isRTL = getDirection(Node.string(element)) === 'rtl'\n\n    if (Hotkeys.isShift(event)) {\n      IS_SHIFT_PRESSED.set(e, true)\n    }\n\n    if (Hotkeys.isSelectAll(event)) {\n      event.preventDefault()\n      Transforms.select(e, Editor.range(e, []))\n      return\n    }\n\n    if (Hotkeys.isCut(event)) {\n      event.preventDefault()\n      e.cut()\n      return\n    }\n\n    if (Hotkeys.isCopy(event)) {\n      event.preventDefault()\n      e.copy()\n      return\n    }\n\n    if (Hotkeys.isPaste(event)) {\n      IS_PASTE_TEXT.set(e, false)\n      return\n    }\n\n    if (Hotkeys.isPasteText(event)) {\n      IS_PASTE_TEXT.set(e, true)\n      return\n    }\n\n    if (Hotkeys.isExtendForward(event)) {\n      event.preventDefault()\n      Transforms.move(e, { edge: 'focus' })\n      return\n    }\n\n    if (Hotkeys.isExtendBackward(event)) {\n      event.preventDefault()\n      Transforms.move(e, { edge: 'focus', reverse: true })\n      return\n    }\n\n    if (Hotkeys.isExtendUp(event)) {\n      event.preventDefault()\n      const point = Editable.findPreviousLinePoint(e)\n      if (point && selection)\n        Transforms.select(editor, {\n          anchor: selection.anchor,\n          focus: point,\n        })\n      return\n    }\n\n    if (Hotkeys.isExtendDown(event)) {\n      event.preventDefault()\n      const point = Editable.findNextLinePoint(e)\n      if (point && selection)\n        Transforms.select(editor, {\n          anchor: selection.anchor,\n          focus: point,\n        })\n      return\n    }\n\n    if (Hotkeys.isMoveUp(event)) {\n      event.preventDefault()\n      const point = Editable.findPreviousLinePoint(e)\n      if (point) Transforms.select(editor, point)\n      return\n    }\n\n    if (Hotkeys.isMoveDown(event)) {\n      event.preventDefault()\n      const point = Editable.findNextLinePoint(e)\n      if (point) Transforms.select(editor, point)\n      return\n    }\n\n    if (Hotkeys.isExtendLineBackward(event)) {\n      event.preventDefault()\n      Transforms.move(e, {\n        unit: 'line',\n        edge: 'focus',\n        reverse: true,\n      })\n      return\n    }\n\n    if (Hotkeys.isExtendLineForward(event)) {\n      event.preventDefault()\n      Transforms.move(e, { unit: 'line', edge: 'focus' })\n      return\n    }\n\n    if (Hotkeys.isMoveWordBackward(event)) {\n      event.preventDefault()\n\n      if (selection && Range.isExpanded(selection)) {\n        Transforms.collapse(editor, { edge: 'focus' })\n      }\n      if (selection) {\n        const { focus } = selection\n        const { path: focusPath } = focus\n        if (Editor.isStart(editor, focus, focusPath)) {\n          Transforms.move(e, { reverse: !isRTL })\n          return\n        }\n        const { text, offset } = Editable.findTextOffsetOnLine(e, focus)\n        if (text) {\n          const wordOffset = getWordOffsetBackward(text, offset)\n          const newPoint = Editable.findPointOnLine(e, focusPath, wordOffset)\n          Transforms.select(editor, newPoint)\n          return\n        }\n      }\n      Transforms.move(e, { unit: 'word', reverse: !isRTL })\n      return\n    }\n\n    if (Hotkeys.isMoveWordForward(event)) {\n      event.preventDefault()\n\n      if (selection && Range.isExpanded(selection)) {\n        Transforms.collapse(editor, { edge: 'focus' })\n      }\n      if (selection) {\n        const { focus } = selection\n        const { path: focusPath } = focus\n        if (Editor.isEnd(editor, focus, focusPath)) {\n          Transforms.move(e, { reverse: isRTL })\n          return\n        }\n        const { text, offset } = Editable.findTextOffsetOnLine(e, focus)\n        if (text) {\n          const wordOffset = getWordOffsetForward(text, offset)\n          Transforms.select(editor, Editable.findPointOnLine(e, focusPath, wordOffset))\n          return\n        }\n      }\n      Transforms.move(e, { unit: 'word', reverse: isRTL })\n      return\n    }\n\n    if (Hotkeys.isMoveBackward(event)) {\n      event.preventDefault()\n\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms.move(e, { reverse: !isRTL })\n      } else {\n        Transforms.collapse(editor, { edge: 'start' })\n      }\n\n      return\n    }\n\n    if (Hotkeys.isMoveForward(event)) {\n      event.preventDefault()\n\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms.move(e, { reverse: isRTL })\n      } else {\n        Transforms.collapse(editor, { edge: 'end' })\n      }\n\n      return\n    }\n\n    if (Hotkeys.isMoveLineStart(event)) {\n      event.preventDefault()\n\n      const point = Editable.findLineEdgePoint(e)\n      if (point) {\n        Transforms.select(editor, point)\n      }\n\n      return\n    }\n\n    if (Hotkeys.isMoveLineEnd(event)) {\n      event.preventDefault()\n\n      const point = Editable.findLineEdgePoint(e, { edge: 'end' })\n      if (point) {\n        Transforms.select(editor, point)\n      }\n\n      return\n    }\n\n    if (Hotkeys.isMoveEditorStart(event)) {\n      event.preventDefault()\n\n      e.focus(true)\n\n      return\n    }\n\n    if (Hotkeys.isMoveEditorEnd(event)) {\n      event.preventDefault()\n\n      e.focus(false)\n\n      return\n    }\n\n    if (Hotkeys.isSoftBreak(event)) {\n      event.preventDefault()\n      Editor.insertSoftBreak(editor)\n      return\n    }\n\n    if (Hotkeys.isSplitBlock(event)) {\n      event.preventDefault()\n      Editor.insertBreak(editor)\n      return\n    }\n\n    if (Hotkeys.isDeleteBackward(event)) {\n      event.preventDefault()\n      if (selection && Range.isExpanded(selection)) {\n        Editor.deleteFragment(editor)\n      } else {\n        Editor.deleteBackward(editor)\n      }\n      return\n    }\n\n    if (Hotkeys.isDeleteForward(event)) {\n      event.preventDefault()\n\n      if (selection && Range.isExpanded(selection)) {\n        Editor.deleteFragment(editor, { direction: 'forward' })\n      } else {\n        Editor.deleteForward(editor)\n      }\n\n      return\n    }\n\n    if (Hotkeys.isDeleteLineBackward(event)) {\n      event.preventDefault()\n\n      if (selection && Range.isExpanded(selection)) {\n        Editor.deleteFragment(editor, { direction: 'backward' })\n      } else {\n        Editor.deleteBackward(editor, { unit: 'line' })\n      }\n\n      return\n    }\n\n    if (Hotkeys.isDeleteLineForward(event)) {\n      event.preventDefault()\n\n      if (selection && Range.isExpanded(selection)) {\n        Editor.deleteFragment(editor, { direction: 'forward' })\n      } else {\n        Editor.deleteForward(editor, { unit: 'line' })\n      }\n\n      return\n    }\n\n    if (Hotkeys.isDeleteWordBackward(event)) {\n      event.preventDefault()\n\n      if (selection && Range.isExpanded(selection)) {\n        Editor.deleteFragment(editor, { direction: 'backward' })\n      } else {\n        Editor.deleteBackward(editor, { unit: 'word' })\n      }\n\n      return\n    }\n\n    if (Hotkeys.isDeleteWordForward(event)) {\n      event.preventDefault()\n\n      if (selection && Range.isExpanded(selection)) {\n        Editor.deleteFragment(editor, { direction: 'forward' })\n      } else {\n        Editor.deleteForward(editor, { unit: 'word' })\n      }\n\n      return\n    }\n  }\n}\n","import { isHotkey, isCodeHotkey, isKeyHotkey } from 'is-hotkey'\nimport { IS_APPLE } from './environment'\n\n/**\n * Hotkey mappings for each platform.\n */\n\nconst HOTKEYS: Record<string, string | string[]> = {\n  compose: ['down', 'left', 'right', 'up', 'backspace', 'enter'],\n  selectAll: 'mod+a',\n  cut: 'mod+x',\n  copy: 'mod+c',\n  paste: 'mod+v',\n  pasteText: 'mod+shift+v',\n  moveUp: 'up',\n  moveDown: 'down',\n  moveBackward: 'left',\n  moveForward: 'right',\n  shift: 'shift',\n  moveWordBackward: 'ctrl+left',\n  moveWordForward: 'ctrl+right',\n  extendUp: 'shift+up',\n  extendDown: 'shift+down',\n  deleteBackward: 'shift?+backspace',\n  deleteForward: 'shift?+delete',\n  extendBackward: 'shift+left',\n  extendForward: 'shift+right',\n  insertSoftBreak: 'shift+enter',\n  splitBlock: 'enter',\n  undo: 'mod+z',\n}\n\nconst APPLE_HOTKEYS: Record<string, string | string[]> = {\n  moveLineBackward: 'opt+up',\n  moveLineForward: 'opt+down',\n  moveWordBackward: 'opt+left',\n  moveWordForward: 'opt+right',\n  moveLineStart: 'cmd+left',\n  moveLineEnd: 'cmd+right',\n  moveEditorStart: 'cmd+up',\n  moveEditorEnd: 'cmd+down',\n  deleteBackward: ['ctrl+backspace', 'ctrl+h'],\n  deleteForward: ['ctrl+delete', 'ctrl+d'],\n  deleteLineBackward: 'cmd+shift?+backspace',\n  deleteLineForward: ['cmd+shift?+delete', 'ctrl+k'],\n  deleteWordBackward: 'opt+shift?+backspace',\n  deleteWordForward: 'opt+shift?+delete',\n  extendLineBackward: 'opt+shift+up',\n  extendLineForward: 'opt+shift+down',\n  redo: 'cmd+shift+z',\n  transposeCharacter: 'ctrl+t',\n}\n\nconst WINDOWS_HOTKEYS: Record<string, string | string[]> = {\n  deleteWordBackward: 'ctrl+shift?+backspace',\n  deleteWordForward: 'ctrl+shift?+delete',\n  redo: ['ctrl+y', 'ctrl+shift+z'],\n}\n\n/**\n * Create a platform-aware hotkey checker.\n */\n\nconst create = (key: string) => {\n  const generic = HOTKEYS[key]\n  const apple = APPLE_HOTKEYS[key]\n  const windows = WINDOWS_HOTKEYS[key]\n  const isGeneric = generic && isKeyHotkey(generic)\n  const isApple = apple && isKeyHotkey(apple)\n  const isWindows = windows && isKeyHotkey(windows)\n\n  return (event: KeyboardEvent) => {\n    if (isGeneric && isGeneric(event)) return true\n    if (IS_APPLE && isApple && isApple(event)) return true\n    if (!IS_APPLE && isWindows && isWindows(event)) return true\n    return false\n  }\n}\n\n/**\n * Hotkeys.\n */\n\nconst Hotkeys = {\n  isSelectAll: create('selectAll'),\n  isCut: create('cut'),\n  isCopy: create('copy'),\n  isPaste: create('paste'),\n  isPasteText: create('pasteText'),\n  isMoveUp: create('moveUp'),\n  isMoveDown: create('moveDown'),\n  isCompose: create('compose'),\n  isMoveBackward: create('moveBackward'),\n  isMoveForward: create('moveForward'),\n  isDeleteBackward: create('deleteBackward'),\n  isDeleteForward: create('deleteForward'),\n  isDeleteLineBackward: create('deleteLineBackward'),\n  isDeleteLineForward: create('deleteLineForward'),\n  isDeleteWordBackward: create('deleteWordBackward'),\n  isDeleteWordForward: create('deleteWordForward'),\n  isExtendUp: create('extendUp'),\n  isExtendDown: create('extendDown'),\n  isExtendBackward: create('extendBackward'),\n  isExtendForward: create('extendForward'),\n  isExtendLineBackward: create('extendLineBackward'),\n  isExtendLineForward: create('extendLineForward'),\n  isMoveLineBackward: create('moveLineBackward'),\n  isMoveLineForward: create('moveLineForward'),\n  isMoveWordBackward: create('moveWordBackward'),\n  isMoveWordForward: create('moveWordForward'),\n  isMoveLineStart: create('moveLineStart'),\n  isMoveLineEnd: create('moveLineEnd'),\n  isMoveEditorStart: create('moveEditorStart'),\n  isMoveEditorEnd: create('moveEditorEnd'),\n  isShift: create('shift'),\n  isRedo: create('redo'),\n  isSoftBreak: create('insertSoftBreak'),\n  isSplitBlock: create('splitBlock'),\n  isTransposeCharacter: create('transposeCharacter'),\n  isUndo: create('undo'),\n}\n\nexport default Hotkeys\n\nfunction match(\n  keys: string | string[] | ((e: KeyboardEvent) => boolean),\n  event: KeyboardEvent,\n): boolean\nfunction match<T extends string = string>(\n  keys: Record<T, string | string[] | ((e: KeyboardEvent) => boolean)>,\n  event: KeyboardEvent,\n): T | false\nfunction match<T extends string = string>(\n  keys:\n    | string\n    | string[]\n    | ((e: KeyboardEvent) => boolean)\n    | Record<T, string | string[] | ((e: KeyboardEvent) => boolean)>,\n  event: KeyboardEvent,\n): T | boolean {\n  if (typeof keys === 'string' || Array.isArray(keys)) {\n    return isHotkey(keys, event)\n  } else if (typeof keys === 'function') {\n    return keys(event)\n  } else {\n    for (const key in keys) {\n      const value = keys[key]\n      if (match(value, event)) {\n        return key\n      }\n    }\n  }\n  return false\n}\nexport const Hotkey = {\n  isCode: isCodeHotkey,\n  isKey: isKeyHotkey,\n  format: (key: string, char = '+') => {\n    let keys = key.toLowerCase().split('+')\n    keys = keys.map(key => {\n      if (key === 'mod') {\n        return IS_APPLE ? '⌘' : 'Ctrl'\n      } else if (key === 'opt') {\n        return IS_APPLE ? 'Option' : 'Alt'\n      } else if (key.length > 1) {\n        return key.substring(0, 1).toUpperCase() + key.substring(1).toLowerCase()\n      }\n      return key.toUpperCase()\n    })\n    return keys.join(char)\n  },\n  match,\n}\n","import { Editor, Transforms, Node, Path } from '@editablejs/models'\nimport { Editable } from './editable'\n\nexport const withNormalizeNode = <T extends Editor>(editor: T) => {\n  const e = editor as T & Editable\n\n  const { normalizeNode } = editor\n\n  e.normalizeNode = entry => {\n    const [node, path] = entry\n    if (Editor.isBlock(e, node)) {\n      const { type, ...attributes } = node\n      let isUnwrap = false\n      const isParagraph = !type || type === 'paragraph'\n      // 相同type类的block不嵌套，paragraph 下不能嵌套block节点\n      for (const [child, childPath] of Node.children(editor, path)) {\n        if (Editor.isBlock(e, child)) {\n          if (!isUnwrap && !isParagraph && child.type === type) {\n            Transforms.unwrapNodes(editor, { at: childPath })\n            return\n          } else if (isParagraph) {\n            Transforms.setNodes(editor, attributes, { at: childPath })\n            isUnwrap = true\n          }\n        }\n      }\n      if (isUnwrap) {\n        Transforms.unwrapNodes(editor, { at: path })\n        return\n      }\n    }\n    normalizeNode(entry)\n  }\n\n  return e\n}\n","import { HTMLDeserializer } from '@editablejs/deserializer/html'\nimport { Editor, Transforms, Range, Node } from '@editablejs/models'\nimport { HTMLSerializer } from '@editablejs/serializer/html'\nimport { TextSerializer } from '@editablejs/serializer/text'\nimport { readClipboardData, writeClipboardData } from '../utils/clipboard'\nimport {\n  APPLICATION_FRAGMENT_TYPE,\n  DATA_EDITABLE_FRAGMENT,\n  TEXT_HTML,\n  TEXT_PLAIN,\n} from '../utils/constants'\nimport { fragmentToString, parseDataTransfer } from '../utils/data-transfer'\nimport { IS_PASTE_TEXT } from '../utils/weak-maps'\nimport { Editable } from './editable'\n\nexport const withDataTransfer = <T extends Editor>(editor: T) => {\n  const e = editor as T & Editable\n\n  e.toDataTransfer = range => {\n    const fragment = e.getFragment(range)\n    const fragmentString = fragmentToString(fragment)\n\n    const text = fragment.map(node => TextSerializer.transformWithEditor(e, node)).join('\\n')\n\n    let html = fragment.map(node => HTMLSerializer.transformWithEditor(e, node)).join('')\n    html = `<div ${DATA_EDITABLE_FRAGMENT}=\"${fragmentString}\">${html}</div>`\n    html = `<html><head><meta name=\"source\" content=\"${DATA_EDITABLE_FRAGMENT}\" /></head><body>${html}</body></html>`\n    const dataTransfer = new DataTransfer()\n    dataTransfer.setData(TEXT_PLAIN, text)\n    dataTransfer.setData(TEXT_HTML, html)\n    dataTransfer.setData(APPLICATION_FRAGMENT_TYPE, fragmentString)\n    return dataTransfer\n  }\n\n  e.onCut = event => {\n    if (event.defaultPrevented) return\n    const { selection } = e\n    const { clipboardData } = event\n    if (clipboardData) writeClipboardData(clipboardData)\n    if (selection) {\n      if (Range.isExpanded(selection)) {\n        Editor.deleteFragment(e)\n      } else {\n        const node = Node.parent(e, selection.anchor.path)\n        if (Editor.isVoid(e, node)) {\n          Transforms.delete(e)\n        }\n      }\n    }\n    e.emit('cut', event)\n  }\n\n  e.onCopy = event => {\n    if (event.defaultPrevented) return\n    const { clipboardData } = event\n    if (clipboardData) writeClipboardData(clipboardData)\n    e.emit('copy', event)\n  }\n\n  e.onPaste = event => {\n    if (event.defaultPrevented) return\n    const { clipboardData } = event\n    if (!clipboardData) return\n    event.preventDefault()\n    const { text, fragment, html, files } = parseDataTransfer(clipboardData)\n    const isPasteText = event.type === 'pasteText'\n    if (!isPasteText && fragment.length > 0) {\n      e.insertFragment(fragment)\n    } else if (!isPasteText && html) {\n      const document = new DOMParser().parseFromString(html, TEXT_HTML)\n      const fragment = HTMLDeserializer.transformWithEditor(e, document.body)\n      e.insertFragment(fragment)\n    } else {\n      const lines = text.split(/\\r\\n|\\r|\\n/)\n      let split = false\n\n      for (const line of lines) {\n        if (split) {\n          Transforms.splitNodes(e, { always: true })\n        }\n        e.normalizeSelection(selection => {\n          if (selection !== e.selection) e.selection = selection\n          e.insertText(line)\n        })\n        split = true\n      }\n    }\n    for (const file of files) {\n      e.insertFile(file)\n    }\n    e.emit('paste', event)\n  }\n\n  e.copy = range => {\n    const data = e.toDataTransfer(range)\n    const event = new ClipboardEvent('copy', { clipboardData: data })\n    e.onCopy(event)\n  }\n\n  e.cut = range => {\n    const data = e.toDataTransfer(range)\n    const event = new ClipboardEvent('copy', { clipboardData: data })\n    if (range) {\n      Transforms.select(e, range)\n    }\n    e.onCut(event)\n  }\n\n  e.insertFromClipboard = range => {\n    if (range) {\n      Transforms.select(e, range)\n    }\n    readClipboardData().then(data => {\n      const event = new ClipboardEvent('paste', { clipboardData: data })\n      e.onPaste(event)\n    })\n  }\n\n  e.insertTextFromClipboard = range => {\n    if (range) {\n      Transforms.select(e, range)\n    }\n    readClipboardData().then(data => {\n      IS_PASTE_TEXT.set(e, true)\n      const event = new ClipboardEvent('pasteText', { clipboardData: data })\n      e.onPaste(event)\n    })\n  }\n\n  return e\n}\n","import { APPLICATION_FRAGMENT_TYPE, TEXT_HTML, TEXT_PLAIN } from './constants'\nimport { matchFragmentStringFromHTML, parseDataTransferFiles } from './data-transfer'\nimport { isDOMHTMLElement } from '@editablejs/models'\n\nconst deselectCurrent = () => {\n  const selection = document.getSelection()\n  if (!selection?.rangeCount) {\n    return function () {}\n  }\n  let active: HTMLElement | null = null\n  let activeElement = document.activeElement\n  if (activeElement && activeElement.shadowRoot) {\n    activeElement = activeElement.shadowRoot.activeElement\n  }\n  if (isDOMHTMLElement(activeElement)) {\n    active = activeElement\n  }\n  const ranges: Range[] = []\n  for (var i = 0; i < selection.rangeCount; i++) {\n    ranges.push(selection.getRangeAt(i))\n  }\n  switch (\n    active?.tagName.toUpperCase() // .toUpperCase handles XHTML\n  ) {\n    case 'INPUT':\n    case 'TEXTAREA':\n      active.blur()\n      break\n\n    default:\n      active = null\n      break\n  }\n\n  selection.removeAllRanges()\n  return () => {\n    if (selection.type === 'Caret') {\n      selection.removeAllRanges()\n    }\n\n    if (!selection.rangeCount) {\n      ranges.forEach(range => {\n        selection.addRange(range)\n      })\n    }\n    if (active) {\n      active.focus()\n    }\n  }\n}\n\nexport const readClipboardDataByCommand = () => {\n  return new Promise<DataTransfer | null>((resolve, reject) => {\n    let textarea: HTMLTextAreaElement | null = null\n    let reselectPrevious: (() => void) | null = null\n\n    let selection: Selection | null = null\n    try {\n      reselectPrevious = deselectCurrent()\n\n      selection = document.getSelection()\n\n      textarea = document.createElement('textarea')\n      textarea.style.cssText = 'position: fixed; top: -9999; left: -9999; opacity: 0;'\n\n      textarea.addEventListener('paste', e => {\n        e.preventDefault()\n        e.stopPropagation()\n        resolve(e.clipboardData)\n      })\n\n      document.body.appendChild(textarea)\n\n      textarea.focus()\n\n      const successful = document.execCommand('paste')\n      if (!successful) throw new Error('paste failed')\n    } catch (error) {\n      reject(error)\n    } finally {\n      if (selection) {\n        selection.removeAllRanges()\n      }\n      if (textarea) document.body.removeChild(textarea)\n      if (reselectPrevious) reselectPrevious()\n    }\n  })\n}\n\nexport const readClipboardData = async () => {\n  let text = ''\n  let html = ''\n  let fragment = ''\n  const dataTransfer = new DataTransfer()\n  try {\n    const items = await navigator.clipboard.read()\n    for (const item of items) {\n      try {\n        text += await (await item.getType(TEXT_PLAIN)).text()\n      } catch {}\n      try {\n        html += await (await item.getType(TEXT_HTML)).text()\n      } catch {}\n      if (!fragment) {\n        try {\n          fragment = await (await item.getType(APPLICATION_FRAGMENT_TYPE)).text()\n        } catch (error) {\n          fragment = matchFragmentStringFromHTML(html)\n        }\n      }\n\n      for (const type of item.types) {\n        if (~[APPLICATION_FRAGMENT_TYPE, TEXT_PLAIN, TEXT_HTML].indexOf(type)) continue\n        const blob = await item.getType(type)\n        const file = new File([blob], 'unknow', {\n          type,\n        })\n        dataTransfer.items.add(file)\n      }\n    }\n  } catch (error) {\n    try {\n      const data = await readClipboardDataByCommand()\n      if (data) return data\n    } catch (error) {\n      console.error(error)\n    }\n  }\n  dataTransfer.setData(TEXT_PLAIN, text)\n  dataTransfer.setData(TEXT_HTML, html)\n  dataTransfer.setData(APPLICATION_FRAGMENT_TYPE, fragment)\n  return dataTransfer\n}\n\nexport const writeClipboardDataByCommand = (data: DataTransfer) => {\n  return new Promise<boolean>((resolve, reject) => {\n    let mark: HTMLElement | null = null\n    let reselectPrevious: (() => void) | null = null\n    let selection: Selection | null = null\n    let range: Range | null = null\n    try {\n      reselectPrevious = deselectCurrent()\n\n      range = document.createRange()\n      selection = document.getSelection()\n\n      mark = document.createElement('span')\n      mark.style.cssText = 'position: fixed; top: -9999;'\n      mark.ariaHidden = 'true'\n      mark.textContent = 'copy content'\n      mark.style.userSelect = 'text'\n      mark.addEventListener('copy', e => {\n        e.stopPropagation()\n        const { clipboardData } = e\n        if (clipboardData) {\n          e.preventDefault()\n          clipboardData.clearData()\n          clipboardData.setData(TEXT_PLAIN, data.getData(TEXT_PLAIN))\n          clipboardData.setData(TEXT_HTML, data.getData(TEXT_HTML))\n          clipboardData.setData(APPLICATION_FRAGMENT_TYPE, data.getData(APPLICATION_FRAGMENT_TYPE))\n          const files = parseDataTransferFiles(data)\n          for (const file of files) {\n            clipboardData.items.add(file)\n          }\n          resolve(true)\n        } else {\n          resolve(false)\n        }\n      })\n      document.body.appendChild(mark)\n\n      range.selectNodeContents(mark)\n      selection?.addRange(range)\n\n      const successful = document.execCommand('copy')\n      if (!successful) throw new Error('copy failed')\n    } catch (error) {\n      reject(error)\n    } finally {\n      if (selection) {\n        if (range && typeof selection.removeRange == 'function') {\n          selection.removeRange(range)\n        } else {\n          selection.removeAllRanges()\n        }\n      }\n      if (mark) document.body.removeChild(mark)\n      if (reselectPrevious) reselectPrevious()\n    }\n  })\n}\n\nexport const writeClipboardData = (data: DataTransfer) => {\n  try {\n    const files = parseDataTransferFiles(data)\n\n    navigator.clipboard.write([\n      new ClipboardItem({\n        [TEXT_PLAIN]: new Blob([data.getData(TEXT_PLAIN)], { type: TEXT_PLAIN }),\n        [TEXT_HTML]: new Blob([data.getData(TEXT_HTML)], { type: TEXT_HTML }),\n        // 当前不支持自定义类型\n        // https://github.com/w3c/editing/blob/gh-pages/docs/clipboard-pickling/explainer.md\n        // [APPLICATION_FRAGMENT_TYPE]: data.getData(APPLICATION_FRAGMENT_TYPE),\n        ...files.reduce((acc, file) => ({ ...acc, [file.type]: file }), {}),\n      }),\n    ])\n  } catch (error) {\n    try {\n      writeClipboardDataByCommand(data)\n    } catch (error) {\n      console.error(error)\n    }\n  }\n}\n"],"mappings":";;;;;;;AAAO,IAAM,4BAA4B;AAClC,IAAM,YAAY;AAClB,IAAM,aAAa;AACnB,IAAM,yBAAyB;AAC/B,IAAM,qBAAqB;AAC3B,IAAM,uBAAuB;AAC7B,IAAM,uBAAuB;AAC7B,IAAM,4BAA4B;AAClC,IAAM,2BAA2B;AACjC,IAAM,uBAAuB;AAC7B,IAAM,qBAAqB;AAC3B,IAAM,4BAA4B;AAClC,IAAM,qBAAqB;AAE3B,IAAM,YAAY;AAAA,EACvB,iBAAiB;AAAA,EACjB,UAAU;AAAA,EACV,WAAW;AAAA,EACX,cAAc;AAAA,EACd,UAAU;AAAA,EACV,YAAY;AAAA,EACZ,YAAY;AAAA,EACZ,iBAAiB;AAAA,EACjB,eAAe;AAAA,EACf,YAAY;AAAA,EACZ,UAAU;AAAA,EACV,iBAAiB;AAAA,EACjB,UAAU;AACZ;;;AC5BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAoBO,IAAM,mBAAmB,CAAC,aAA2B;AAC1D,QAAM,SAAS,KAAK,UAAU,QAAQ;AACtC,SAAO,OAAO,KAAK,mBAAmB,MAAM,CAAC;AAC/C;AAOO,IAAM,0BAA0B,CAAC,aAAmC;AACzE,QAAM,SAAS,mBAAmB,OAAO,KAAK,QAAQ,CAAC;AACvD,MAAI;AACF,WAAO,KAAK,MAAM,MAAM;AAAA,EAC1B,SAAS,OAAP;AACA,WAAO,CAAC;AAAA,EACV;AACF;AAOO,IAAM,8BAA8B,CAAC,SAAiB;AAC3D,QAAM,MAAM,IAAI,OAAO,GAAG,gCAAgC;AAC1D,SAAO,KAAK,MAAM,GAAG,IAAI,MAAM;AACjC;AAOO,IAAM,yBAAyB,CAAC,iBAA+B;AACpE,MAAI,QAAgB,CAAC;AAErB,MAAI;AACF,QAAI,aAAa,SAAS,aAAa,MAAM,SAAS,GAAG;AACvD,iBAAW,QAAQ,aAAa,OAAO;AACrC,YAAI,OAAO,KAAK,SAAS,SAAS,KAAK,UAAU,IAAI;AACrD,YAAI,SAAS,MAAM;AACjB,cAAI,KAAK,QAAQ,KAAK,KAAK,QAAQ,WAAW,IAAI,MAAM,CAAC,KAAK,cAAc;AAC1E,mBAAO,IAAI,KAAK,CAAC,IAAI,GAAG,aAAa;AAAA,cACnC,MAAM,KAAK;AAAA,YACb,CAAC;AAAA,UACH;AAAA,QACF;AACA,YAAI;AAAM,gBAAM,KAAK,IAAI;AAAA,MAC3B;AAAA,IACF,WAAW,aAAa,SAAS,aAAa,MAAM,SAAS,GAAG;AAC9D,cAAQ,MAAM,KAAK,aAAa,KAAK;AAAA,IACvC;AAAA,EACF,SAAS,KAAP;AACA,QAAI,aAAa,SAAS,aAAa,MAAM,SAAS,GAAG;AACvD,cAAQ,MAAM,KAAK,aAAa,KAAK;AAAA,IACvC;AAAA,EACF;AACA,SAAO;AACT;AAOO,IAAM,oBAAoB,CAAC,iBAAuD;AACvF,QAAM,OAAO,aAAa,QAAQ,UAAU;AAC5C,QAAM,OAAO,aAAa,QAAQ,SAAS;AAC3C,MAAI,WAAW,aAAa,QAAQ,yBAAyB;AAC7D,MAAI,CAAC;AAAU,eAAW,4BAA4B,IAAI;AAC1D,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA,UAAU,WAAW,wBAAwB,QAAQ,IAAI,CAAC;AAAA,IAC1D,OAAO,uBAAuB,YAAY;AAAA,EAC5C;AACF;AAOO,IAAM,kBAAkB,CAC7B,cACA,SACG;AACH,QAAM,EAAE,MAAM,MAAM,UAAU,MAAM,IAAI;AACxC,MAAI;AAAM,iBAAa,QAAQ,YAAY,IAAI;AAC/C,MAAI;AAAM,iBAAa,QAAQ,WAAW,IAAI;AAC9C,MAAI;AAAU,iBAAa,QAAQ,2BAA2B,iBAAiB,QAAQ,CAAC;AACxF,MAAI,OAAO;AACT,eAAW,QAAQ,OAAO;AACxB,mBAAa,MAAM,IAAI,IAAI;AAAA,IAC7B;AAAA,EACF;AACF;;;ACrHA,YAAYA,YAAW;AACvB,SAAS,YAAAC,iBAAgB;;;ACDzB,OAAO,WAAW;AAClB,OAAO,YAAyC;AAWhD,IAAM,yBAAgF,oBAAI,QAAQ;AAElG,IAAM,WAAW,CAAC,WAAmB;AACnC,MAAI,QAAQ,uBAAuB,IAAI,MAAM;AAC7C,MAAI,CAAC,OAAO;AACV,YAAQ,OAAoB,OAAO;AAAA,MACjC,MAAM;AAAA,MACN,SAAS,CAAC;AAAA,IACZ,EAAE;AACF,2BAAuB,IAAI,QAAQ,KAAK;AAAA,EAC1C;AACA,SAAO;AACT;AAEO,IAAM,SAAS;AAAA,EACpB;AAAA,EAEA,WAAW,CAAmB,WAAmB,YAAiC;AAChF,UAAM,QAAQ,SAAS,MAAM;AAC7B,UAAM,SAAS,WAAS;AACtB,YAAM,EAAE,MAAM,SAAS,YAAY,IAAI;AACvC,YAAM,aAAa,OAAO,OAAO,CAAC,GAAG,WAAW;AAChD,iBAAW,UAAU,SAAS;AAC5B,mBAAW,OAAO,QAAQ;AACxB,qBAAW,OAAO,MAAM,WAAW,MAAM,OAAO,IAAI;AAAA,QACtD;AAAA,MACF;AACA,aAAO;AAAA,QACL;AAAA,QACA,SAAS;AAAA,MACX;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEA,SAAS,CAAC,WAAmB;AAC3B,UAAM,QAAQ,SAAS,MAAM,EAAE,SAAS;AACxC,WAAO,MAAM;AAAA,EACf;AAAA,EAEA,SAAS,CAAC,QAAgB,SAAiB;AACzC,UAAM,QAAQ,SAAS,MAAM;AAC7B,UAAM,SAAS,WAAS;AACtB,aAAO;AAAA,QACL;AAAA,QACA,SAAS,MAAM;AAAA,MACjB;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEA,WAAW,CAAmB,WAAsB;AAClD,UAAM,OAAO,OAAO,QAAQ,MAAM;AAClC,UAAM,UAAU,OAAO,WAAW,MAAM;AACxC,WAAQ,QAAQ,SAAS,QAAQ;AAAA,EACnC;AAAA,EAEA,YAAY,CAAC,WAA2C;AACtD,UAAM,QAAQ,SAAS,MAAM,EAAE,SAAS;AACxC,WAAO,MAAM;AAAA,EACf;AACF;;;ACvEA,YAAY,WAAW;AACvB,SAAkC,gBAAgB;AAO3C,IAAM,mBAAmB,MAAM;AACpC,QAAM,WAAiB,iBAAW,oBAAoB;AACtD,MAAI,CAAC,UAAU;AACb,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAEA,SAAO,SAAS;AAClB;AAOO,IAAM,uBAA6B,oBAA2C,IAAI;AAMlF,IAAM,oBAAoB,MAAgB;AAC/C,QAAM,WAAiB,iBAAW,oBAAoB;AAEtD,MAAI,CAAC,UAAU;AACb,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAEA,SAAO,SAAS;AAClB;AAMO,IAAM,cAAc,MAAgB;AACzC,QAAM,QAAQ,iBAAiB;AAE/B,SAAO,SAAS,OAAO,WAAS;AAC9B,WAAO,MAAM;AAAA,EACf,CAAC,EAAE;AACL;;;AF9CO,IAAM,iBAAiB,CAAC,WAAqB;AAClD,SAAa,eAAQ,MAAM;AACzB,WAAO,OAAO,SAAS,MAAM;AAAA,EAC/B,GAAG,CAAC,MAAM,CAAC;AACb;AAEO,IAAM,UAAU,CAAC,WAA6B;AACnD,QAAM,QAAQ,eAAe,MAAM;AACnC,SAAOC,UAAS,OAAO,WAAS,MAAM,IAAI;AAC5C;AAEO,IAAM,YAAY,CAIvB,eACA,kBACS;AACT,QAAM,SAAS,kBAAkB;AACjC,QAAM,OAAO,QAAQ,MAAM;AAC3B,QAAM,gBAAgB,WAAc,QAAQ,IAAI;AAChD,QAAM,yBAAyB,cAAc;AAE7C,QAAM,kBAAwB,eAAQ,MAAM;AAC1C,UAAM,SAAS,0BAA0B;AACzC,WAAO;AAAA,MACL,GAAI,kBAAkB,WAAW,OAAO,IAAI;AAAA,IAC9C;AAAA,EACF,GAAG,CAAC,eAAe,sBAAsB,CAAC;AAE1C,SAAO;AACT;AAEO,IAAM,aAAa,CAAmB,QAAkB,SAAoB;AACjF,QAAM,QAAQ,eAAe,MAAM;AAEnC,QAAM,UAAUA,UAAS,OAAO,WAAS,MAAM,QAAQ,SAAS,MAAM,QAAQ,QAAQ;AACtF,SAAO;AACT;AAEO,IAAM,kBAAkB,CAI7B,kBACG;AACH,QAAM,SAAS,UAAa,aAAa;AACzC,SAAO;AAAA,IACL,QAAQ,CAAC,KAA0B,YAA8C;AAC/E,YAAM,QAAQ,OAAO;AACrB,UAAI,OAAO,UAAU,UAAU;AAC7B,YAAI,CAAC;AAAS,iBAAO;AACrB,eAAO,MAAM,QAAQ,YAAY,CAACC,QAAOC,SAAQ,OAAO,QAAQA,KAAI,KAAKD,MAAK;AAAA,MAChF;AACA,aAAO;AAAA,IACT;AAAA,EACF;AACF;;;AG/DA,YAAYE,aAAW;AACvB;AAAA,EACE,UAAAC;AAAA,EACA,SAAAC;AAAA,EACA,cAAAC;AAAA,EACA,SAAAC;AAAA,EACA,QAAAC;AAAA,EACA,WAAAC;AAAA,EAEA;AAAA,EACA,aAAAC;AAAA,OACK;;;ACXP,SAAS,UAAAC,SAAQ,SAAAC,QAAO,WAAAC,gBAAqC;;;ACA7D,YAAYC,YAAW;AACvB,OAAO,kBAAkB;AACzB,SAAS,UAAAC,SAAQ,QAAAC,OAAM,SAAAC,cAAsC;;;ACF7D,YAAYC,YAAW;AACvB,SAAkB,QAAQ,iBAAiB;;;ACD3C,YAAYC,YAAW;;;ACCvB,SAAS,UAAAC,SAAc,QAAAC,OAAe,QAAAC,OAAM,uBAAuB;;;ACDnE;AAAA,EACE,UAAAC;AAAA,EACA,QAAAC;AAAA,EACA;AAAA,EACA,WAAAC;AAAA,EACA,QAAAC;AAAA,EAEA,SAAAC;AAAA,EACA;AAAA,EACA;AAAA,EAEA;AAAA,EAOA,gBAAAC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;;;ACfA,IAAM,gBAAuC,oBAAI,QAAQ;AACzD,IAAM,iBAA0C,oBAAI,QAAQ;AAM5D,IAAM,mBAA4C,oBAAI,QAAQ;AAC9D,IAAM,oBAAkD,oBAAI,QAAQ;AACpE,IAAM,kBAAwD,oBAAI,QAAQ;AAC1E,IAAM,mBAAuD,oBAAI,QAAQ;AACzE,IAAM,kBAA8C,oBAAI,QAAQ;AAChE,IAAM,kBAA8C,oBAAI,QAAQ;AAChE,IAAM,cAAkC,oBAAI,QAAQ;AACpD,IAAM,2BAAuE,oBAAI,QAAQ;AACzF,IAAM,4BAA4B,oBAAI,QAA2B;AAMjE,IAAM,eAAyC,oBAAI,QAAQ;AAE3D,IAAM,mBAA6C,oBAAI,QAAQ;AAC/D,IAAM,eAAyC,oBAAI,QAAQ;AAC3D,IAAM,iBAA2C,oBAAI,QAAQ;AAC7D,IAAM,cAAwC,oBAAI,QAAQ;AAC1D,IAAM,gBAA0C,oBAAI,QAAQ;AAM5D,IAAM,gBAA0C,oBAAI,QAAQ;;;ACtCnE;AAAA,EAEE;AAAA,EAGA;AAAA,EACA;AAAA,OACK;;;ACTP,YAAYC,YAAW;AAEhB,IAAM,+BAA+B,SAAe,eAAQ,MAAM,GAAG,EAAE,IAAI,EAAE,KAAK;AAElF,IAAM,SACX,OAAO,cAAc,eACrB,OAAO,WAAW,eAClB,mBAAmB,KAAK,UAAU,SAAS,KAC3C,CAAE,OAAe;AAEZ,IAAM,WAAW,OAAO,cAAc,eAAe,WAAW,KAAK,UAAU,SAAS;AAExF,IAAM,aACX,OAAO,cAAc,eAAe,mCAAmC,KAAK,UAAU,SAAS;AAE1F,IAAM,YACX,OAAO,cAAc,eAAe,2BAA2B,KAAK,UAAU,SAAS;AAGlF,IAAM,iBACX,OAAO,cAAc,eACrB,0CAA0C,KAAK,UAAU,SAAS;AAE7D,IAAM,YAAY,OAAO,cAAc,eAAe,UAAU,KAAK,UAAU,SAAS;AAIxF,IAAM,mBACX,OAAO,cAAc,eACrB,4CAA4C,KAAK,UAAU,SAAS;AAG/D,IAAM,oBACX,OAAO,cAAc,eACrB,oEAAoE,KAAK,UAAU,SAAS;AAGvF,IAAM,eACX,OAAO,cAAc,eAAe,cAAc,KAAK,UAAU,SAAS;AAGrE,IAAM,eACX,OAAO,cAAc,eAAe,cAAc,KAAK,UAAU,SAAS;AAGrE,IAAM,mBACX,OAAO,cAAc,eAAe,WAAW,KAAK,UAAU,SAAS;AAIlE,IAAM,cAAc,CAAC,EAC1B,OAAO,WAAW,eAClB,OAAO,OAAO,aAAa,eAC3B,OAAO,OAAO,SAAS,kBAAkB;AAKpC,IAAM,2BACX,CAAC,oBACD,CAAC,kBAED,OAAO,eAAe,eACtB,WAAW,cAEX,OAAO,WAAW,WAAW,UAAU,oBAAoB;AAKtD,IAAM,gBAAgB,eAAe,kBAAkB,SAAS;;;ADrDhE,IAAM,oBAAoB,CAAC,aAAiC;AACjE,MAAI,CAAC,MAAM,MAAM,IAAI;AAIrB,MAAI,aAAa,IAAI,KAAK,KAAK,WAAW,QAAQ;AAChD,QAAI,SAAS,WAAW,KAAK,WAAW;AACxC,QAAI,QAAQ,SAAS,SAAS,IAAI;AACjC,KAAC,MAAM,KAAK,IAAI,yBAAyB,MAAM,OAAO,SAAS,aAAa,SAAS;AAEtF,aAAS,QAAQ;AAIjB,WAAO,aAAa,IAAI,KAAK,KAAK,WAAW,QAAQ;AACnD,YAAM,IAAI,SAAS,KAAK,WAAW,SAAS,IAAI;AAChD,aAAO,iBAAiB,MAAM,GAAG,SAAS,aAAa,SAAS;AAAA,IAClE;AAGA,aAAS,UAAU,KAAK,eAAe,OAAO,KAAK,YAAY,SAAS;AAAA,EAC1E;AAGA,SAAO,CAAC,MAAM,MAAM;AACtB;AAMO,IAAM,gBAAgB,MAAM;AACjC,SAAO,CAAC,EAAE,OAAO,SAAS,iBAAiB,OAAO,SAAS,cAAc;AAC3E;AAOO,IAAM,2BAA2B,CACtC,QACA,OACA,cACsB;AACtB,QAAM,EAAE,WAAW,IAAI;AACvB,MAAI,QAAQ,WAAW;AACvB,MAAI,IAAI;AACR,MAAI,eAAe;AACnB,MAAI,gBAAgB;AAIpB,SAAO,aAAa,KAAK,KAAM,aAAa,KAAK,KAAK,MAAM,WAAW,WAAW,GAAI;AACpF,QAAI,gBAAgB,eAAe;AACjC;AAAA,IACF;AAEA,QAAI,KAAK,WAAW,QAAQ;AAC1B,qBAAe;AACf,UAAI,QAAQ;AACZ,kBAAY;AACZ;AAAA,IACF;AAEA,QAAI,IAAI,GAAG;AACT,sBAAgB;AAChB,UAAI,QAAQ;AACZ,kBAAY;AACZ;AAAA,IACF;AAEA,YAAQ,WAAW;AACnB,YAAQ;AACR,SAAK,cAAc,YAAY,IAAI;AAAA,EACrC;AAEA,SAAO,CAAC,OAAO,KAAK;AACtB;AAOO,IAAM,mBAAmB,CAC9B,QACA,OACA,cACY;AACZ,QAAM,CAAC,KAAK,IAAI,yBAAyB,QAAQ,OAAO,SAAS;AACjE,SAAO;AACT;AAEO,IAAM,uBAAuB,CAAC,UAAwB;AAC3D,MAAI,iBAAiB,KAAK,GAAG;AAC3B,WAAO,CAAC,SAAS,UAAU,EAAE,QAAQ,MAAM,QAAQ,IAAI,MAAM,MAAM;AAAA,EACrE;AACA,SAAO;AACT;AAEO,IAAM,oBAAoB,MAAM;AACrC,MAAI,CAAC;AAAa,WAAO;AACzB,QAAM,gBAAgB,SAAS;AAC/B,MAAI,qBAAqB,aAAa;AAAG,WAAO;AAChD,SAAO;AACT;AAEO,IAAM,uBAAuB,CAAC,UAAwB;AAC3D,MAAI,iBAAiB,KAAK,GAAG;AAC3B,QAAI,OAA2B;AAC/B,WAAO,MAAM;AACX,YAAM,iBAAiB,KAAK,kBAAkB;AAC9C,UAAI,eAAe,KAAK,UAAQ,UAAU,aAAa,IAAI;AAAG,eAAO;AACrE,YAAM,SAAS,iBAAiB,IAAI;AACpC,UAAI,CAAC,CAAC,YAAY,OAAO,EAAE,QAAQ,OAAO,QAAQ,GAAG;AACnD,eAAO;AAAA,MACT;AACA,aAAO,KAAK;AAAA,IACd;AAAA,EACF;AACA,SAAO;AACT;;;AE/HO,IAAM,eAAe,CAAC,MAAe,MAAY,UAAsB;AAC5E,SACE,KAAK,SAAS,MAAM,KAAK,UACxB,KAAK,QAAQ,MAAM,KAAK,UACvB,KAAK,wBAAwB,MAAM,IAAI,MAAM,KAAK;AAExD;AAEO,IAAM,eAAe,CAAC,MAAe,MAAY,UAAsB;AAC5E,SACE,KAAK,MAAM,MAAM,KAAK,OACrB,KAAK,QAAQ,MAAM,KAAK,OACvB,KAAK,wBAAwB,MAAM,IAAI,MAAM,KAAK;AAExD;AAEO,IAAM,eAAe,CAAC,MAAe,MAAY,UAAsB;AAC5E,SACE,KAAK,QAAQ,MAAM,KAAK,SACvB,KAAK,UAAU,MAAM,KAAK,SACzB,KAAK,wBAAwB,MAAM,IAAI,MAAM,KAAK;AAExD;AAEO,IAAM,eAAe,CAAC,MAAe,MAAY,UAAsB;AAC5E,SACE,KAAK,OAAO,MAAM,KAAK,QACtB,KAAK,SAAS,MAAM,KAAK,QACxB,KAAK,wBAAwB,MAAM,IAAI,MAAM,KAAK;AAExD;AASO,IAAM,WAAW,CAAC,MAAe,OAAgB,QAAQ,QAAQ;AACtE,MAAI,KAAK,WAAW,MAAM;AAAQ,WAAO;AAEzC,MAAI,KAAK,MAAM,MAAM,UAAU,MAAM,MAAM,KAAK;AAAQ,WAAO;AAC/D,QAAM,YAAY,KAAK,IAAI,MAAM,QAAQ,KAAK,MAAM;AACpD,QAAM,cAAc,KAAK,IAAI,KAAK,QAAQ,MAAM,MAAM,IAAI,KAAK,IAAI,KAAK,KAAK,MAAM,GAAG;AAEtF,SAAO,MAAM,aAAa,cAAc,YAAY;AACtD;AAQO,IAAM,aAAa,CAAC,GAAW,SAAkB;AACtD,SAAO,KAAK,KAAK,QAAQ,KAAK,KAAK;AACrC;AAQO,IAAM,aAAa,CAAC,GAAW,SAAkB;AACtD,SAAO,KAAK,KAAK,OAAO,KAAK,KAAK;AACpC;AAQO,IAAM,gBAAgB,CAAC,GAAW,SAAkB;AACzD,SAAO,KAAK,IAAI,KAAK,IAAI,IAAI,KAAK,IAAI,GAAG,KAAK,IAAI,IAAI,KAAK,KAAK,CAAC;AACnE;AAEO,IAAM,YAAY,CACvB,GACA,MACA,MACA,YACA,YAAY,SACT;AACH,MAAI,SAAS,MAAM,WAAW,IAAI,GAAG;AACnC,UAAM,aAAa,WAAW,GAAG,WAAW,IAAI;AAChD,UAAM,YAAY,WAAW,GAAG,IAAI;AACpC,UAAM,SAAS,cAAc,GAAG,WAAW,IAAI;AAC/C,UAAM,MAAM,cAAc,GAAG,IAAI;AACjC,QAAI,CAAC,eAAe,aAAa,MAAM,SAAS;AAC9C,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT,WAAW,WAAW;AACpB,WAAO,aAAa,MAAM,MAAM,UAAU;AAAA,EAC5C,OAAO;AACL,WAAO,aAAa,MAAM,MAAM,UAAU;AAAA,EAC5C;AACF;AAgBA,IAAM,kBAAkB,CAAC,OAAkB,GAAW,MAA4C;AAChG,QAAM,aAA0B;AAAA,IAC9B,KAAK;AAAA,IACL,OAAO;AAAA,IACP,MAAM;AAAA,IACN,OAAO;AAAA,EACT;AACA,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,UAAM,QAAQ,MAAM;AACpB,UAAM,QAAQ,MAAM,eAAe;AACnC,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,YAAM,OAAO,MAAM;AAEnB,UAAI,KAAK,KAAK,QAAQ,KAAK,KAAK,SAAS,KAAK,KAAK,OAAO,KAAK,KAAK,QAAQ;AAC1E,eAAO;AAAA,MACT,WAES,IAAI,KAAK,KAAK;AACrB,YAAI,CAAC,WAAW,SAAS,UAAU,GAAG,MAAM,OAAO,WAAW,OAAO,KAAK,GAAG;AAC3E,qBAAW,QAAQ;AAAA,YACjB;AAAA,YACA,MAAM;AAAA,UACR;AAAA,QACF;AAAA,MACF,WAES,IAAI,KAAK,QAAQ;AACxB,YAAI,CAAC,WAAW,OAAO,UAAU,GAAG,MAAM,OAAO,WAAW,GAAG,GAAG;AAChE,qBAAW,MAAM;AAAA,YACf;AAAA,YACA,MAAM;AAAA,UACR;AAAA,QACF;AACA,YAAI,WAAW,QAAQ,aAAa,MAAM,OAAO,WAAW,IAAI,GAAG;AACjE,qBAAW,OAAO;AAAA,YAChB;AAAA,YACA,MAAM;AAAA,UACR;AAAA,QACF;AAAA,MACF,WACE,WAAW,GAAG,IAAI,KAClB,IAAI,KAAK,SACR,CAAC,WAAW,QAAQ,aAAa,MAAM,OAAO,WAAW,IAAI,IAC9D;AACA,mBAAW,OAAO;AAAA,UAChB;AAAA,UACA,MAAM;AAAA,QACR;AAAA,MACF,WACE,WAAW,GAAG,IAAI,KAClB,IAAI,KAAK,UACR,CAAC,WAAW,SAAS,aAAa,MAAM,OAAO,WAAW,KAAK,IAChE;AACA,mBAAW,QAAQ;AAAA,UACjB;AAAA,UACA,MAAM;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAEA,IAAO,iBAAQ;;;AC/Lf,SAAS,WAAW,qBAAqB;AASlC,IAAM,6BAA6B,CAAC,MAAc,QAAgB,WAAW,UAAU;AAC5F,MAAI,SAAS,KAAK,SAAS,KAAK,QAAQ;AACtC,WAAO;AAAA,EACT;AACA,MAAI;AACJ,MAAI,UAAU;AACZ,YAAQ,cAAc,MAAM,MAAM;AAClC,WAAO,KAAK,UAAU,OAAO,MAAM;AAAA,EACrC,OAAO;AACL,YAAQ,UAAU,MAAM,MAAM;AAC9B,WAAO,KAAK,UAAU,QAAQ,KAAK;AAAA,EACrC;AACF;AAkBO,IAAM,uBAAuB,CAAC,MAAc,WAAmB;AACpE,SAAO,2BAA2B,MAAM,MAAM,EAAE,UAAU;AAC5D;AASO,IAAM,eAAe,CAAC,MAAc,WAAmB;AAC5D,MAAI,IAAI;AACR,SAAO,KAAK,UAAU;AACpB,UAAM,MAAM,IAAI,qBAAqB,MAAM,CAAC;AAC5C,QAAI,MAAM;AAAQ,aAAO,CAAC,GAAG,GAAG;AAChC,QAAI;AAAA,EACN;AACA,SAAO,CAAC,GAAG,IAAI,KAAK,IAAI,KAAK,QAAQ,CAAC,CAAC;AACzC;AAEA,IAAM,UAAU,CAAC,SAAiB,KAAK,KAAK,IAAI;AAEhD,IAAM,cAAc,CAAC,SACnB,mFAAmF,KAAK,IAAI;AAG9F,IAAM,sBAAsB,CAAC,SAC3B,kwCAAkwC;AAAA,EAChwC;AACF;AAEF,IAAM,uBAAuB,CAAC,MAAc,UAAkB;AAC5D,SACE,CAAC,CAAC,QACF,CAAC,CAAC,SACF,CAAC,QAAQ,IAAI,KACb,CAAC,oBAAoB,IAAI,KACzB,CAAC,QAAQ,KAAK,KACd,CAAC,oBAAoB,KAAK,KAC1B,YAAY,IAAI,MAAM,YAAY,KAAK;AAE3C;AAsBO,IAAM,kBAAkB,CAAC,MAAc,aAAgD;AAE5F,QAAM,YAAY,OAAO,KAAK;AAC9B,MAAI,aAAa,YAAY,IAAI,GAAG;AAClC,UAAM,WAAsB,MAAM;AAAA,MAChC,IAAI,UAAU,QAAW,EAAE,aAAa,OAAO,CAAC,EAAE,QAAQ,IAAI;AAAA,IAChE;AACA,QAAI,SAAS,SAAS,GAAG;AACvB,YAAM,EAAE,SAAS,MAAM,IAAI,WAAW,SAAS,QAAQ,IAAI,SAAS,SAAS,SAAS;AACtF,aAAO,EAAE,MAAM,SAAS,QAAQ,MAAM;AAAA,IACxC;AAAA,EACF;AACA,SAAO,EAAE,MAAM,QAAQ,EAAE;AAC3B;AAEO,IAAM,kBAAkB,CAAC,MAAc,WAAmB;AAC/D,MAAI,cAAc,2BAA2B,MAAM,QAAQ,IAAI;AAC/D,MAAI,iBAAiB,SAAS;AAC9B,SAAO,kBAAkB,KAAK;AAC5B,UAAM,eAAe,2BAA2B,MAAM,gBAAgB,IAAI;AAC1E,QAAI,qBAAqB,aAAa,YAAY,GAAG;AACnD,wBAAkB,aAAa;AAAA,IACjC;AAAO;AAAA,EACT;AACA,MAAI,SAAS,iBAAiB,GAAG;AAC/B,UAAM,WAAW,KAAK,UAAU,gBAAgB,MAAM;AACtD,UAAM,EAAE,QAAQ,WAAW,IAAI,gBAAgB,QAAQ;AACvD,sBAAkB;AAAA,EACpB;AACA,SAAO,KAAK,UAAU,iBAAiB,IAAI,IAAI,gBAAgB,MAAM;AACvE;AAEO,IAAM,wBAAwB,CAAC,MAAc,WAAmB;AACrE,SAAO,SAAS,gBAAgB,MAAM,MAAM,EAAE;AAChD;AAEO,IAAM,iBAAiB,CAAC,MAAc,WAAmB;AAC9D,MAAI,cAAc,2BAA2B,MAAM,MAAM;AACzD,MAAI,gBAAgB,SAAS;AAC7B,SAAO,gBAAgB,KAAK,UAAU;AACpC,UAAM,cAAc,2BAA2B,MAAM,aAAa;AAClE,QAAI,qBAAqB,aAAa,WAAW,GAAG;AAClD,uBAAiB,YAAY;AAAA,IAC/B;AAAO;AAAA,EACT;AACA,MAAI,gBAAgB,SAAS,GAAG;AAC9B,UAAM,UAAU,KAAK,UAAU,QAAQ,aAAa;AACpD,UAAM,EAAE,MAAM,UAAU,QAAQ,WAAW,IAAI,gBAAgB,SAAS,cAAY,SAAS,EAAE;AAC/F,oBAAgB,SAAS,aAAa,SAAS;AAAA,EACjD;AACA,SAAO,KAAK,UAAU,QAAQ,gBAAgB,KAAK,SAAS,KAAK,SAAS,aAAa;AACzF;AAEO,IAAM,uBAAuB,CAAC,MAAc,WAAmB;AACpE,SAAO,SAAS,eAAe,MAAM,MAAM,EAAE;AAC/C;AAEO,IAAM,eAAe,CAAC,MAAc,WAAmB;AAC5D,MAAI,CAAC;AAAM,WAAO,CAAC,GAAG,CAAC;AACvB,WAAS,KAAK,IAAI,QAAQ,KAAK,MAAM;AAErC,MAAI,eAAe,2BAA2B,MAAM,QAAQ,IAAI;AAChE,MAAI,WAAW,2BAA2B,MAAM,MAAM;AAEtD,MAAI,iBAAiB,SAAS;AAC9B,MAAI,gBAAgB,SAAS;AAC7B,MAAI,CAAC,UAAU;AACb,WAAO,CAAC,QAAQ,MAAM;AAAA,EACxB;AACA,MAAI,gBAAgB,qBAAqB,cAAc,QAAQ,GAAG;AAChE,WAAO,kBAAkB,KAAK;AAC5B,YAAM,eAAe,2BAA2B,MAAM,gBAAgB,IAAI;AAC1E,UAAI,qBAAqB,cAAc,YAAY,GAAG;AACpD,0BAAkB,aAAa;AAAA,MACjC;AAAO;AAAA,IACT;AAAA,EACF,OAAO;AACL,qBAAiB;AAAA,EACnB;AAEA,SAAO,gBAAgB,KAAK,UAAU;AACpC,UAAM,cAAc,2BAA2B,MAAM,aAAa;AAClE,QAAI,qBAAqB,UAAU,WAAW,GAAG;AAC/C,uBAAiB,YAAY;AAAA,IAC/B;AAAO;AAAA,EACT;AAEA,MAAI,gBAAgB,iBAAiB,GAAG;AACtC,UAAM,UAAU,KAAK,UAAU,gBAAgB,aAAa;AAC5D,UAAM,EAAE,MAAM,UAAU,QAAQ,WAAW,IAAI,gBAAgB,SAAS,cAAY;AAClF,eAAS,IAAI,SAAS,SAAS,GAAG,KAAK,GAAG,KAAK;AAC7C,cAAM,UAAU,SAAS;AACzB,cAAM,YAAY,QAAQ,QAAQ;AAClC,YAAI,UAAU,aAAa,SAAS,YAAY,QAAQ,QAAQ,QAAQ;AACtE,iBAAO;AAAA,QACT;AAAA,MACF;AACA,aAAO,SAAS;AAAA,IAClB,CAAC;AACD,sBAAkB;AAClB,oBAAgB,SAAS,SAAS;AAAA,EACpC;AACA,SAAO,CAAC,gBAAgB,aAAa;AACvC;AAaO,IAAM,gBAAgB,CAC3B,MACA,GACA,GACA,OACA,KACA,WACW;AACX,QAAM,QAAQ,SAAS,YAAY;AACnC,MAAI,MAAM,QAAQ,GAAG;AACnB,UAAM,MAAM,KAAK,OAAO,QAAQ,OAAO,CAAC;AACxC,QAAI;AACF,YAAM,SAAS,MAAM,GAAG;AACxB,YAAM,OAAO,MAAM,KAAK,IAAI,KAAK,IAAI,KAAK,MAAM,GAAG,CAAC,CAAC;AAAA,IACvD,SAAS,GAAP;AACA,aAAO;AAAA,IACT;AACA,UAAMC,SAAQ,MAAM,eAAe;AACnC,QAAIA,OAAM,WAAW,GAAG;AACtB,aAAO;AAAA,IACT;AACA,eAAW,QAAQA,QAAO;AACxB,UAAI,IAAI,KAAK,KAAK;AAChB,eAAO,cAAc,MAAM,GAAG,GAAG,OAAO,KAAK,MAAM;AAAA,MACrD,WAAW,IAAI,KAAK,QAAQ;AAC1B,eAAO,cAAc,MAAM,GAAG,GAAG,KAAK,KAAK,MAAM;AAAA,MACnD,WAAW,KAAK,KAAK,OAAO,KAAK,OAAO;AACtC,eAAO,cAAc,MAAM,GAAG,GAAG,OAAO,KAAK,MAAM;AAAA,MACrD;AAAA,IACF;AACA,WAAO,cAAc,MAAM,GAAG,GAAG,KAAK,KAAK,MAAM;AAAA,EACnD;AACA,QAAM,CAAC,QAAQ,IAAI,IAAI,aAAa,KAAK,eAAe,IAAI,KAAK;AACjE,MAAI;AACF,UAAM,SAAS,MAAM,MAAM;AAC3B,UAAM,OAAO,MAAM,KAAK,IAAI,KAAK,IAAI,MAAM,MAAM,GAAG,CAAC,CAAC;AAAA,EACxD,SAAS,KAAP;AACA,WAAO;AAAA,EACT;AACA,QAAM,QAAQ,MAAM,eAAe;AACnC,MAAI,MAAM,WAAW;AAAG,WAAO;AAE/B,aAAW,QAAQ,OAAO;AACxB,QAAI,KAAK,UAAU;AAAG;AACtB,QAAI,IAAI,KAAK,KAAK;AAChB,aAAO;AAAA,IACT,WAAW,IAAI,KAAK,QAAQ;AAC1B,aAAO;AAAA,IACT,WAAW,KAAK,KAAK,OAAO,KAAK,QAAQ,GAAG;AAC1C,aAAO;AAAA,IACT;AAAA,EACF;AACA,SAAO;AACT;;;AChRA;AAAA,EACE;AAAA,EAEA;AAAA,EACA;AAAA,EAEA;AAAA,EAGA,gBAAAC;AAAA,OACK;AAqBP,IAAM,sBAAsB,CAAC,UAAmC;AAC9D,QAAM,QAAuC,oBAAI,IAAI;AACrD,MAAI,MAAM,WAAW;AAAG,WAAO;AAE/B,QAAM,WAA4B,CAAC;AAMnC,QAAM,cAAc,CAAC,SAAkB;AACrC,eAAW,WAAW,UAAU;AAC9B,YAAM,EAAE,MAAM,IAAI;AAClB,YAAM,gBAAgB,MAAM,IAAI,OAAO;AACvC,YAAM,WAAW,gBACb,cACG,OAAO,EACP,QAAQ,EACR,KAAK,OAAK,EAAE,QAAQ,CAAC,KAAK,cAAc,cAAc,SAAS,KAClE;AACJ,UAAI,aAAa,MAAM,OAAO,KAAK,KAAK,SAAS,WAAW,SAAS,QAAQ,SAAS,GAAG;AACvF,eAAO;AAAA,MACT;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAGA,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,UAAM,OAAO,MAAM;AACnB,UAAM,MAAM,YAAY,IAAI;AAC5B,QAAI,KAAK;AACP,YAAM,IAAI,GAAG,GAAG,KAAK,IAAI;AAAA,IAC3B,OAAO;AACL,YAAM,WAAW;AAAA,QACf,KAAK,KAAK;AAAA,QACV,QAAQ,KAAK;AAAA,QACb,QAAQ,KAAK;AAAA,QACb,MAAM,KAAK;AAAA,QACX,OAAO,KAAK;AAAA,MACd;AACA,YAAM,IAAI,UAAU,CAAC,IAAI,CAAC;AAC1B,eAAS,KAAK,QAAQ;AAAA,IACxB;AAAA,EACF;AAGA,aAAW,CAAC,MAAMC,MAAK,KAAK,OAAO;AAEjC,QAAIA,OAAM,WAAW;AAAG;AAExB,QAAI,SAAS,KAAK,KAChB,YAAY,KAAK,QACjB,WAAW,KAAK;AAGlB,eAAW,QAAQA,QAAO;AACxB,YAAM,EAAE,KAAK,QAAQ,MAAM,IAAI;AAC/B,UAAI,MAAM;AAAQ,iBAAS;AAC3B,UAAI,SAAS;AAAW,oBAAY;AACpC,UAAI,QAAQ,YAAY,KAAK,QAAQ;AAAG,mBAAW;AAAA,IACrD;AACA,SAAK,MAAM;AACX,SAAK,SAAS;AACd,SAAK,QAAQ;AAAA,EACf;AACA,SAAO;AACT;AAOA,IAAM,yBAAyB,CAAC,OAAmB;AACjD,QAAM,EAAE,YAAY,SAAS,IAAI,OAAO,iBAAiB,EAAE;AAI3D,MAAI,SAAS;AAEb,MAAI,WAAW,SAAS,IAAI,GAAG;AAC7B,aAAS,WAAW,UAAU;AAC9B,WAAO;AAAA,EACT,WAES,WAAW,SAAS,GAAG,GAAG;AACjC,aAAS,SAAS,YAAY,EAAE,IAAI;AAAA,EACtC,WAES,gBAAgB,KAAK,UAAU,GAAG;AACzC,aAAS,WAAW,UAAU;AAAA,EAChC,OAAO;AACL,WAAO,GAAG,sBAAsB,EAAE;AAAA,EACpC;AAEA,MAAI,OAAO;AACX,MAAI,SAAS,SAAS,IAAI,GAAG;AAC3B,WAAO,SAAS,UAAU,EAAE;AAAA,EAC9B;AAEA,SAAO,SAAS;AAClB;AAQA,IAAM,mBAAmB,CAAC,MAAe,WAAmB;AAC1D,QAAM,YAAY,KAAK;AACvB,MAAI,aAAa;AAAQ,WAAO;AAChC,QAAM,MAAM,KAAK,OAAO,YAAY,UAAU;AAC9C,SAAO,IAAI,QAAQ,KAAK,MAAM,KAAK,KAAK,OAAO,MAAM;AACvD;AAQA,IAAM,eAAe,CAAC,MAAe,SAAsD;AACzF,QAAM,YAAY,KAAK,SAAS;AAChC,SAEG,KAAK,OAAO,KAAK,QACf,KAAK,UAAU,KAAK,UAEnB,KAAK,MAAM,YAAY,KAAK,UAE3B,KAAK,OAAO,KAAK,MAAM,KAAK,SAAS,KAAK,KAAK,SAAS,KAAK,QAEjE,KAAK,OAAO,KAAK,QACf,KAAK,UAAU,KAAK,UAEnB,KAAK,SAAS,YAAY,KAAK,QAElC,KAAK,UAAU,KAAK,UACnB,KAAK,UAAU,KAAK,SAAS,KAAK,SAAS,KAC3C,KAAK,MAAM,KAAK;AAEtB;AASA,IAAM,eAAe,CAAC,QAAgB,SAAqB,KAAa,WAAmB;AACzF,QAAM,WAAW;AAAA,IACf;AAAA,IACA,QAAQ,SAAS;AAAA,IACjB;AAAA,EACF;AAOA,QAAM,gBAAgB,CAAC,SAAkB;AACvC,QAAI,aAAa,MAAM,QAAQ,GAAG;AAChC,YAAM,SAAS,SAAS,MAAM,KAAK,MAAM,SAAS,MAAM,KAAK;AAC7D,YAAM,YAAY,SAAS,SAAS,KAAK,SAAS,SAAS,SAAS,KAAK;AACzE,eAAS,SAAS,YAAY;AAC9B,eAAS,MAAM;AACf,eAAS,SAAS;AAAA,IACpB;AAAA,EACF;AAMA,QAAMC,SAAQ,CAACC,aAAwB;AACrC,eAAW,SAASA,SAAQ,YAAY;AACtC,UAAIC,cAAa,KAAK,GAAG;AACvB,cAAM,UAAU,MAAM,aAAa,kBAAkB;AACrD,cAAM,OAAO,UAAU,SAAS,aAAa,QAAQ,KAAK,IAAI;AAC9D,YAAI,MAAM;AACR,cAAI,QAAQ,UAAU,IAAI,GAAG;AAC3B,gBAAI,OAAO,OAAO,IAAI,GAAG;AACvB,oBAAM,OAAO;AAAA,gBACX,MAAM,sBAAsB;AAAA,gBAC5B,uBAAuB,KAAK;AAAA,cAC9B;AACA,4BAAc,IAAI;AAAA,YACpB,WAAW,OAAO,SAAS,IAAI,GAAG;AAChC,oBAAM,SAAS,uBAAuB,KAAK;AAC3C,oBAAM,QAAQ,MAAM,eAAe;AACnC,uBAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,sBAAM,OAAO,iBAAiB,MAAM,IAAI,MAAM;AAC9C,8BAAc,IAAI;AAAA,cACpB;AAAA,YACF,OAAO;AACL,cAAAF,OAAM,KAAK;AAAA,YACb;AAAA,UACF,OAAO;AACL,kBAAM,QAAQ,MAAM;AAAA,cAClB,IAAI,2BAA2B,gCAAgC;AAAA,YACjE;AACA,kBAAM,QAAQ,CAAAG,UAAQ;AACpB,oBAAM,SAAS,uBAAuBA,KAAI;AAC1C,oBAAM,QAAQA,MAAK,eAAe;AAClC,uBAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,sBAAM,OAAO,iBAAiB,MAAM,IAAI,MAAM;AAC9C,8BAAc,IAAI;AAAA,cACpB;AAAA,YACF,CAAC;AAAA,UACH;AAAA,QACF,OAAO;AACL,UAAAH,OAAM,KAAK;AAAA,QACb;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,EAAAA,OAAM,OAAO;AACb,SAAO;AACT;AAQO,IAAM,qBAAqB,CAAC,QAAgB,MAAY,WAAW,MAAM;AAC9E,QAAM,OAAO,SAAS,SAAS,QAAQ,IAAI;AAC3C,QAAM,QACJ,OAAO,QAAQ,QAAQ,IAAI,KAAK,KAAK,WAAW,IAC5C,CAAC,MAAM,IAAI,IACX,OAAO,MAAe,QAAQ;AAAA,IAC5B,IAAI;AAAA,IACJ,OAAO,OAAK,OAAO,QAAQ,QAAQ,CAAC;AAAA,IACpC,MAAM;AAAA,EACR,CAAC;AACP,MAAI,CAAC;AAAO,WAAO,CAAC;AACpB,QAAM,QAAQ,SAAS,UAAU,QAAQ,MAAM,EAAE;AACjD,QAAM,UAAU,MAAM,sBAAsB;AAC5C,QAAM,QAAQ,SAAS,YAAY;AACnC,QAAM,mBAAmB,SAAS,UAAU,QAAQ,IAAI,CAAC;AACzD,QAAM,QAAQ,oBAAoB,MAAM,eAAe,CAAC;AACxD,QAAM,YAAuB,CAAC;AAC9B,aAAW,CAAC,MAAM,KAAK,KAAK,OAAO;AACjC,QAAI,QAAQ,KAAK,QAAQ,KAAK;AAC9B,UAAM,WAAW,aAAa,QAAQ,OAAO,KAAK,KAAK,KAAK,MAAM;AAClE,SAAK,MAAM,SAAS;AACpB,SAAK,SAAS,SAAS;AACvB,SAAK,SAAS,SAAS;AAEvB,QAAI,QAAQ,KAAK,QAAQ,SAAS,MAAM,GAAG,MAAM;AAC/C,cAAQ;AAAA,IACV;AACA,cAAU,KAAK,IAAI,QAAQ,MAAM,GAAG,MAAM,KAAK,KAAK,OAAO,KAAK,MAAM,CAAC;AAAA,EACzE;AACA,SAAO;AACT;AASO,IAAM,sBAAsB,CAAC,QAAgB,OAAc,WAAW,MAAM;AACjF,QAAM,SAAS,MAAM,MAAM,KAAK;AAChC,QAAM,QAAQ,MAAM,IAAI,KAAK;AAE7B,QAAM,cAAc,OAAO,MAAe,QAAQ;AAAA,IAChD,IAAI;AAAA,IACJ,OAAO,OAAK,OAAO,QAAQ,QAAQ,CAAC;AAAA,IACpC,MAAM;AAAA,EACR,CAAC;AAED,QAAM,aAAa,OAAO,MAAe,QAAQ;AAAA,IAC/C,IAAI;AAAA,IACJ,OAAO,OAAK,OAAO,QAAQ,QAAQ,CAAC;AAAA,IACpC,MAAM;AAAA,EACR,CAAC;AACD,MAAI,CAAC,eAAe,CAAC;AAAY,WAAO,CAAC;AAEzC,QAAM,aAAwB,CAAC;AAC/B,QAAM,UAMF,oBAAI,IAAI;AAEZ,MAAI,CAAC,YAAY,SAAS,IAAI;AAC9B,MAAI,CAAC,GAAG,OAAO,IAAI;AACnB,QAAM,SAAqB,CAAC;AAC5B,MAAI,UAAU;AACd,MAAI,OAAuC;AAC3C,SAAO,MAAM;AACX,UAAM,CAAC,WAAW,QAAQ,IAAI;AAC9B,UAAM,UAAU,SAAS,UAAU,QAAQ,SAAS;AACpD,UAAM,OAAO,QAAQ,sBAAsB;AAC3C,YAAQ,IAAI,MAAM;AAAA,MAChB,KAAK;AAAA,MACL,SAAS;AAAA,IACX,CAAC;AACD,eAAW,KAAK,IAAI;AAEpB,QAAI,KAAK,OAAO,UAAU,OAAO;AAAG;AACpC,QAAI,CAAC,SAAS;AACZ,YAAMI,SAAQ,SAAS,YAAY;AACnC,MAAAA,OAAM,mBAAmB,OAAO;AAChC,aAAO,KAAKA,MAAK;AAAA,IACnB,OAAO;AACL,gBAAU;AAAA,IACZ;AACA,WAAO,OAAO,KAAc,QAAQ;AAAA,MAClC,IAAI;AAAA,MACJ,OAAO,OAAK,OAAO,QAAQ,QAAQ,CAAC;AAAA,IACtC,CAAC;AAAA,EACH;AACA,MAAI,KAAK,OAAO,WAAW,OAAO,GAAG;AACnC,WAAO,QAAQ,SAAS,WAAW,QAAQ,KAAK,CAAC;AAAA,EACnD,OAAO;AACL,WAAO;AAAA,MACL,SAAS,WAAW,QAAQ;AAAA,QAC1B;AAAA,QACA,OAAO,OAAO,IAAI,QAAQ;AAAA,UACxB,MAAM;AAAA,UACN,QAAQ,WAAW,SAAS;AAAA,QAC9B,CAAC;AAAA,MACH,CAAC;AAAA,IACH;AACA,WAAO;AAAA,MACL,SAAS,WAAW,QAAQ;AAAA,QAC1B,QAAQ,OAAO,MAAM,QAAQ;AAAA,UAC3B,MAAM;AAAA,UACN,QAAQ;AAAA,QACV,CAAC;AAAA,QACD;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AAGA,QAAM,QAAmB,CAAC;AAC1B,aAAWA,UAAS,QAAQ;AAC1B,UAAM,KAAK,GAAGA,OAAM,eAAe,CAAC;AAAA,EACtC;AACA,QAAM,QAAQ,oBAAoB,KAAK;AACvC,QAAM,YAAuB,CAAC;AAC9B,MAAI,eAA+B;AACnC,aAAW,CAAC,MAAML,MAAK,KAAK,OAAO;AAEjC,UAAM,YAAY,WAAW;AAAA,MAC3B,OACE,aAAa,GAAG,IAAI,MACnB,KAAK,QAAQ,EAAE,QAAQ,KAAK,IAAI,KAAK,OAAO,EAAE,IAAI,IAAI,OACtD,KAAK,SAAS,EAAE,SAAS,KAAK,IAAI,KAAK,QAAQ,EAAE,KAAK,IAAI;AAAA,IAC/D;AACA,UAAM,QAAQ,YAAY,QAAQ,IAAI,SAAS,IAAI;AAEnD,QAAI,QAAQ,KAAK,QAAQ,KAAK;AAC9B,QAAI,OAAO;AACT,YAAM,EAAE,KAAK,QAAQ,IAAI;AACzB,YAAMM,YAAW,aAAa,QAAQ,KAAK,KAAK,KAAK,KAAK,MAAM;AAChE,WAAK,MAAMA,UAAS;AACpB,WAAK,SAASA,UAAS;AAEvB,UACE,OACA,OAAO,QAAQ,QAAQ,OAAO,KAC9B,QAAQ,KACR,IAAI,sBAAsB,EAAE,SAAS,KAAK,MAC1C;AACA,gBAAQ;AAAA,MACV;AAAA,IACF;AAEA,QAAI,gBAAgB,aAAa,SAAS,KAAK,KAAK;AAClD,YAAM,UAAU,aAAa,SAAS,KAAK;AAC3C,WAAK,OAAO;AACZ,WAAK,UAAU;AAAA,IACjB;AACA,UAAM,WAAW,IAAI,QAAQN,OAAM,GAAG,MAAM,KAAK,KAAK,OAAO,KAAK,MAAM;AAExE,mBAAe;AACf,cAAU,KAAK,QAAQ;AAAA,EACzB;AACA,SAAO;AACT;;;ACvaA,OAAOO,WAAmC,YAAAC,iBAAgB;AAQ1D,IAAM,4BAA4B,oBAAI,QAAuD;AAE7F,IAAMC,YAAW,CAAC,WAAmB;AACnC,MAAI,QAAQ,0BAA0B,IAAI,MAAM;AAChD,MAAI,CAAC,OAAO;AACV,YAAQC,QAAqB,OAAO;AAAA,MAClC,WAAW;AAAA,IACb,EAAE;AACF,8BAA0B,IAAI,QAAQ,KAAK;AAC3C,UAAM,UAAU,CAAC,EAAE,UAAU,MAAM;AACjC,UAAI,CAAC,SAAS,SAAS,MAAM;AAAG;AAEhC,UAAI,WAAW;AACb,eAAO,QAAQ;AAAA,MACjB,OAAO;AACL,eAAO,OAAO;AAAA,MAChB;AAAA,IACF,CAAC;AAAA,EACH;AAEA,SAAO;AACT;AAEO,IAAM,aAAa,MAA+C;AACvE,QAAM,SAAS,kBAAkB;AACjC,QAAM,QAAQD,UAAS,MAAM;AAC7B,QAAM,YAAYE,UAAS,OAAO,WAAS,MAAM,SAAS;AAE1D,SAAO;AAAA,IACL;AAAA,IACA,CAACC,eAAuB;AACtB,YAAM,SAAS,EAAE,WAAAA,WAAU,CAAC;AAAA,IAC9B;AAAA,EACF;AACF;AAEO,IAAM,UAAU;AAAA,EACrB,IAAI,CAAC,WAAmB;AACtB,UAAM,QAAQH,UAAS,MAAM;AAC7B,WAAO,MAAM,SAAS,EAAE;AAAA,EAC1B;AACF;;;AClDO,IAAM,uBAAuB,CAClC,sBACA,iBACA,EAAE,2BAA2B,KAAK,IAAI,CAAC,MACpC;AACH,SAAO,SAAS,YAAY,OAAU;AACpC,2BAAuB,KAAK;AAE5B,QAAI,6BAA6B,SAAS,CAAE,MAA2B,kBAAkB;AACvF,aAAO,kBAAkB,KAAK;AAAA,IAChC;AAAA,EACF;AACF;AAEO,IAAM,eAAe,CAAC,UAAoC;AAC/D,SAAO,OAAO,OAAO,eAAe,eAAe,iBAAiB;AACtE;AAEO,IAAM,UAAU,CAAC,UAA+B;AACrD,SAAO,OAAO,OAAO,UAAU,eAAe,iBAAiB;AACjE;AAEO,IAAM,eAAe,CAAC,UAAoC;AAC/D,SAAO,iBAAiB;AAC1B;AAEO,IAAM,iBAAiB,CAAC,UAAe;AAC5C,QAAM,EAAE,YAAY,IAAI;AACxB,UAAQ,eAAe;AACvB,MAAI,aAAa,KAAK,GAAG;AACvB,WAAO,MAAM,QAAQ,MAAM,MAAM,eAAe;AAAA,EAClD;AACA,SAAO;AACT;;;AChCA,OAAOI,WAAmC,YAAAC,iBAAgB;AAO1D,IAAMC,6BAA4B,oBAAI,QAAwD;AAE9F,IAAMC,YAAW,CAAC,WAAmB;AACnC,MAAI,QAAQD,2BAA0B,IAAI,MAAM;AAChD,MAAI,CAAC,OAAO;AACV,YAAQE,QAAsB,OAAO;AAAA,MACnC,YAAY;AAAA,IACd,EAAE;AACF,IAAAF,2BAA0B,IAAI,QAAQ,KAAK;AAAA,EAC7C;AAEA,SAAO;AACT;AAEO,IAAM,cAAc,MAAgD;AACzE,QAAM,SAAS,kBAAkB;AACjC,QAAM,QAAQC,UAAS,MAAM;AAC7B,QAAM,aAAaE,UAAS,OAAO,WAAS,MAAM,UAAU;AAE5D,SAAO;AAAA,IACL;AAAA,IACA,CAACC,gBAAwB;AACvB,YAAM,SAAS,EAAE,YAAAA,YAAW,CAAC;AAAA,IAC/B;AAAA,EACF;AACF;AAEO,IAAM,WAAW;AAAA,EACtB,IAAI,CAAC,WAAmB;AACtB,UAAM,QAAQH,UAAS,MAAM;AAC7B,WAAO,MAAM,SAAS,EAAE;AAAA,EAC1B;AACF;;;ATeA,OAAO,oBAAoB;AAsHpB,IAAM,WAAW;AAAA,EACtB,SAAS,OAA+B;AACtC,WAAO,CAAC,CAAC,SAASI,QAAO,SAAS,KAAK,KAAK,uBAAuB;AAAA,EACrE;AAAA,EAIA,YAAY,QAAyB;AACnC,WAAO,CAAC,CAAC,aAAa,IAAI,MAAM;AAAA,EAClC;AAAA,EAQA,cACE,QACA,UAAoE,CAAC,GACtC;AAC/B,UAAM,EAAE,QAAQ,OAAO,WAAW,OAAAC,SAAQ,MAAM,KAAK,IAAI;AACzD,QAAI,CAAC,SAASC,OAAM,YAAY,KAAK;AAAG;AACxC,UAAM,QAAQA,OAAM,MAAM,KAAK;AAC/B,UAAM,QAAQF,QAAO,MAAM,QAAQ,EAAE,IAAI,OAAO,OAAO,OAAKA,QAAO,QAAQ,QAAQ,CAAC,EAAE,CAAC;AACvF,QAAI,CAAC;AAAO;AACZ,UAAM,aAAa,oBAAoB,QAAQ,KAAK;AACpD,QAAI,CAAC,OAAO,IAAI,IAAI;AACpB,WAAO,OAAO;AACZ,UAAIC,OAAM,KAAK,GAAG;AAChB,cAAM,UAAU,mBAAmB,QAAQ,KAAK;AAChD,mBAAW,aAAa,YAAY;AAClC,gBAAM,QAAQ,QAAQ;AAAA,YACpB,YACE,OAAO,SAAS,UAAU,QAC1B,OAAO,QAAQ,UAAU,OACzB,OAAO,UAAU,UAAU;AAAA,UAC/B;AACA,cAAI,CAAC,OAAO;AACV,mBAAO,CAAC,OAAO,KAAK;AAAA,UACtB;AAAA,QACF;AAAA,MACF;AACA,YAAM,OAAOD,QAAO,KAAK,QAAQ,EAAE,IAAI,MAAM,OAAO,CAAAG,OAAKH,QAAO,QAAQ,QAAQG,EAAC,EAAE,CAAC;AACpF,UAAI,CAAC;AAAM;AACX,YAAM,CAAC,GAAG,CAAC,IAAI;AACf,cAAQ;AACR,aAAO;AAAA,IACT;AACA;AAAA,EACF;AAAA,EAOA,iBAAiB,QAAgB,UAAmD,CAAC,GAAY;AAC/F,UAAM,EAAE,QAAQ,OAAO,WAAW,OAAO,OAAO,QAAQ,IAAI;AAC5D,QAAI,CAAC;AAAO,aAAO;AACnB,UAAM,QAAQH,QAAO,MAAM,QAAQ,EAAE,IAAI,OAAO,OAAO,OAAKA,QAAO,QAAQ,QAAQ,CAAC,EAAE,CAAC;AACvF,QAAI,CAAC;AAAO,aAAO;AACnB,UAAM,CAAC,KAAK,IAAI;AAChB,UAAM,aAAa,oBAAoB,QAAQ,EAAE,QAAQ,OAAO,OAAO,MAAM,CAAC;AAC9E,QAAI,WAAW,WAAW;AAAG,aAAO;AACpC,UAAM,YAAY,WAAW;AAC7B,UAAM,QAAQ,mBAAmB,QAAQ,KAAK;AAC9C,eAAW,QAAQ,OAAO;AACxB,UACE,CAAC,CAAC,SAAS,QAAQ,EAAE,QAAQ,IAAI,KACjC,KAAK,SAAS,UAAU,QACxB,KAAK,QAAQ,UAAU,KACvB;AACA,eAAO;AAAA,MACT,WACE,CAAC,CAAC,OAAO,OAAO,EAAE,QAAQ,IAAI,KAC9B,KAAK,UAAU,UAAU,SACzB,KAAK,QAAQ,UAAU,KACvB;AACA,eAAO;AAAA,MACT;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EAKA,UAAU,QAAwB;AAChC,UAAMI,UAAS,iBAAiB,IAAI,MAAM;AAC1C,QAAI,CAACA,SAAQ;AACX,YAAM,IAAI,MAAM,sDAAsD;AAAA,IACxE;AACA,WAAOA;AAAA,EACT;AAAA,EAMA,QAAQ,QAAgB,MAAiB;AACvC,QAAI,MAAM,YAAY,IAAI,IAAI;AAE9B,QAAI,CAAC,KAAK;AACR,YAAM,IAAI,IAAI;AACd,kBAAY,IAAI,MAAM,GAAG;AAAA,IAC3B;AAEA,WAAO;AAAA,EACT;AAAA,EAMA,SAAS,QAAgB,MAAkB;AACzC,UAAM,OAAa,CAAC;AACpB,QAAI,QAAQ;AAEZ,WAAO,MAAM;AACX,YAAM,SAAS,eAAe,IAAI,KAAK;AAEvC,UAAI,UAAU,MAAM;AAClB,YAAIJ,QAAO,SAAS,KAAK,GAAG;AAC1B,iBAAO;AAAA,QACT,OAAO;AACL;AAAA,QACF;AAAA,MACF;AAEA,YAAM,IAAI,cAAc,IAAI,KAAK;AAEjC,UAAI,KAAK,MAAM;AACb;AAAA,MACF;AAEA,WAAK,QAAQ,CAAC;AACd,cAAQ;AAAA,IACV;AAEA,UAAM,IAAI,MAAM,4CAA4C,SAAS,UAAU,IAAI,GAAG;AAAA,EACxF;AAAA,EAMA,yBAAyB,QAAuC;AAC9D,UAAM,KAAK,SAAS,UAAU,QAAQ,MAAM;AAC5C,UAAM,OAAO,GAAG,YAAY;AAE5B,SACG,gBAAgB,YAAY,gBAAgB,eAC5C,KAAa,gBAAgB,MAC9B;AACA,aAAO;AAAA,IACT;AAEA,WAAO,GAAG;AAAA,EACZ;AAAA,EAKA,UAAU,QAAyB;AACjC,WAAO,QAAQ,GAAG,MAAM;AAAA,EAC1B;AAAA,EAMA,WAAW,QAAyB;AAClC,WAAO,SAAS,GAAG,MAAM;AAAA,EAC3B;AAAA,EAMA,KAAK,QAAwB;AAC3B,WAAO,KAAK;AAAA,EACd;AAAA,EAKA,MAAM,QAAwB;AAC5B,WAAO,MAAM;AAAA,EACf;AAAA,EAEA,SAAS,QAAsB;AAC7B,UAAM,EAAE,UAAU,IAAI;AACtB,QAAI,WAAW;AACb,iBAAW,SAAS,MAAM;AAAA,IAC5B;AAAA,EACF;AAAA,EAKA,WAAW,QAAgB,QAA0B;AACnD,UAAM,WAAW,SAAS,UAAU,QAAQ,MAAM;AAClD,QAAI;AAMJ,QAAI;AACF,iBAAYK,cAAa,MAAM,IAAI,SAAS,OAAO;AAAA,IACrD,SAAS,KAAP;AACA,UAAI,CAAC,IAAI,QAAQ,SAAS,iDAAiD,GAAG;AAC5E,cAAM;AAAA,MACR;AAAA,IACF;AAEA,QAAI,CAAC,UAAU;AACb,aAAO;AAAA,IACT;AAEA,WAAO,SAAS,QAAQ,IAAI,8BAA8B,MAAM;AAAA,EAClE;AAAA,EAMA,UAAU,QAAgB,MAAyB;AACjD,UAAM,iBAAiB,yBAAyB,IAAI,MAAM;AAC1D,UAAM,aAAaL,QAAO,SAAS,IAAI,IACnC,kBAAkB,IAAI,MAAM,IAC5B,gBAAgB,IAAI,SAAS,QAAQ,QAAQ,IAAI,CAAC;AAEtD,QAAI,CAAC,YAAY;AACf,YAAM,IAAI,MAAM,+CAA+C,SAAS,UAAU,IAAI,GAAG;AAAA,IAC3F;AAEA,WAAO;AAAA,EACT;AAAA,EAKA,WAAW,QAAgB,OAAwB;AACjD,UAAM,CAAC,IAAI,IAAIA,QAAO,KAAK,QAAQ,MAAM,IAAI;AAC7C,UAAM,KAAK,SAAS,UAAU,QAAQ,IAAI;AAC1C,QAAI;AAIJ,QAAIA,QAAO,KAAK,QAAQ,EAAE,IAAI,MAAM,CAAC,GAAG;AACtC,cAAQ,EAAE,MAAM,MAAM,MAAM,QAAQ,EAAE;AAAA,IACxC;AAKA,UAAM,WAAW,IAAI,2BAA2B,gCAAgC;AAChF,UAAM,QAAQ,MAAM,KAAK,GAAG,iBAAiB,QAAQ,CAAC;AACtD,QAAI,QAAQ;AAEZ,eAAW,QAAQ,OAAO;AACxB,YAAM,aAAa,KAAK,WAAW;AAEnC,UAAI,cAAc,QAAQ,WAAW,eAAe,MAAM;AACxD;AAAA,MACF;AAEA,YAAM,EAAE,OAAO,IAAI,WAAW;AAC9B,YAAM,OAAO,KAAK,aAAa,oBAAoB;AACnD,YAAM,aAAa,QAAQ,OAAO,SAAS,SAAS,MAAM,EAAE;AAC5D,YAAM,MAAM,QAAQ;AAEpB,UAAI,MAAM,UAAU,KAAK;AACvB,cAAM,SAAS,KAAK,IAAI,QAAQ,KAAK,IAAI,GAAG,MAAM,SAAS,KAAK,CAAC;AACjE,mBAAW,CAAC,YAAY,MAAM;AAC9B;AAAA,MACF;AAEA,cAAQ;AAAA,IACV;AAEA,QAAI,CAAC,UAAU;AACb,YAAM,IAAI,MAAM,iDAAiD,SAAS,UAAU,KAAK,GAAG;AAAA,IAC9F;AAEA,WAAO;AAAA,EACT;AAAA,EAUA,WAAW,QAAgB,OAAwB;AACjD,UAAM,EAAE,QAAQ,MAAM,IAAI;AAC1B,UAAM,aAAaE,OAAM,WAAW,KAAK;AACzC,UAAM,YAAY,SAAS,WAAW,QAAQ,MAAM;AACpD,UAAM,WAAWA,OAAM,YAAY,KAAK,IAAI,YAAY,SAAS,WAAW,QAAQ,KAAK;AAEzF,UAAME,UAAS,SAAS,UAAU,MAAM;AACxC,UAAM,WAAWA,QAAO,SAAS,YAAY;AAC7C,UAAM,CAAC,WAAW,WAAW,IAAI,aAAa,WAAW;AACzD,UAAM,CAAC,SAAS,SAAS,IAAI,aAAa,YAAY;AAKtD,UAAM,UAAWC,cAAa,SAAS,IAAI,YAAY,UAAU;AACjE,UAAM,qBAAqB,CAAC,CAAC,QAAQ,aAAa,wBAAwB;AAC1E,UAAM,QAASA,cAAa,OAAO,IAAI,UAAU,QAAQ;AACzD,UAAM,mBAAmB,CAAC,CAAC,MAAM,aAAa,wBAAwB;AAEtE,aAAS,SAAS,WAAW,qBAAqB,IAAI,WAAW;AACjE,aAAS,OAAO,SAAS,mBAAmB,IAAI,SAAS;AACzD,WAAO;AAAA,EACT;AAAA,EAKA,aAAa,QAAgB,YAA2B;AACtD,QAAI,QAAQA,cAAa,UAAU,IAAI,aAAa,WAAW;AAE/D,QAAI,SAAS,CAAC,MAAM,aAAa,kBAAkB,GAAG;AACpD,cAAQ,MAAM,QAAQ,IAAI,qBAAqB;AAAA,IACjD;AAEA,UAAM,OAAO,QAAQ,gBAAgB,IAAI,KAAoB,IAAI;AAEjE,QAAI,CAAC,MAAM;AACT,YAAM,IAAI,MAAM,+CAA+C,OAAO;AAAA,IACxE;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,sBAAsB,QAAgB,MAAY;AAChD,UAAM,UAAU,SAAS,UAAU,QAAQ,IAAI;AAC/C,QAAIL,QAAO,OAAO,QAAQ,IAAI;AAAG,aAAO,CAAC,OAAO;AAChD,UAAM,QAAQ,QAAQ;AAAA,MACpB,IAAI,2BAA2B,gCAAgC;AAAA,IACjE;AACA,WAAO,MAAM,KAAK,KAAK;AAAA,EACzB;AAAA,EAEA,iBAAiB,QAAgB,SAAkB,GAAW,GAAyB;AACrF,UAAM,QAAQK,cAAa,OAAO,IAAI,UAAU,QAAQ;AACxD,QAAI,CAAC;AAAO,aAAO;AACnB,UAAM,WAAyB,CAAC;AAChC,QAAI,UAA6B,MAAM,aAAa,kBAAkB,IAClE,QACA,MAAM,QAAQ,IAAI,qBAAqB;AAE3C,UAAM,gBAAgB,CAACC,UAAe;AACpC,UAAI,CAAC,gBAAgB,IAAIA,KAAI;AAAG;AAChC,YAAM,WAAW,SAAS,sBAAsB,QAAQA,KAAI;AAC5D,iBAAW,SAAS,UAAU;AAC5B,YAAI,CAAC,SAAS,QAAQ,KAAK;AAAG;AAC9B,iBAAS,KAAK,KAAK;AAAA,MACrB;AAAA,IACF;AAEA,QAAI,CAAC,SAAS;AACZ,YAAMC,SAAQC,MAAK,MAAM,MAAM;AAC/B,iBAAW,CAACF,KAAI,KAAKC,QAAO;AAC1B,sBAAcD,KAAI;AAAA,MACpB;AAAA,IACF,OAAO;AACL,YAAMA,QAAO,SAAS,aAAa,QAAQ,OAAO;AAClD,UAAI,KAAK,OAAOA,KAAI,KAAKN,QAAO,OAAO,QAAQM,KAAI,GAAG;AACpD,sBAAcA,KAAI;AAAA,MACpB,OAAO;AACL,YAAI,CAACN,QAAO,YAAY,QAAQM,KAAI,GAAG;AACrC,gBAAM,OAAO,QAAQ,sBAAsB;AAC3C,gBAAM,UAAU,IAAI,KAAK,OAAO,KAAK,QAAQ;AAC7C,gBAAM,YAAY,UAAUN,QAAO,WAAWA,QAAO,MAAM,QAAQ;AAAA,YACjE,IAAI,SAAS,SAAS,QAAQM,KAAI;AAAA,UACpC,CAAC;AACD,cAAI,UAAU;AACZ,0BAAc,SAAS,EAAE;AAAA,UAC3B;AAAA,QACF,OAAO;AACL,gBAAM,SAASN,QAAO,OAAO,QAAQM,KAAI;AACzC,gBAAMC,SAAQP,QAAO,MAAM,QAAQ;AAAA,YACjC,IAAI,SAAS,SAAS,QAAQM,KAAI;AAAA,YAClC,OAAO,OAAM,UAAUN,QAAO,WAAW,QAAQ,CAAC,KAAM,KAAK,OAAO,CAAC;AAAA,YACrE,MAAM;AAAA,UACR,CAAC;AACD,qBAAW,CAAC,KAAK,KAAKO,QAAO;AAC3B,gBAAIP,QAAO,QAAQ,QAAQ,KAAK,GAAG;AACjC,uBAAS,KAAK,SAAS,UAAU,QAAQ,KAAK,CAAC;AAAA,YACjD;AAAO,4BAAc,KAAK;AAAA,UAC5B;AAAA,QACF;AAAA,MACF;AAAA,IACF;AACA,QAAI,MAAM,GACR,OAAO;AACT,UAAM,QAAQ,eAAgB,UAAU,GAAG,CAAC;AAC5C,QAAI,CAAC;AAAO,aAAO;AACnB,QAAI,aAAgC;AACpC,QAAI,UAAU,KAAK,GAAG;AACpB,mBAAa;AAAA,IACf,OAAO;AACL,YAAM,EAAE,KAAK,WAAW,MAAM,YAAY,OAAO,aAAa,OAAO,YAAY,IAAI;AAErF,UAAI,cAAc,aAAa;AAC7B,YAAI,SAAS,YAAY,MAAM,WAAW,IAAI,GAAG;AAC/C,uBAAa,YAAY;AACzB,gBAAM,YAAY,KAAK;AAAA,QACzB,OAAO;AACL,uBAAa,WAAW;AACxB,iBAAO,WAAW,KAAK;AAAA,QACzB;AAAA,MACF,WAAW,eAAe,aAAa;AACrC,YAAI,SAAS,YAAY,MAAM,YAAY,IAAI,GAAG;AAChD,uBAAa,YAAY;AACzB,gBAAM,YAAY,KAAK;AAAA,QACzB,OAAO;AACL,uBAAa,YAAY;AACzB,iBAAO,YAAY,KAAK;AAAA,QAC1B;AAAA,MACF,WAAW,YAAY;AACrB,qBAAa,WAAW;AACxB,YAAI,QAAQ,WAAW,KAAK;AAAM,iBAAO,WAAW,KAAK;AAAA,iBAChD,QAAQ,WAAW,KAAK;AAAO,iBAAO,WAAW,KAAK;AAAA,aAC1D;AACH,gBAAM,WAAW,KAAK;AAAA,QACxB;AAAA,MACF,WAAW,aAAa;AACtB,qBAAa,YAAY;AACzB,YAAI,QAAQ,YAAY,KAAK;AAAM,iBAAO,YAAY,KAAK;AAAA,iBAClD,QAAQ,YAAY,KAAK;AAAO,iBAAO,YAAY,KAAK;AAAA,aAC5D;AACH,gBAAM,YAAY,KAAK;AAAA,QACzB;AAAA,MACF,WAAW,aAAa;AACtB,YAAI,OAAO,YAAY,KAAK,MAAM;AAChC,iBAAO,YAAY,KAAK;AAAA,QAC1B,WAAW,OAAO,YAAY,KAAK,OAAO;AACxC,iBAAO,YAAY,KAAK;AAAA,QAC1B;AACA,cAAM,YAAY,KAAK;AACvB,qBAAa,YAAY;AAAA,MAC3B,WAAW,WAAW;AACpB,qBAAa,UAAU;AACvB,YAAI,OAAO,UAAU,KAAK,MAAM;AAC9B,iBAAO,UAAU,KAAK;AAAA,QACxB,WAAW,OAAO,UAAU,KAAK,OAAO;AACtC,iBAAO,UAAU,KAAK;AAAA,QACxB;AACA,cAAM,UAAU,KAAK;AAAA,MACvB;AAAA,IACF;AACA,QAAI,CAAC;AAAY,aAAO;AACxB,UAAM,OAAO,SAAS,aAAa,QAAQ,UAAU;AACrD,QAAI,KAAK,OAAO,IAAI,GAAG;AACrB,YAAM,OAAO,SAAS,SAAS,QAAQ,IAAI;AAC3C,UAAI,KAAK,KAAK,WAAW,GAAG;AAC1B,eAAO;AAAA,UACL;AAAA,UACA,QAAQ;AAAA,QACV;AAAA,MACF;AACA,YAAM,YAAY,SAAS,sBAAsB,QAAQ,IAAI;AAC7D,UAAI,cAAc;AAClB,eAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACzC,cAAMS,YAAW,UAAU;AAC3B,YAAIA,cAAa;AAAY;AAC7B,wBAAgBA,UAAS,eAAe,IAAI;AAAA,MAC9C;AACA,YAAM,WAAW,UAAU,UAAU,IAAI,aAAa,WAAW;AACjE,UAAI,CAAC,UAAU,QAAQ;AAAG,eAAO;AACjC,YAAM,UAAU,SAAS,eAAe;AACxC,YAAM,SAAS,cAAc,UAAU,MAAM,KAAK,GAAG,QAAQ,QAAQ,QAAQ,MAAM;AACnF,aAAO;AAAA,QACL;AAAA,QACA,QAAQ,cAAc;AAAA,MACxB;AAAA,IACF,WAAWC,SAAQ,UAAU,IAAI,GAAG;AAClC,YAAM,QAAQ,SAAS,cAAc,QAAQ,CAAC,YAAY,CAAC,GAAG;AAAA,QAC5D,YAAY;AAAA,QACZ,eAAe;AAAA,MACjB,CAAC;AACD,UAAI,CAAC;AAAO,eAAOV,QAAO,MAAM,QAAQ,SAAS,SAAS,QAAQ,IAAI,CAAC;AACvE,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT;AAAA,EAIA,eAAe,QAAgB,OAA0B;AACvD,YAAQ,eAAe,KAAK;AAC5B,UAAM,EAAE,SAAS,GAAG,SAAS,EAAE,IAAI;AAEnC,QAAI,KAAK,QAAQ,KAAK,MAAM;AAC1B,YAAM,IAAI,MAAM,mDAAmD,OAAO;AAAA,IAC5E;AACA,QAAI,SAAS,MAAM;AACnB,QAAI,QAAQ,KAAK,GAAG;AAClB,eAAS,SAAS,iBAAiB,MAAM,SAAS,MAAM,OAAO;AAAA,IACjE;AACA,WAAO,SAAS,iBAAiB,QAAQ,QAAQ,GAAG,CAAC;AAAA,EACvD;AAAA,EAEA,sBAAsB,QAAgB,IAA0B;AAC9D,UAAM,EAAE,UAAU,IAAI;AACtB,QAAI,CAAC,MAAM;AAAW,WAAK;AAC3B,QAAI,CAAC;AAAI,aAAO;AAChB,UAAM,aAAaE,OAAM,MAAM,EAAE;AACjC,UAAM,WAAWA,OAAM,IAAI,EAAE;AAC7B,UAAM,aAAa,SAAS,WAAW,QAAQ,EAAE,QAAQ,YAAY,OAAO,WAAW,CAAC;AACxF,UAAM,WAAW,SAAS,WAAW,QAAQ,EAAE,QAAQ,UAAU,OAAO,SAAS,CAAC;AAElF,UAAM,aAAa,WAAW,eAAe;AAC7C,UAAM,WAAW,SAAS,eAAe;AAEzC,UAAM,QAAQF,QAAO,MAAM,QAAQ;AAAA,MACjC,IAAI,GAAG;AAAA,MACP,OAAO,OAAKA,QAAO,QAAQ,QAAQ,CAAC;AAAA,IACtC,CAAC;AACD,QAAI,MAAM,SAAS,GAAG;AACtB,QAAI,SAAS;AAEb,QAAI,aAAa;AAEjB,QAAI,YAAY;AAChB,QAAI,WAA8B;AAClC,WAAO,aAAa,CAAC,QAAQ;AAC3B,YAAM,CAACW,QAAO,IAAI,IAAI;AACtB,iBAAW,SAAS,UAAU,QAAQA,MAAK;AAC3C,YAAM,iBAAiB,SAAS,sBAAsB,QAAQA,MAAK;AACnE,eAAS,IAAI,eAAe,SAAS,GAAG,KAAK,KAAK,CAAC,QAAQ,KAAK;AAC9D,cAAM,gBAAgB,eAAe;AACrC,cAAM,QAAQ,cAAc,eAAe;AAC3C,iBAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,gBAAM,OAAO,MAAM;AACnB,cAAI,KAAK,WAAW;AAAG;AACvB,cAAI,KAAK,UAAU,KAAK;AACtB,qBAAS;AACT,kBAAM,KAAK,SAAS,KAAK,SAAS;AAClC;AAAA,UACF;AAAA,QACF;AAAA,MACF;AACA,UAAI,CAAC,QAAQ;AACX,qBAAa;AACb,oBAAYX,QAAO,SAAS,QAAQ;AAAA,UAClC,IAAI;AAAA,UACJ,OAAO,OAAKA,QAAO,QAAQ,QAAQ,CAAC;AAAA,QACtC,CAAC;AAAA,MACH;AAAA,IACF;AACA,QAAI,CAAC;AAAU,aAAO;AACtB,WAAO,SAAS;AAAA,MACd;AAAA,MACA;AAAA,MACA,UAAU,CAAC,aAAa,WAAW,GAAG,IAAI;AAAA,MAC1C;AAAA,IACF;AAAA,EACF;AAAA,EAEA,kBACE,QACA,EAAE,IAAI,OAAO,QAAQ,IAA4C,CAAC,GACpD;AACd,UAAM,EAAE,UAAU,IAAI;AACtB,QAAI,CAAC,MAAM;AAAW,WAAK;AAC3B,QAAI,CAAC;AAAI,aAAO;AAChB,UAAM,UAAU,SAAS;AACzB,UAAM,QAAQ,UAAUE,OAAM,MAAM,EAAE,IAAIA,OAAM,IAAI,EAAE;AACtD,UAAM,QAAQ,SAAS,WAAW,QAAQ;AAAA,MACxC,QAAQ;AAAA,MACR,OAAO;AAAA,IACT,CAAC;AACD,UAAM,SAAS,OAAO;AACtB,UAAM,QAAQ,MAAM,eAAe;AACnC,UAAM,OAAO,MAAM,MAAM,SAAS;AAClC,UAAM,SAAS,KAAK,MAAM,KAAK,SAAS;AACxC,UAAM,QAAQF,QAAO,MAAM,QAAQ;AAAA,MACjC,IAAI;AAAA,MACJ,OAAO,OAAKA,QAAO,QAAQ,QAAQ,CAAC;AAAA,IACtC,CAAC;AACD,QAAI,CAAC;AAAO,aAAO;AACnB,UAAM,WAAW,SAAS,UAAU,QAAQ,MAAM,EAAE;AACpD,WAAO,SAAS,iBAAiB,QAAQ,UAAU,UAAU,SAAS,OAAO,MAAM;AAAA,EACrF;AAAA,EAEA,kBAAkB,QAAgB,IAA0B;AAC1D,UAAM,EAAE,UAAU,IAAI;AACtB,QAAI,CAAC,MAAM;AAAW,WAAK;AAC3B,QAAI,CAAC;AAAI,aAAO;AAChB,UAAM,aAAaE,OAAM,MAAM,EAAE;AACjC,UAAM,WAAWA,OAAM,IAAI,EAAE;AAC7B,UAAM,aAAa,SAAS,WAAW,QAAQ,EAAE,QAAQ,YAAY,OAAO,WAAW,CAAC;AACxF,UAAM,WAAW,SAAS,WAAW,QAAQ,EAAE,QAAQ,UAAU,OAAO,SAAS,CAAC;AAElF,UAAM,aAAa,WAAW,eAAe;AAC7C,UAAM,WAAW,SAAS,eAAe;AAEzC,QAAI,aAAaF,QAAO,MAAM,QAAQ;AAAA,MACpC,IAAI,GAAG;AAAA,MACP,OAAO,OAAKA,QAAO,QAAQ,QAAQ,CAAC;AAAA,IACtC,CAAC;AACD,QAAI,SAAS,SAAS,GAAG;AACzB,QAAI,SAAS;AACb,QAAI,aAAa;AACjB,QAAI,WAA8B;AAClC,WAAO,cAAc,CAAC,QAAQ;AAC5B,YAAM,CAAC,OAAO,IAAI,IAAI;AACtB,iBAAW,SAAS,UAAU,QAAQ,KAAK;AAC3C,YAAM,iBAAiB,SAAS,sBAAsB,QAAQ,KAAK;AACnE,eAAS,IAAI,GAAG,IAAI,eAAe,UAAU,CAAC,QAAQ,KAAK;AACzD,cAAM,gBAAgB,eAAe;AACrC,cAAM,QAAQ,cAAc,eAAe;AAC3C,iBAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,gBAAM,OAAO,MAAM;AACnB,cAAI,KAAK,WAAW;AAAG;AACvB,cAAI,KAAK,OAAO,QAAQ;AACtB,qBAAS;AACT,qBAAS,KAAK,MAAM,KAAK,SAAS;AAClC;AAAA,UACF;AAAA,QACF;AAAA,MACF;AACA,UAAI,CAAC,QAAQ;AACX,qBAAaA,QAAO,KAAK,QAAQ;AAAA,UAC/B,IAAI;AAAA,UACJ,OAAO,OAAKA,QAAO,QAAQ,QAAQ,CAAC;AAAA,QACtC,CAAC;AACD,qBAAa;AAAA,MACf;AAAA,IACF;AACA,QAAI,CAAC;AAAU,aAAO;AAEtB,WAAO,SAAS;AAAA,MACd;AAAA,MACA;AAAA,MACA,UAAU,CAAC,aAAa,WAAW,GAAG,IAAI;AAAA,MAC1C;AAAA,IACF;AAAA,EACF;AAAA,EAEA,qBAAqB,QAAgB,OAAc;AACjD,UAAM,aAAaA,QAAO,MAAM,QAAQ;AAAA,MACtC,OAAO,OAAKA,QAAO,QAAQ,QAAQ,CAAC;AAAA,MACpC,IAAI;AAAA,IACN,CAAC;AACD,UAAM,OAAO;AAAA,MACX,MAAM;AAAA,MACN,QAAQ;AAAA,IACV;AACA,QAAI,CAAC,YAAY;AACf,YAAM,IAAI,MAAM,+CAA+C,OAAO;AAAA,IACxE;AACA,UAAM,YAAYQ,MAAK,MAAM,WAAW,EAAE;AAC1C,QAAI,eAAe;AACnB,eAAW,CAAC,UAAU,QAAQ,KAAK,WAAW;AAC5C,UAAI,EAAE,KAAK,IAAI;AACf,YAAM,OAAO,WAAW,GAAG,OAAO,QAAQ;AAC1C,YAAM,CAAC,MAAM,IAAIR,QAAO,OAAO,QAAQ,IAAI;AAC3C,UAAI,UAAUA,QAAO,OAAO,QAAQ,MAAM,GAAG;AAC3C,eAAO;AAAA,MACT;AACA,UAAIY,MAAK,OAAO,MAAM,MAAM,IAAI,GAAG;AACjC,aAAK,UAAU,MAAM;AACrB,uBAAe;AAAA,MACjB,WAAW,CAAC,cAAc;AACxB,aAAK,UAAU,KAAK;AAAA,MACtB;AACA,WAAK,QAAQ;AAAA,IACf;AACA,WAAO;AAAA,EACT;AAAA,EAEA,gBAAgB,QAAgB,MAAY,QAAgB,WAAoB,OAAO;AACrF,UAAM,aAAaZ,QAAO,MAAM,QAAQ;AAAA,MACtC,OAAO,OAAKA,QAAO,QAAQ,QAAQ,CAAC;AAAA,MACpC,IAAI;AAAA,IACN,CAAC;AACD,QAAI,CAAC,YAAY;AACf,YAAM,IAAI,MAAM,8CAA8C,MAAM;AAAA,IACtE;AACA,UAAM,YAAYQ,MAAK,MAAM,WAAW,EAAE;AAC1C,QAAI,aAAa;AACjB,eAAW,CAAC,UAAU,QAAQ,KAAK,WAAW;AAC5C,UAAI,EAAE,KAAK,IAAI;AACf,YAAMK,QAAO,WAAW,GAAG,OAAO,QAAQ;AAC1C,YAAM,CAAC,QAAQ,UAAU,IAAIb,QAAO,OAAO,QAAQa,KAAI;AACvD,YAAM,SAAS,UAAUb,QAAO,OAAO,QAAQ,MAAM;AACrD,UAAI,QAAQ;AACV,eAAO;AAAA,MACT;AACA,YAAM,aAAa,KAAK;AACxB,YAAM,cAAc,aAAa;AACjC,UAAI,eAAe,QAAQ;AACzB,YAAI,YAAY,SAAS,KAAK,gBAAgB,QAAQ;AACpD,gBAAM,OAAOA,QAAO,KAAK,QAAQ;AAAA,YAC/B,IAAI,SAAS,aAAaa;AAAA,UAC5B,CAAC;AACD,cAAI,MAAM;AACR,mBAAO;AAAA,cACL,MAAM,KAAK;AAAA,cACX,QAAQ;AAAA,YACV;AAAA,UACF;AAAA,QACF;AACA,eAAO,EAAE,MAAAA,OAAM,QAAQ,cAAc,cAAc,QAAQ;AAAA,MAC7D,OAAO;AACL,sBAAc;AAAA,MAChB;AAAA,IACF;AACA,WAAO,EAAE,MAAM,OAAO;AAAA,EACxB;AAAA,EAKA,cACE,QACA,UACA,SAIuC;AACvC,UAAM,EAAE,YAAY,cAAc,IAAI;AACtC,UAAM,CAAC,aAAa,aAAa,IAAI,aAAa,WAAW,kBAAkB,QAAQ;AACvF,UAAM,aAAa,YAAY;AAC/B,QAAI,WAA8B;AAClC,QAAI,SAAS;AAEb,QAAI,YAAY;AACd,YAAM,WAAW,SAAS,UAAU,QAAQ,MAAM;AAClD,YAAM,oBAAoB,WAAW,QAAQ,IAAI,qBAAqB;AAKtE,YAAM,WACJ,qBAAqB,SAAS,SAAS,iBAAiB,IAAI,oBAAoB;AAClF,UAAI,WAAW,WAAW,QAAQ,IAAI,qBAAqB;AAC3D,UAAI,aAAgC;AAIpC,UAAI,UAAU;AACZ,mBAAW,SAAS,QAAQ,IAAI,4BAA4B;AAE5D,YAAI,UAAU;AACZ,gBAAMT,UAAS,SAAS,UAAU,MAAM;AACxC,gBAAM,QAAQA,QAAO,SAAS,YAAY;AAC1C,gBAAM,SAAS,UAAU,CAAC;AAC1B,gBAAM,OAAO,aAAa,aAAa;AAEvC,gBAAM,WAAW,MAAM,cAAc;AACrC,gBAAM,WAAW;AAAA,YACf,GAAG,MAAM,UAAU,MAAM;AAAA,cACvB,SAAS,iBAAiB,IAAI,2BAA2B;AAAA,YAC3D;AAAA,UACF;AAEA,mBAAS,QAAQ,QAAM;AACrB,eAAI,WAAY,YAAY,EAAE;AAAA,UAChC,CAAC;AAOD,mBAAS,SAAS,YAAa;AAC/B,uBAAa;AAAA,QACf;AAAA,MACF,WAAW,UAAU;AAGnB,mBAAW,SAAS,cAAc,IAAI,qBAAqB;AAG3D,YAAI,CAAC,UAAU;AACb,mBAAS;AAAA,QACX,OAAO;AACL,qBAAW,SAAS,QAAQ,IAAI,4BAA4B;AAC5D,uBAAa;AACb,mBAAS,WAAW,YAAa;AACjC,qBAAW,iBAAiB,IAAI,2BAA2B,EAAE,QAAQ,QAAM;AACzE,sBAAU,GAAG,YAAa;AAAA,UAC5B,CAAC;AAAA,QACH;AAAA,MACF;AAEA,UACE,cACA,WAAW,WAAW,YAAa,WAMlC,WAAW,aAAa,wBAAwB,KAI9C,cAAc,WAAW,aAAa,SAAS,MAAM,IACxD;AACA;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,UAAU;AACb,UAAI,eAAe;AACjB,eAAO;AAAA,MACT;AACA,YAAM,IAAI,MAAM,iDAAiD,UAAU;AAAA,IAC7E;AAKA,UAAM,aAAa,SAAS,aAAa,QAAQ,QAAS;AAC1D,UAAM,OAAO,SAAS,SAAS,QAAQ,UAAU;AACjD,WAAO,EAAE,MAAM,OAAO;AAAA,EACxB;AAAA,EAKA,cACE,QACA,UACA,SAIuC;AACvC,UAAM,EAAE,YAAY,cAAc,IAAI;AACtC,UAAM,KAAK,eAAe,QAAQ,IAAI,SAAS,aAAa,SAAS;AACrE,QAAI;AACJ,QAAI;AACJ,QAAI;AACJ,QAAI;AACJ,QAAI;AAEJ,QAAI,IAAI;AACN,UAAI,eAAe,QAAQ,GAAG;AAC5B,qBAAa,SAAS;AACtB,uBAAe,SAAS;AACxB,oBAAY,SAAS;AACrB,sBAAc,SAAS;AAKvB,YAAI,aAAa,cAAc,GAAG;AAChC,wBACE,SAAS,eAAe,SAAS,aACjC,SAAS,iBAAiB,SAAS;AAAA,QACvC,OAAO;AACL,wBAAc,SAAS;AAAA,QACzB;AAAA,MACF,OAAO;AACL,qBAAa,SAAS;AACtB,uBAAe,SAAS;AACxB,oBAAY,SAAS;AACrB,sBAAc,SAAS;AACvB,sBAAc,SAAS;AAAA,MACzB;AAAA,IACF;AAEA,QAAI,cAAc,QAAQ,aAAa,QAAQ,gBAAgB,QAAQ,eAAe,MAAM;AAC1F,YAAM,IAAI,MAAM,iDAAiD,UAAU;AAAA,IAC7E;AAEA,UAAM,SAAS,SAAS,cAAc,QAAQ,CAAC,YAAY,YAAY,GAAG;AAAA,MACxE;AAAA,MACA;AAAA,IACF,CAAC;AACD,QAAI,CAAC,QAAQ;AACX,aAAO;AAAA,IACT;AAEA,UAAM,QAAQ,cACV,SACA,SAAS,cAAc,QAAQ,CAAC,WAAW,WAAW,GAAG;AAAA,MACvD;AAAA,MACA;AAAA,IACF,CAAC;AACL,QAAI,CAAC,OAAO;AACV,aAAO;AAAA,IACT;AAEA,QAAI,QAAe,EAAE,QAAyB,MAAsB;AAKpE,QACEF,OAAM,WAAW,KAAK,KACtBA,OAAM,UAAU,KAAK,KACrBG,cAAa,SAAS,KACtBL,QAAO,KAAK,QAAQ,EAAE,IAAI,MAAM,OAAO,MAAM,UAAU,CAAC,GACxD;AACA,cAAQA,QAAO,YAAY,QAAQ,OAAO,EAAE,OAAO,KAAK,CAAC;AAAA,IAC3D;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,mBAAmB,QAAgB,GAAW,GAA6B;AACzE,UAAM,YAAY,SAAS,UAAU,QAAQ,MAAM;AACnD,UAAM,WAAW,UAAU,sBAAsB;AAEjD,WAAO,CAAC,IAAI,SAAS,MAAM,IAAI,SAAS,GAAG;AAAA,EAC7C;AAAA,EAEA,wBAAwB,QAAgB,GAAW,GAA6B;AAC9E,UAAM,YAAY,SAAS,UAAU,QAAQ,MAAM;AACnD,UAAM,WAAW,UAAU,sBAAsB;AACjD,WAAO,CAAC,IAAI,SAAS,MAAM,IAAI,SAAS,GAAG;AAAA,EAC7C;AAAA,EAEA,eAAe,QAAgB,QAAQ,OAAO,WAAW;AACvD,QAAI,CAAC;AAAO;AACZ,UAAM,WAAW,SAAS,WAAW,QAAQ,KAAK;AAClD,UAAM,UAAU,SAAS,aAAa;AACtC,mBAAe,SAAS;AAAA,MACtB,YAAY;AAAA,IACd,CAAC;AAAA,EACH;AACF;;;ADvjCW,SASL,UATK,KASL,YATK;AAfX,IAAMc,UAMD,WAAS;AACZ,QAAM,EAAE,QAAQ,QAAQ,MAAM,KAAK,IAAI;AACvC,QAAM,SAAS,kBAAkB;AACjC,QAAM,OAAO,SAAS,SAAS,QAAQ,IAAI;AAC3C,QAAM,aAAaC,MAAK,OAAO,IAAI;AAInC,MAAI,OAAO,OAAO,MAAM,GAAG;AACzB,WAAO,oBAAC,mBAAgB,QAAQC,MAAK,OAAO,MAAM,EAAE,QAAQ;AAAA,EAC9D;AAEA,MAAI,gBAAgB,kBAAkB,IAAI,GAAG;AAC3C,UAAM,EAAE,QAAQ,MAAM,gBAAgB,IAAI,KAAK;AAC/C,UAAM,UAAU,KAAK;AACrB,UAAM,OAAO,QAAQ,UAAU,GAAG,MAAM;AACxC,UAAM,QAAQ,QAAQ,UAAU,MAAM;AACtC,WACE,iCACG;AAAA,cAAQ,oBAAC,cAAW,MAAM,MAAM;AAAA,MACjC,oBAAC,qBAAkB,MAAM,iBAAiB;AAAA,MACzC,SAAS,oBAAC,cAAW,MAAM,OAAO;AAAA,OACrC;AAAA,EAEJ;AAIA,MACE,KAAK,SAAS,MACd,OAAO,SAAS,OAAO,SAAS,SAAS,OAAO,QAChD,CAAC,OAAO,SAAS,MAAM,KACvBC,QAAO,OAAO,QAAQ,UAAU,MAAM,IACtC;AACA,WAAO,oBAAC,mBAAgB,aAAW,MAAC;AAAA,EACtC;AAKA,MAAI,KAAK,SAAS,IAAI;AACpB,WAAO,oBAAC,mBAAgB;AAAA,EAC1B;AAIA,MAAI,UAAU,KAAK,KAAK,MAAM,EAAE,MAAM,MAAM;AAC1C,WAAO,oBAAC,cAAW,YAAU,MAAC,MAAM,KAAK,MAAM;AAAA,EACjD;AACA,SAAO,oBAAC,cAAW,MAAM,KAAK,MAAM;AACtC;AAKA,IAAM,aAAa,CAAC,UAAkD;AACpE,QAAM,EAAE,MAAM,aAAa,MAAM,IAAI;AAErC,QAAM,iBAAiB,MAAM;AAC3B,WAAO,GAAG,QAAQ,KAAK,aAAa,OAAO;AAAA,EAC7C;AAEA,SAAO,oBAAC,UAAM,GAAG,EAAE,CAAC,uBAAuB,KAAK,GAAI,yBAAe,GAAE;AACvE;AAEA,IAAM,oBAAoB,CAAC,UAA4B;AACrD,QAAM,EAAE,KAAK,IAAI;AACjB,SAAO,oBAAC,OAAG,GAAG,EAAE,CAAC,4BAA4B,KAAK,GAAI,gBAAK;AAC7D;AAMA,IAAM,kBAAkB,CAAC,UAAsD;AAC7E,QAAM,EAAE,SAAS,GAAG,cAAc,MAAM,IAAI;AAC5C,SACE;AAAA,IAAC;AAAA;AAAA,MACE,GAAG,EAAE,CAAC,2BAA2B,cAAc,MAAM,KAAK,CAAC,uBAAuB,OAAO;AAAA,MAEzF;AAAA;AAAA,QACA,cAAc,oBAAC,QAAG,IAAK;AAAA;AAAA;AAAA,EAC1B;AAEJ;AAEA,IAAO,iBAAQH;;;ADvFE,gBAAAI,MAWT,QAAAC,aAXS;AATjB,IAAM,OAAO,CAAC,UAMR;AACJ,QAAM,EAAE,QAAQ,MAAM,MAAM,QAAQ,kBAAkB,IAAI;AAE1D,MAAI,WAAW,gBAAAD,KAAC,kBAAO,QAAgB,QAAgB,MAAY,MAAY;AAE/E,QAAM,SAAS,kBAAkB;AACjC,MAAI,mBAAmB;AACrB,UAAM,uBAAuB,OAAO,kBAAkB;AAAA,MACpD,YAAY,EAAE,CAAC,4BAA4B,KAAK;AAAA,MAChD,MAAM;AAAA,MACN,UAAU,kBAAkB,EAAE,MAAM,KAAK,CAAC;AAAA,IAC5C,CAAC;AACD,QAAI;AACF,iBACE,gBAAAC,MAAO,iBAAN,EACE;AAAA;AAAA,QACA;AAAA,SACH;AAAA,EAEN;AAKA,QAAM,aAA6B;AAAA,IACjC,CAAC,qBAAqB;AAAA,EACxB;AACA,QAAM,gBAAgB,OAAO,qBAAqB,EAAE,YAAY,KAAK,CAAC;AACtE,SAAO,OAAO,WAAW,EAAE,YAAY,eAAe,UAAU,KAAK,CAAC;AACxE;AAEA,IAAM,eAAqB,YAAK,MAAM,CAAC,MAAM,SAAS;AACpD,SACE,KAAK,WAAW,KAAK,UACrB,KAAK,sBAAsB,KAAK,qBAChC,KAAK,WAAW,KAAK,UACrB,KAAK,SAAS,KAAK;AAEvB,CAAC;AAED,IAAO,eAAQ;;;AYzDf,YAAYC,YAAW;AAOhB,IAAM,4BAA4B,cAAoB,yBAAwB;;;ACPrF,YAAYC,YAAW;AAEvB,SAAS,YAAAC,iBAAgB;;;ACGzB,OAAOC,aAAyC;AAmChD,IAAM,2BAA2B,oBAAI,QAAwD;AAGtF,IAAM,mBAAmB,CAAC,WAAmB;AAClD,MAAI,QAAQ,yBAAyB,IAAI,MAAM;AAC/C,MAAI,CAAC,OAAO;AACV,YAAQA,QAAsB,OAAO;AAAA,MACnC,aAAa,CAAC;AAAA,IAChB,EAAE;AACF,6BAAyB,IAAI,QAAQ,KAAK;AAAA,EAC5C;AACA,SAAO;AACT;AAGA,IAAM,YAAY,CAAC,aAAgC;AACjD,QAAM,QAAQ,OAAO,aAAa;AAClC,SAAO,CAAC,MAAgB;AACtB,WAAO,QAAQ,EAAE,QAAQ,WAAW,MAAM;AAAA,EAC5C;AACF;AAGO,IAAM,WAAW;AAAA,EAEtB,gBAAgB,CAAC,UAAsC;AACrD,WAAO,SAAS,OAAO,MAAM,UAAU,cAAc,OAAO,MAAM,eAAe;AAAA,EACnF;AAAA,EAGA,QAAQ,CAAC,QAAgB,aAAuB;AAC9C,UAAM,QAAQ,iBAAiB,MAAM;AACrC,UAAM,SAAS,YAAU;AAAA,MACvB,aAAa,CAAC,GAAG,MAAM,aAAa,QAAQ;AAAA,IAC9C,EAAE;AAAA,EACJ;AAAA,EAGA,QAAQ,CAAC,QAAgB,aAAgC;AACvD,UAAM,QAAQ,iBAAiB,MAAM;AACrC,UAAM,SAAS,YAAU;AAAA,MACvB,aAAa,MAAM,YAAY,OAAO,OAAK,CAAC,UAAU,QAAQ,EAAE,CAAC,CAAC;AAAA,IACpE,EAAE;AAAA,EACJ;AAAA,EAEA,KAAK,CAAC,QAAgB,aAAgC;AACpD,UAAM,QAAQ,iBAAiB,MAAM;AACrC,WAAO,MAAM,SAAS,EAAE,YAAY,KAAK,UAAU,QAAQ,CAAC;AAAA,EAC9D;AACF;;;ADnFO,IAAM,mBAAmB,MAAM;AACpC,QAAM,SAAS,kBAAkB;AACjC,SAAa,eAAQ,MAAM;AACzB,WAAO,iBAAiB,MAAM;AAAA,EAChC,GAAG,CAAC,MAAM,CAAC;AACb;AAEO,IAAM,qBAAqB,CAAC,MAAY,SAAe;AAC5D,QAAM,QAAQ,iBAAiB;AAC/B,QAAM,cAAcC,UAAS,OAAO,WAAS,MAAM,WAAW;AAC9D,SAAa,eAAQ,MAAM;AACzB,WAAO,YAAY,OAAsD,CAAC,KAAK,aAAa;AAC1F,UAAI,CAAC,SAAS,eAAe,QAAQ;AAAG,eAAO;AAC/C,YAAM,SAAS,SAAS,MAAM,MAAM,IAAI;AACxC,UAAI,OAAO,SAAS,GAAG;AACrB,YAAI,KAAK,EAAE,UAAU,OAAO,CAAC;AAAA,MAC/B;AACA,aAAO;AAAA,IACT,GAAG,CAAC,CAAC;AAAA,EACP,GAAG,CAAC,aAAa,MAAM,IAAI,CAAC;AAC9B;AAEO,IAAM,wBAAwB,CAAC,SAAkB,SAAe;AACrE,QAAM,QAAQ,iBAAiB;AAC/B,QAAM,cAAcA,UAAS,OAAO,WAAS,MAAM,WAAW;AAC9D,SAAa,eAAQ,MAAM;AACzB,WAAO,YAAY,OAA0B,CAAC,KAAK,aAAa;AAC9D,UAAI,SAAS,eAAe,QAAQ;AAAG,eAAO;AAC9C,UAAI,SAAS,MAAM,SAAS,IAAI,GAAG;AACjC,YAAI,KAAK,QAAQ;AAAA,MACnB;AACA,aAAO;AAAA,IACT,GAAG,CAAC,CAAC;AAAA,EACP,GAAG,CAAC,aAAa,SAAS,IAAI,CAAC;AACjC;;;AdCM,gBAAAC,YAAA;AA1BN,IAAMC,QAAO,CAAC,UAKR;AACJ,QAAM,EAAE,QAAQ,QAAQ,MAAM,kBAAkB,IAAI;AACpD,QAAM,SAAS,kBAAkB;AACjC,QAAM,MAAY,cAAwB,IAAI;AAC9C,QAAM,MAAM,SAAS,QAAQ,QAAQ,IAAI;AACzC,QAAM,OAAO,SAAS,SAAS,QAAQ,IAAI;AAC3C,QAAM,YAAY,mBAAmB,MAAM,IAAI,EAAE,IAAI,CAAC,GAAG,WAAW;AAAA,IAClE,GAAG;AAAA,IACH,KAAK,eAAe;AAAA,EACtB,EAAE;AAEF,QAAM,SAAS,UACZ,IAAI,CAAC,EAAE,QAAAC,SAAQ,KAAAC,KAAI,MAAMD,QAAO,IAAI,YAAU,EAAE,GAAG,OAAO,CAACC,OAAM,KAAK,EAAE,CAAC,EACzE,KAAK;AACR,QAAM,SAAS,UAAU,YAAY,MAAM,MAAM;AAEjD,QAAM,eAAe,UAAU,IAAI,OAAK,EAAE,GAAG;AAC7C,QAAM,WAAW,CAAC;AAClB,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,UAAM,OAAO,OAAO;AACpB,QAAI,UACF,gBAAAH;AAAA,MAAC;AAAA;AAAA,QACC;AAAA,QACA,QAAQ,UAAU,MAAM,OAAO,SAAS;AAAA,QAExC;AAAA,QACA;AAAA,QACA;AAAA;AAAA,MAHK,GAAG,IAAI,MAAM;AAAA,IAIpB;AAEF,eAAWG,QAAO,cAAc;AAC9B,UAAIA,QAAO,MAAM;AACf,cAAM,MAAM,UAAU,aAAa,QAAQA,IAAG,GAAG,SAAS,WAAW;AAAA,UACnE,MAAM;AAAA,UACN;AAAA,UACA,UAAU;AAAA,QACZ,CAAC;AACD,kBAAgB,oBAAa,KAAK,EAAE,KAAAA,KAAI,CAAC;AAAA,MAC3C;AAAA,IACF;AACA,aAAS,KAAK,OAAO;AAAA,EACvB;AAEA,4BAA0B,MAAM;AAC9B,UAAM,iBAAiB,yBAAyB,IAAI,MAAM;AAC1D,QAAI,IAAI,SAAS;AACf,sBAAgB,IAAI,KAAK,IAAI,OAAO;AACpC,sBAAgB,IAAI,MAAM,IAAI,OAAO;AACrC,sBAAgB,IAAI,IAAI,SAAS,IAAI;AAAA,IACvC,OAAO;AACL,sBAAgB,OAAO,GAAG;AAC1B,sBAAgB,OAAO,IAAI;AAAA,IAC7B;AAAA,EACF,CAAC;AAED,SACE,gBAAAH,KAAC,UAAM,GAAG,EAAE,CAAC,qBAAqB,OAAO,GAAG,KACzC,UACH;AAEJ;AAEA,IAAM,eAAqB,YAAKC,OAAM,CAAC,MAAM,SAAS;AACpD,SACE,KAAK,WAAW,KAAK,UACrB,KAAK,WAAW,KAAK,UACrB,KAAK,SAAS,KAAK,QACnB,KAAK,sBAAsB,KAAK;AAEpC,CAAC;AAED,IAAO,eAAQ;;;AgB3Ff,YAAYG,YAAW;AACvB,SAAS,UAAAC,eAAoB;AAC7B,SAAS,YAAAC,iBAAgB;;;ACDzB,SAAS,UAAAC,SAAyB,SAAAC,cAAa;AAC/C,OAAOC,aAAyC;AAUhD,IAAM,uBAAuB,oBAAI,QAAuC;AAaxE,IAAM,8BAA8B,oBAAI,QAGtC;AAEF,IAAM,sBAAsB,CAAC,WAAqB;AAChD,MAAI,QAAQ,4BAA4B,IAAI,MAAM;AAClD,MAAI,CAAC,OAAO;AACV,YAAQC,QAAyB,OAAO;AAAA,MACtC,cAAc,CAAC;AAAA,MACf,SAAS,CAAC;AAAA,IACZ,EAAE;AACF,gCAA4B,IAAI,QAAQ,KAAK;AAAA,EAC/C;AACA,SAAO;AACT;AAEO,IAAM,cAAc;AAAA,EACzB,UAAU;AAAA,EAEV,SAAS,CAAC,OAA6B;AACrC,WAAO,qBAAqB,IAAI,EAAE,KAAK;AAAA,EACzC;AAAA,EAEA,WAAW,CAAC,QAAkB,IAA0B,QAAQ,UAAU;AACxE,UAAM,QAAQ,oBAAoB,MAAM;AACxC,yBAAqB,IAAI,IAAI,KAAK;AAElC,UAAM,SAAS,YAAU;AAAA,MACvB,cAAc,CAAC,GAAG,MAAM,aAAa,OAAO,OAAK,MAAM,EAAE,GAAG,EAAE;AAAA,IAChE,EAAE;AAEF,WAAO,MAAM;AACX,YAAM,SAAS,YAAU;AAAA,QACvB,cAAc,MAAM,aAAa,OAAO,OAAK,MAAM,EAAE;AAAA,MACvD,EAAE;AACF,2BAAqB,OAAO,EAAE;AAAA,IAChC;AAAA,EACF;AAAA,EAEA,QAAQ,CAAC,QAAkB,UAAqB;AAC9C,UAAM,QAAQ,oBAAoB,MAAM;AACxC,UAAM,QAAQ,MAAM,SAAS;AAC7B,QAAI,SAAmC;AACvC,QAAI,cAA2C;AAC/C,UAAM,cAAc,MAAM,QAAQ,KAAK,OAAK,EAAE,SAAS,EAAE,MAAM,OAAO,MAAM,EAAE;AAC9E,QAAI,aAAa;AACf,YAAM,IAAI,YAAY,YAAY,KAAK;AACvC,UAAI,GAAG;AACL,iBAAS;AACT,sBAAc,YAAY;AAAA,MAC5B;AAAA,IACF,OAEK;AACH,YAAM,uBAAuB,MAAM,QAAQ,KAAK,OAAK,EAAE,MAAM,OAAO,MAAM;AAC1E,YAAM,eAAe,MAAM,aAAa,KAAK,OAAM,YAAY,QAAQ,CAAC,IAAI,IAAI,CAAE;AAClF,eAAS,IAAI,aAAa,SAAS,GAAG,KAAK,GAAG,KAAK;AACjD,sBAAc,aAAa;AAC3B,YAAI,CAAC,YAAY,QAAQ,WAAW,KAAK;AAAsB;AAC/D,cAAM,IAAI,YAAY,KAAK;AAC3B,YAAI,GAAG;AACL,mBAAS;AACT;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,UAAM,UAAU,MAAM,QAAQ,OAAO,OAAK;AACxC,UAAI,CAAC,EAAE,SAAU,EAAE,MAAM,OAAO,MAAM,MAAM;AAAS,eAAO;AAC5D,aAAOC,QAAO,QAAQ,QAAQ,EAAE,MAAM,EAAE;AAAA,IAC1C,CAAC;AAED,QAAI,UAAU,aAAa;AACzB,cAAQ,KAAK;AAAA,QACX;AAAA,QACA,OAAO,YAAY,QAAQ,WAAW;AAAA,QACtC;AAAA,QACA;AAAA,MACF,CAAC;AAAA,IACH;AACA,UAAM,SAAS,EAAE,QAAQ,CAAC;AAC1B,WAAO;AAAA,EACT;AAAA,EAEA,SAAS,CAAC,WAAqB;AAC7B,UAAM,aAAa,SAAS,WAAW,MAAM;AAC7C,UAAM,QAAQ,oBAAoB,MAAM;AACxC,QAAI,YAAY;AACd,YAAM,SAAS,EAAE,SAAS,CAAC,EAAE,CAAC;AAAA,IAChC,WAAWA,QAAO,QAAQ,QAAQ,MAAM,GAAG;AACzC,kBAAY,OAAO,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC;AAAA,IACzC,WAAW,OAAO,aAAaC,OAAM,YAAY,OAAO,SAAS,GAAG;AAClE,YAAM,QAAQD,QAAO,MAAM,QAAQ;AAAA,QACjC,IAAI,OAAO;AAAA,MACb,CAAC;AACD,iBAAW,SAAS,OAAO;AACzB,YAAIA,QAAO,QAAQ,QAAQ,MAAM,EAAE,GAAG;AACpC,iBAAO,YAAY,OAAO,QAAQ,KAAK;AAAA,QACzC;AAAA,MACF;AACA,YAAM,SAAS,CAAC,EAAE,QAAQ,MAAM;AAC9B,eAAO;AAAA,UACL,SAAS,QAAQ,OAAO,OAAK;AAC3B,gBAAI,CAAC,EAAE;AAAO,qBAAO;AACrB,mBAAOA,QAAO,QAAQ,QAAQ,EAAE,MAAM,EAAE;AAAA,UAC1C,CAAC;AAAA,QACH;AAAA,MACF,CAAC;AAAA,IACH,OAAO;AACL,YAAM,SAAS,CAAC,EAAE,QAAQ,OAAO;AAAA,QAC/B,SAAS,QAAQ,OAAO,OAAK,EAAE,KAAK;AAAA,MACtC,EAAE;AAAA,IACJ;AAAA,EACF;AACF;;;ADpIO,IAAM,sBAAsB,MAAM;AACvC,QAAM,SAAS,kBAAkB;AACjC,SAAa,eAAQ,MAAM;AACzB,WAAO,YAAY,SAAS,MAAM;AAAA,EACpC,GAAG,CAAC,MAAM,CAAC;AACb;AAQO,IAAM,iBAAiB,CAAC,SAAe;AAC5C,QAAM,SAAS,kBAAkB;AACjC,QAAM,QAAQ,oBAAoB;AAClC,QAAM,UAAUE,UAAS,OAAO,WAAS,MAAM,OAAO;AACtD,4BAA0B,MAAM;AAC9B,QAAIC,QAAO,QAAQ,QAAQ,IAAI,GAAG;AAChC,kBAAY,OAAO,QAAQ,CAAC,MAAM,SAAS,SAAS,QAAQ,IAAI,CAAC,CAAC;AAClE,aAAO,MAAM;AACX,cAAM,SAAS,CAAC,EAAE,SAAAC,SAAQ,MAAM;AAC9B,iBAAO;AAAA,YACL,SAASA,SAAQ,OAAO,OAAK,EAAE,MAAM,OAAO,IAAI;AAAA,UAClD;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF,GAAG,CAAC,OAAO,MAAM,MAAM,CAAC;AAExB,SAAa,eAAQ,MAAM;AACzB,WAAO,QAAQ,KAAK,OAAK,EAAE,MAAM,OAAO,IAAI,GAAG;AAAA,EACjD,GAAG,CAAC,SAAS,IAAI,CAAC;AACpB;;;AjBuCQ,gBAAAC,YAAA;AAzDR,IAAMC,WAAU,CAAC,UAIX;AACJ,QAAM,EAAE,SAAS,WAAW,kBAAkB,IAAI;AAClD,QAAM,MAAY,cAAoB,IAAI;AAC1C,QAAM,SAAS,kBAAkB;AACjC,QAAM,WAAW,OAAO,SAAS,OAAO;AACxC,QAAM,MAAM,SAAS,QAAQ,QAAQ,OAAO;AAE5C,QAAM,2BAA2B,eAAe,OAAO;AACvD,MAAI,WAA4B,qBAAY;AAAA,IAC1C,MAAM;AAAA,IACN;AAAA,IACA,mBAAmBC,QAAO,QAAQ,QAAQ,OAAO,IAC7C,4BAA4B,oBAC5B;AAAA,EACN,CAAC;AAID,QAAM,aAAgC;AAAA,IACpC,CAAC,qBAAqB;AAAA,IACtB;AAAA,EACF;AAEA,MAAI,UAAU;AACZ,eAAW,wBAAwB;AAAA,EACrC;AAIA,MAAI,CAAC,YAAYA,QAAO,WAAW,QAAQ,OAAO,GAAG;AACnD,UAAM,OAAOC,MAAK,OAAO,OAAO;AAChC,UAAM,MAAM,aAAa,IAAI;AAE7B,QAAI,QAAQ,OAAO;AACjB,iBAAW,MAAM;AAAA,IACnB;AAAA,EACF;AAGA,MAAID,QAAO,OAAO,QAAQ,OAAO,GAAG;AAClC,eAAW,sBAAsB;AAEjC,UAAM,MAAM,WAAW,SAAS;AAChC,UAAM,CAAC,CAAC,IAAI,CAAC,IAAIC,MAAK,MAAM,OAAO;AAEnC,eACE,gBAAAH;AAAA,MAAC;AAAA;AAAA,QACC,OAAO;AAAA,UACL,QAAQ;AAAA,UACR,OAAO;AAAA,UACP,SAAS;AAAA,QACX;AAAA,QAEA,0BAAAA;AAAA,UAAC;AAAA;AAAA,YACC,mBAAmB,qBAAqB;AAAA,YACxC,QAAQ;AAAA,YACR,QAAQ;AAAA,YACR;AAAA;AAAA,QACF;AAAA;AAAA,IACF;AAGF,kBAAc,IAAI,MAAM,CAAC;AACzB,mBAAe,IAAI,MAAM,OAAO;AAAA,EAClC;AAGA,4BAA0B,MAAM;AAC9B,UAAM,iBAAiB,yBAAyB,IAAI,MAAM;AAC1D,QAAI,IAAI,SAAS;AACf,sBAAgB,IAAI,KAAK,IAAI,OAAO;AACpC,sBAAgB,IAAI,SAAS,IAAI,OAAO;AACxC,sBAAgB,IAAI,IAAI,SAAS,OAAO;AAAA,IAC1C,OAAO;AACL,sBAAgB,OAAO,GAAG;AAC1B,sBAAgB,OAAO,OAAO;AAAA,IAChC;AAAA,EACF,CAAC;AACD,QAAM,OAAO,SAAS,SAAS,QAAQ,OAAO;AAE9C,QAAM,gBAAgB,OAAO,wBAAwB,EAAE,YAAY,QAAQ,CAAC;AAE5E,MAAI,UAAU,OAAO,cAAc,EAAE,YAAY,eAAe,UAAU,QAAQ,CAAC;AAEnF,QAAM,YAAY,sBAAsB,SAAS,IAAI;AAErD,MAAI,UAAU,SAAS,GAAG;AACxB,cAAU,UAAU,YAAY,CAACI,WAAU,aAAa;AACtD,aAAO,SAAS,cAAc;AAAA,QAC5B,MAAM;AAAA,QACN;AAAA,QACA,UAAAA;AAAA,MACF,CAAC;AAAA,IACH,GAAG,OAAO;AAAA,EACZ;AAEA,SAAO;AACT;AAEA,IAAM,kBAAwB,YAAKH,UAAS,CAAC,MAAM,SAAS;AAC1D,SACE,KAAK,YAAY,KAAK,WACtB,KAAK,sBAAsB,KAAK,sBAC/B,KAAK,cAAc,KAAK,aACtB,CAAC,CAAC,KAAK,aAAa,CAAC,CAAC,KAAK,aAAaI,OAAM,OAAO,KAAK,WAAW,KAAK,SAAS;AAE1F,CAAC;AAED,IAAO,kBAAQ;;;AmBvIf,YAAYC,aAAW;AAEhB,IAAM,sBAA4B,sBAAuB,KAAK;AAK9D,IAAM,kBAAkB,MAAe;AAC5C,SAAa,mBAAW,mBAAmB;AAC7C;;;ACTA,YAAYC,aAAW;AAEhB,IAAM,qBAA2B,sBAAuB,KAAK;AAK7D,IAAM,iBAAiB,MAAe;AAC3C,SAAa,mBAAW,kBAAkB;AAC5C;;;ACTA,YAAYC,aAAW;AAGhB,IAAM,cAAoB,sBAA2B,IAAI;AAEzD,IAAM,UAAU,MAAmB;AACxC,SAAa,mBAAW,WAAW;AACrC;;;AtBiCY,gBAAAC,YAAA;AAzBZ,IAAM,cAAc,CAAC,UAIf;AACJ,QAAM,EAAE,MAAM,WAAW,kBAAkB,IAAI;AAC/C,QAAM,SAAS,kBAAkB;AACjC,QAAM,OAAO,SAAS,SAAS,QAAQ,IAAI;AAC3C,QAAM,WAAW,CAAC;AAClB,QAAM,cACJC,SAAQ,UAAU,IAAI,KAAK,CAAC,OAAO,SAAS,IAAI,KAAKC,QAAO,WAAW,QAAQ,IAAI;AAErF,WAAS,IAAI,GAAG,IAAI,KAAK,SAAS,QAAQ,KAAK;AAC7C,UAAM,IAAI,KAAK,OAAO,CAAC;AACvB,UAAM,IAAI,KAAK,SAAS;AACxB,UAAM,MAAM,SAAS,QAAQ,QAAQ,CAAC;AACtC,UAAM,QAAQA,QAAO,MAAM,QAAQ,CAAC;AACpC,UAAM,MAAM,aAAaC,OAAM,aAAa,OAAO,SAAS;AAC5D,UAAM,UACJ,aAAaA,OAAM,SAAS,OAAO,UAAU,MAAM,KAAKA,OAAM,SAAS,OAAO,UAAU,KAAK;AAE/F,QAAIF,SAAQ,UAAU,CAAC,GAAG;AACxB,YAAM,UACJ,gBAAAD,KAAC,oBAAoB,UAApB,EAAiE,OAAO,CAAC,CAAC,KACzE,0BAAAA,KAAC,mBAAmB,UAAnB,EAA+D,OAAO,WAAW,OAChF,0BAAAA;AAAA,QAAC;AAAA;AAAA,UACC,SAAS;AAAA,UAET,WAAW;AAAA,UACX;AAAA;AAAA,QAFK,IAAI;AAAA,MAGX,KANgC,oBAAoB,IAAI,IAO1D,KARiC,qBAAqB,IAAI,IAS5D;AAEF,UAAIE,QAAO,OAAO,QAAQ,CAAC,GAAG;AAC5B,iBAAS;AAAA,UACP,gBAAAF,KAAC,YAAY,UAAZ,EAAqD,OAAO,GAC1D,qBADwB,iBAAiB,IAAI,IAEhD;AAAA,QACF;AAAA,MACF,OAAO;AACL,iBAAS,KAAK,OAAO;AAAA,MACvB;AAAA,IACF,OAAO;AACL,eAAS;AAAA,QACP,gBAAAA;AAAA,UAAC;AAAA;AAAA,YACC;AAAA,YAEA,QAAQ,eAAe,MAAM,KAAK,SAAS,SAAS;AAAA,YACpD,QAAQ;AAAA,YACR,MAAM;AAAA;AAAA,UAHD,IAAI;AAAA,QAIX;AAAA,MACF;AAAA,IACF;AAEA,kBAAc,IAAI,GAAG,CAAC;AACtB,mBAAe,IAAI,GAAG,IAAI;AAAA,EAC5B;AAEA,SAAO;AACT;AAEA,IAAO,uBAAQ;;;AuB7Ef,YAAYI,aAAW;;;ACAvB,YAAYC,aAAW;AAOvB,IAAM,qBAAqB,CAAI,YAAwB;AACrD,MAAI,aAAa;AAEjB,QAAM,iBAAiB,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtD,YAAQ;AAAA,MACN,WAAU,aAAa,OAAO,EAAE,YAAY,MAAM,CAAC,IAAI,QAAQ,KAAK;AAAA,MACpE,WAAS,OAAO,EAAE,YAAY,MAAM,CAAC;AAAA,IACvC;AAAA,EACF,CAAC;AAED,SAAO;AAAA,IACL,SAAS;AAAA,IACT,QAAQ,MAAO,aAAa;AAAA,EAC9B;AACF;AAEA,IAAM,OAAO,MAAM;AAAC;AAEpB,IAAM,QAAQ,CAAC,MAAc,IAAI,QAAQ,aAAW,WAAW,SAAS,CAAC,CAAC;AAE1E,IAAM,yBAAyB,MAAS;AACtC,QAAM,kBAAwB,eAA6B,CAAC,CAAC;AAE7D,QAAM,uBAAuB,CAAC,YAC3B,gBAAgB,UAAU,CAAC,GAAG,gBAAgB,SAAS,OAAO;AAEjE,QAAM,uBAAuB,CAAC,YAC3B,gBAAgB,UAAU,gBAAgB,QAAQ,OAAO,OAAK,MAAM,OAAO;AAE9E,QAAM,uBAAuB,MAAM,gBAAgB,QAAQ,IAAI,OAAK,EAAE,OAAO,CAAC;AAE9E,QAAM,MAAM;AAAA,IACV;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,SAAO;AACT;;;AD5CA,IAAM,mBAAmB,CAAC,YAGpB;AACJ,QAAM,EAAE,SAAS,gBAAgB,IAAI;AACrC,QAAM,MAAM,uBAAuB;AACnC,QAAM,WAAiB,eAAiC;AACxD,QAAM,WAAiB,eAAO,CAAC;AAE/B,QAAM,cAAc,CAAC,UAAiD;AACpE,UAAM,QAAQ,SAAS;AACvB,WAAO,QACH,KAAK,IAAI,MAAM,UAAU,MAAM,CAAC,IAAI,MAAM,KAAK,IAAI,MAAM,UAAU,MAAM,CAAC,IAAI,KAC9E;AAAA,EACN;AAEA,QAAM,QAAQ,MAAM;AAClB,QAAI,qBAAqB;AACzB,aAAS,UAAU;AAAA,EACrB;AAEA,QAAM,sBAAsB,CAAC,UAA4B;AACvD,QAAI,MAAM,WAAW;AAAG;AACxB,UAAM,QAAQ,SAAS;AACvB,QAAI,OAAO;AACT,UAAI,YAAY,KAAK,GAAG;AACtB,YAAI,qBAAqB;AACzB,iBAAS,WAAW;AACpB,YAAI,gBAAgB,OAAO,SAAS,OAAO,MAAM,OAAO;AACtD,gBAAM;AACN;AAAA,QACF;AAAA,MACF,OAAO;AACL,cAAM;AAAA,MACR;AAAA,IACF,OAAO;AACL,eAAS,UAAU;AACnB,eAAS,UAAU;AAAA,QACjB,GAAG,MAAM;AAAA,QACT,GAAG,MAAM;AAAA,MACX;AAAA,IACF;AACA,QAAI,SAAS,YAAY,KAAK,gBAAgB,OAAO,CAAC,MAAM,OAAO;AACjE,YAAM;AAAA,IACR,OAAO;AACL,YAAM,eAAe,mBAAmB,IAAI,MAAM,GAAG,CAAC;AACtD,UAAI,qBAAqB,YAAY;AACrC,aAAO,aAAa,QACjB,KAAK,MAAM;AACV,YAAI,qBAAqB,YAAY;AACrC,YAAI;AAAS,kBAAQ,KAAK;AAC1B,iBAAS,UAAU;AAAA,MACrB,CAAC,EACA,MAAM,eAAa;AAClB,YAAI,qBAAqB,YAAY;AACrC,YAAI,CAAC,UAAU,YAAY;AACzB,gBAAM,UAAU;AAAA,QAClB;AAAA,MACF,CAAC;AAAA,IACL;AAAA,EACF;AAEA,SAAO,EAAE,qBAAqB,YAAY;AAC5C;;;AEnEA,YAAYC,aAAW;AACvB,OAAO,cAAc;AAkBjB,gBAAAC,YAAA;AAFG,IAAM,qBACL,mBAA6C,CAAC,EAAE,UAAU,MAAM,UAAU,MAAM,GAAG,QACvF,gBAAAA;AAAA,EAAC;AAAA;AAAA,IACC;AAAA,IACA,OAAO;AAAA,MACL,UAAU;AAAA,MACV,KAAK,KAAK;AAAA,MACV,MAAM,KAAK;AAAA,MACX,OAAO,KAAK;AAAA,MACZ,QAAQ,KAAK;AAAA,MAGb,SAAS;AAAA,MACT,iBAAiB,GAAG,KAAK,SAAS;AAAA,MAClC,QAAQ;AAAA,MACR,GAAG;AAAA,IACL;AAAA,IACC,GAAG;AAAA,IAEH;AAAA;AACH,CACD;AAEH,mBAAmB,cAAc;AAE1B,IAAM,cAAoB,aAAK,oBAAoB,CAAC,MAAM,SAAS;AACxE,SACE,KAAK,KAAK,SAAS,KAAK,KAAK,QAC7B,KAAK,KAAK,QAAQ,KAAK,KAAK,OAC5B,KAAK,KAAK,UAAU,KAAK,KAAK,SAC9B,KAAK,KAAK,WAAW,KAAK,KAAK,UAC/B,KAAK,KAAK,UAAU,KAAK,KAAK,SAC9B,KAAK,aAAa,KAAK;AAE3B,CAAC;AAMD,IAAM,kBACE,mBAA6C,CAAC,EAAE,SAAS,GAAG,QAAQ;AACxE,QAAM,CAAC,MAAM,OAAO,IAAU,iBAAqB;AACnD,QAAM,eAAqB,eAAuB,IAAI;AAEtD,4BAA0B,MAAM;AAC9B,QAAI,CAAC,aAAa,WAAW,aAAa,QAAQ;AAAY;AAC9D,UAAMC,QAAO,aAAa,QAAQ,aAAa,EAAE,MAAM,OAAO,CAAC;AAC/D,YAAQA,KAAI;AAAA,EACd,GAAG,CAAC,CAAC;AAEL,EAAM,4BAAoB,KAAK,MAAM,MAAO,CAAC,IAAI,CAAC;AAElD,SACE,gBAAAD,KAAC,SAAI,KAAK,cAAc,OAAO,EAAE,UAAU,YAAY,QAAQ,GAAG,KAAK,GAAG,MAAM,EAAE,GAC/E,kBACC,SAAS,aAAa,gBAAAA,KAAC,SAAI,OAAO,EAAE,eAAe,OAAO,GAAI,UAAS,GAAQ,IAAI,GACvF;AAEJ,CAAC;AAEH,gBAAgB,cAAc;AAE9B,IAAO,iBAAQ;;;AChFf,YAAYE,aAAW;AACvB,SAAS,SAAAC,cAAa;;;ACDtB,YAAYC,aAAW;AACvB,SAAS,YAAAC,iBAAgB;;;ACDzB,OAAOC,aAAyC;AAChD,SAAoB,SAAAC,cAAqB;AAyCzC,IAAM,oCAAoC,oBAAI,QAG5C;AAEF,IAAMC,YAAW,CAAC,WAAmB;AACnC,MAAI,QAAQ,kCAAkC,IAAI,MAAM;AACxD,MAAI,CAAC,OAAO;AACV,YAAQC,QAA8B,OAAO;AAAA,MAC3C,OAAO;AAAA,QACL,YAAY;AAAA,QAEZ,WAAW;AAAA,QAEX,YAAY;AAAA,QAEZ,YAAY;AAAA,QAEZ,WAAW;AAAA,QAEX,YAAY;AAAA,QAEZ,YAAY;AAAA,MACd;AAAA,MACA,WAAW;AAAA,MACX,OAAO;AAAA,MACP,SAAS;AAAA,IACX,EAAE;AACF,sCAAkC,IAAI,QAAQ,KAAK;AAAA,EACrD;AACA,SAAO;AACT;AAEO,IAAM,mBAAmB;AAAA,EAC9B,UAAAD;AAAA,EAEA,UAAU,CAAC,QAAgB,UAA0C;AACnE,UAAM,QAAQA,UAAS,MAAM;AAC7B,UAAM,SAAS,YAAU,EAAE,GAAG,OAAO,MAAM,EAAE;AAAA,EAC/C;AAAA,EAEA,cAAc,CAAC,QAAgB,cAAgC;AAC7D,UAAM,QAAQA,UAAS,MAAM;AAC7B,UAAM,SAAS,YAAU,EAAE,GAAG,OAAO,UAAU,EAAE;AAAA,EACnD;AAAA,EAEA,YAAY,CAAC,QAAgB,YAAqB;AAChD,UAAM,QAAQA,UAAS,MAAM;AAC7B,UAAM,SAAS,YAAU,EAAE,GAAG,OAAO,QAAQ,EAAE;AAAA,EACjD;AAAA,EAEA,QAAQ,QAAgB,OAAc,WAAW,MAAM;AACrD,QAAI,QAAmB,CAAC;AACxB,QAAIE,OAAM,YAAY,KAAK,GAAG;AAC5B,YAAM,WAAW,SAAS,WAAW,QAAQ,KAAK;AAClD,YAAM,cAAc,SAAS,eAAe;AAC5C,UAAI,YAAY,SAAS,GAAG;AAC1B,gBAAQ,CAAC,YAAY,YAAY,SAAS,EAAE;AAAA,MAC9C,OAAO;AACL,gBAAQ,CAAC,SAAS,sBAAsB,CAAC;AAAA,MAC3C;AAAA,IACF,OAAO;AACL,cAAQ,oBAAoB,QAAQ,KAAK;AAAA,IAC3C;AAEA,WAAO,WACH,MAAM,IAAI,OAAK;AACb,YAAM,CAAC,GAAG,CAAC,IAAI,SAAS,mBAAmB,QAAQ,EAAE,MAAM,EAAE,GAAG;AAChE,QAAE,IAAI;AACN,QAAE,IAAI;AACN,aAAO;AAAA,IACT,CAAC,IACD;AAAA,EACN;AACF;;;AD7GO,IAAM,2BAA2B,MAAM;AAC5C,QAAM,SAAS,kBAAkB;AACjC,SAAa,gBAAQ,MAAM;AACzB,WAAO,iBAAiB,SAAS,MAAM;AAAA,EACzC,GAAG,CAAC,MAAM,CAAC;AACb;AAEO,IAAM,2BAA2B,MAAM;AAC5C,QAAM,QAAQ,yBAAyB;AACvC,SAAOC,UAAS,OAAO,WAAS,MAAM,KAAK;AAC7C;AAEO,IAAM,+BAA+B,MAAM;AAChD,QAAM,QAAQ,yBAAyB;AACvC,SAAOA,UAAS,OAAO,WAAS,MAAM,SAAS;AACjD;AAEO,IAAM,2BAA2B,MAAM;AAC5C,QAAM,SAAS,kBAAkB;AACjC,QAAM,YAAY,6BAA6B;AAC/C,QAAM,CAAC,OAAO,QAAQ,IAAU,iBAAoB,CAAC,CAAC;AACtD,4BAA0B,MAAM;AAC9B,UAAMC,SAAQ,YAAY,iBAAiB,QAAQ,QAAQ,SAAS,IAAI,CAAC;AACzE,8BAA0B,IAAI,QAAQA,MAAK;AAC3C,aAASA,MAAK;AAAA,EAChB,GAAG,CAAC,QAAQ,SAAS,CAAC;AAEtB,SAAO;AACT;AAEO,IAAM,6BAA6B,MAAM;AAC9C,QAAM,QAAQ,yBAAyB;AACvC,SAAOD,UAAS,OAAO,WAAS,MAAM,OAAO;AAC/C;;;AD0CI,gBAAAE,YAAA;AA9DJ,IAAM,iBAA6C,aAAK,CAAC,EAAE,UAAU,IAAI,MAAM;AAC7E,QAAM,SAAS,kBAAkB;AAEjC,QAAM,CAAC,OAAO,IAAI,WAAW;AAE7B,QAAM,QAAc,eAAe;AAEnC,QAAM,MAAY,eAAuB,IAAI;AAE7C,QAAM,CAAC,QAAQ,IAAI,YAAY;AAE/B,QAAM,UAAU,2BAA2B;AAC3C,QAAM,YAAY,6BAA6B;AAC/C,QAAM,QAAQ,yBAAyB;AACvC,QAAM,QAAQ,yBAAyB;AAEvC,QAAM,aAAa,gBAAgB,MAAM,aAAa,MAAM;AAC5D,QAAM,aAAa,gBAAgB,MAAM,aAAa,MAAM;AAE5D,QAAM,OAAa,gBAAQ,MAAM;AAC/B,QAAI,CAAC,aAAa,MAAM,WAAW,KAAK,CAAC,WAAW,CAACC,OAAM,YAAY,SAAS;AAAG,aAAO;AAC1F,WAAO,MAAM,GAAG,OAAO;AAAA,EACzB,GAAG,CAAC,SAAS,OAAO,SAAS,CAAC;AAE9B,QAAM,cAAoB,oBAAY,MAAM;AAC1C,iBAAa,MAAM,OAAO;AAAA,EAC5B,GAAG,CAAC,CAAC;AAEL,QAAM,aAAa,CAAC,YAAqB;AACvC,UAAM,QAAQ,IAAI;AAClB,QAAI,OAAO;AACT,YAAM,MAAM,UACV,YAAY,SAAY,OAAO,OAAO,IAAI,MAAM,MAAM,YAAY,MAAM,MAAM;AAAA,IAClF;AAAA,EACF;AAEA,QAAM,SAAe;AAAA,IACnB,CAAC,YAAqB;AACpB,kBAAY;AACZ,UAAI,CAAC,QAAQ,YAAY;AAAO;AAChC,UAAI,aAAa,IAAI,MAAM,GAAG;AAC5B,mBAAW,CAAC;AAAA,MACd,OAAO;AACL,mBAAW,OAAO;AAAA,MACpB;AACA,YAAM,UAAU,WAAW,MAAM;AAC/B,eAAO;AAAA,MACT,GAAG,OAAO;AAAA,IACZ;AAAA,IACA,CAAC,aAAa,QAAQ,MAAM,OAAO;AAAA,EACrC;AAEA,4BAA0B,MAAM;AAC9B,QAAI,UAAU;AACZ,kBAAY;AAAA,IACd;AAAO,aAAO,CAAC;AACf,WAAO,MAAM,YAAY;AAAA,EAC3B,GAAG,CAAC,QAAQ,UAAU,QAAQ,WAAW,CAAC;AAE1C,MAAI,CAAC,WAAW;AAAU,WAAO;AAEjC,SACE,gBAAAD;AAAA,IAAC;AAAA;AAAA,MACC,MACE,OACI,OAAO,OAAO,CAAC,GAAG,MAAM,EAAE,OAAO,YAAY,OAAO,WAAW,CAAC,IAChE,EAAE,OAAO,GAAG,QAAQ,GAAG,KAAK,GAAG,MAAM,EAAE;AAAA,MAE7C;AAAA,MACA,OAAO,EAAE,YAAY,sBAAsB,SAAS,OAAO,IAAI,EAAE;AAAA;AAAA,EACnE;AAEJ,CAAC;AACD,eAAe,cAAc;;;AG5F7B,SAAS,SAAAE,cAAa;AAsBlB,qBAAAC,WAGM,OAAAC,YAHN;AATJ,IAAM,qBAA+C,MAAM;AACzD,QAAM,YAAY,6BAA6B;AAC/C,QAAM,QAAQ,yBAAyB;AACvC,QAAM,UAAU,2BAA2B;AAC3C,QAAM,QAAQ,yBAAyB;AACvC,QAAM,CAAC,OAAO,IAAI,WAAW;AAC7B,MAAI,CAAC,WAAW,CAAC,aAAaC,OAAM,YAAY,SAAS;AAAG,WAAO;AAEnE,SACE,gBAAAD,KAAAD,WAAA,EACG,gBAAM,IAAI,CAAC,MAAM,UAAU;AAC1B,WACE,gBAAAC;AAAA,MAAC;AAAA;AAAA,QAEC,MAAM,OAAO,OAAO,CAAC,GAAG,KAAK,OAAO,GAAG;AAAA,UACrC,OAAO,iBAAiB,UAAU,MAAM,aAAa,MAAM;AAAA,QAC7D,CAAC;AAAA;AAAA,MAHI,OAAO;AAAA,IAId;AAAA,EAEJ,CAAC,GACH;AAEJ;;;ACpCA,SAAS,SAAAE,cAAa;AACtB,YAAYC,aAAW;AAmBvB,SAAS,aAAAC,kBAAiB;AAuHpB,gBAAAC,YAAA;AAjHN,IAAM,iBAAuC,CAAC,EAAE,UAAU,MAAM;AAC9D,QAAM,SAAS,kBAAkB;AACjC,QAAM,WAAiB,eAA4B,IAAI;AACvD,QAAM,CAAC,SAAS,UAAU,IAAI,WAAW;AACzC,QAAM,CAAC,QAAQ,IAAI,YAAY;AAE/B,QAAM,CAAC,MAAM,OAAO,IAAU,iBAA4B,IAAI;AAE9D,4BAA0B,MAAM;AAC9B,QAAI,SAAS;AAAS,sBAAgB,IAAI,QAAQ,SAAS,OAAO;AAClE,WAAO,MAAM;AACX,sBAAgB,OAAO,MAAM;AAAA,IAC/B;AAAA,EACF,GAAG,CAAC,MAAM,CAAC;AAEX,EAAAD,WAAU,MAAM;AACd,QAAI,WAAW;AACb,aAAO,MAAM;AACb,eAAS,eAAe,MAAM;AAAA,IAChC;AAAA,EACF,GAAG,CAAC,QAAQ,SAAS,CAAC;AAEtB,QAAM,gBAAgB,CAAC,UAA+B;AACpD,UAAM,EAAE,YAAY,IAAI;AACxB,QAAI,SAAS,YAAY,MAAM,KAAK,YAAY,gBAAgB,OAAO;AACrE,mBAAa,IAAI,QAAQ,KAAK;AAAA,IAChC;AAEA,QAAI,MAAM,oBAAoB,SAAS,YAAY,MAAM,GAAG;AAC1D;AAAA,IACF;AACA,WAAO,UAAU,WAAW;AAAA,EAC9B;AAEA,QAAM,cAAc,CAAC,UAA+B;AAClD,UAAM,EAAE,YAAY,IAAI;AACxB,WAAO,QAAQ,WAAW;AAAA,EAC5B;AAEA,QAAM,aAAa,MAAM;AACvB,QAAI,CAAC,aAAa,IAAI,MAAM,KAAK,CAAC,YAAY,IAAI,MAAM;AAAG,iBAAW,KAAK;AAAA,EAC7E;AAEA,QAAM,cAAc,MAAM;AACxB,eAAW,IAAI;AAAA,EACjB;AAEA,QAAM,oBAAoB,CAAC,UAAgD;AACzE,UAAM,WAAW,MAAM;AACvB,QAAI,EAAE,oBAAoB;AAAsB;AAChD,UAAM,EAAE,MAAM,IAAI;AAClB,WAAO,cAAc,KAAK;AAAA,EAC5B;AAEA,QAAM,cAAc,CAAC,UAAgD;AACnE,UAAM,WAAW,MAAM;AACvB,QAAI,EAAE,oBAAoB;AAAsB;AAChD,UAAM,QAAQ,SAAS;AACvB,QAAI,CAAC,aAAa,IAAI,MAAM,GAAG;AAC7B,eAAS,QAAQ;AAAA,IACnB;AACA,WAAO,QAAQ,KAAK;AAAA,EACtB;AAEA,QAAM,yBAAyB,CAAC,OAA+B;AAC7D,UAAM,EAAE,KAAK,IAAI,GAAG;AACpB,WAAO,mBAAmB,IAAI;AAAA,EAChC;AAEA,QAAM,uBAAuB,CAAC,UAAkC;AAC9D,UAAM,WAAW,MAAM;AACvB,QAAI,EAAE,oBAAoB;AAAsB;AAChD,UAAM,QAAQ,SAAS;AACvB,aAAS,QAAQ;AACjB,WAAO,iBAAiB,KAAK;AAAA,EAC/B;AAEA,QAAM,cAAc,CAAC,UAAgC;AACnD;AAAA,MACE,CAACE,WAAgC;AAC/B,YAAI,SAAS,GAAG,MAAM,GAAG;AACvB,UAAAA,OAAM,eAAe;AAAA,QACvB;AAAA,MACF;AAAA,MACA,CAAAA,WAAS;AACP,cAAM,EAAE,YAAY,IAAIA;AACxB,cAAM,cAAc,cAAc,IAAI,MAAM;AAC5C,QAAAA,OAAM,eAAe;AACrB,cAAM,IAAI,IAAI,eAAe,cAAc,cAAc,SAAS,WAAW;AAC7E,eAAO,QAAQ,CAAC;AAAA,MAClB;AAAA,IACF,EAAE,KAAK;AAAA,EACT;AAEA,QAAM,YAAY,6BAA6B;AAC/C,QAAM,QAAQ,yBAAyB;AAEvC,4BAA0B,MAAM;AAC9B,QAAI,CAAC,aAAa,CAAC,WAAW,MAAM,WAAW;AAAG,aAAO,QAAQ,IAAI;AACrE,QAAIC,OAAM,YAAY,SAAS,GAAG;AAChC,cAAQ,MAAM,GAAG,OAAO,CAAC;AAAA,IAC3B,OAAO;AACL,YAAMC,QAAO,MAAM,MAAM,SAAS,GAAG,OAAO;AAC5C,MAAAA,MAAK,OAAOA,MAAK,OAAOA,MAAK;AAC7B,aAAO,QAAQA,KAAI;AAAA,IACrB;AAAA,EACF,GAAG,CAAC,SAAS,OAAO,SAAS,CAAC;AAE9B,SACE,gBAAAH;AAAA,IAAC;AAAA;AAAA,MACC,MAAM,OAAO,OAAO,CAAC,GAAG,MAAM,EAAE,OAAO,eAAe,OAAO,EAAE,CAAC;AAAA,MAChE,OAAO,EAAE,SAAS,GAAG,SAAS,QAAQ,YAAY,eAAe,UAAU,SAAS;AAAA,MAEpF,0BAAAA;AAAA,QAAC;AAAA;AAAA,UACC,KAAK;AAAA,UACL,MAAM;AAAA,UACN,OAAO;AAAA,YACL,UAAU;AAAA,YACV,YAAY;AAAA,YACZ,SAAS;AAAA,YACT,QAAQ;AAAA,YACR,YAAY;AAAA,YACZ,OAAO;AAAA,YACP,UAAU;AAAA,YACV,QAAQ;AAAA,UACV;AAAA,UACA;AAAA,UACA,WAAW;AAAA,UACX,SAAS;AAAA,UACT,eAAe;AAAA,UACf,SAAS;AAAA,UACT,oBAAoB;AAAA,UACpB,kBAAkB;AAAA,UAClB,QAAQ;AAAA,UACR,SAAS;AAAA,UACT,SAAS;AAAA;AAAA,MACX;AAAA;AAAA,EACF;AAEJ;;;ACrKA,YAAYI,aAAW;;;ACAvB,OAAOC,aAAyC;AAChD,SAAS,UAAAC,SAAe,WAAAC,UAAS,QAAAC,aAAuB;AAyBxD,IAAM,uBAAuB,oBAAI,QAAoD;AAErF,IAAM,eAAe,CAAC,WAAmB;AACvC,MAAI,QAAQ,qBAAqB,IAAI,MAAM;AAC3C,MAAI,CAAC,OAAO;AACV,YAAQC,QAAkB,OAAO;AAAA,MAC/B,MAAM;AAAA,IACR,EAAE;AACF,yBAAqB,IAAI,QAAQ,KAAK;AAAA,EACxC;AACA,SAAO;AACT;AAKO,IAAM,OAAO;AAAA,EAClB,UAAU;AAAA,EAEV,SAAS,CAAC,WAAmB;AAC3B,UAAM,QAAQ,aAAa,MAAM;AACjC,UAAM,EAAE,KAAK,IAAI,MAAM,SAAS;AAChC,WAAO;AAAA,EACT;AAAA,EAEA,SAAS,CAAC,QAAgB,SAAqC;AAC7D,UAAM,QAAQ,aAAa,MAAM;AACjC,UAAM,SAAS,WAAS;AACtB,aAAO;AAAA,QACL,MAAM,SAAS,OAAO,OAAO,OAAO,OAAO,CAAC,GAAG,MAAM,MAAM,IAAI;AAAA,MACjE;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEA,OAAO,CAAC,WAAmB;AACzB,UAAM,QAAQ,aAAa,MAAM;AACjC,UAAM,SAAS,EAAE,MAAM,KAAK,CAAC;AAAA,EAC/B;AAAA,EAEA,aAAa,CAAC,WAAmB;AAC/B,UAAM,OAAO,KAAK,QAAQ,MAAM;AAChC,QAAI,CAAC,QAAQ,KAAK,SAAS;AAAS;AACpC,UAAM,EAAE,IAAI,SAAS,IAAI;AACzB,QAAI,CAAC;AAAI;AACT,UAAM,QAAQC,QAAO,MAAM,QAAQ;AAAA,MACjC,IAAIC,MAAK,OAAO,EAAE,IAAI,KAAK,GAAG;AAAA,MAC9B,OAAO,OAAKC,SAAQ,UAAU,CAAC;AAAA,MAC/B,MAAM;AAAA,IACR,CAAC;AACD,QAAI,CAAC;AAAO;AACZ,UAAM,UAAU,SAAS,UAAU,QAAQ,MAAM,EAAE;AACnD,UAAM,OAAO,QAAQ,sBAAsB;AAC3C,UAAM,EAAE,GAAG,OAAO,IAAI;AACtB,UAAM,EAAE,GAAG,GAAG,IAAI;AAClB,QAAI,KAAK,IAAI,SAAS,GAAG;AACvB,aAAOD,MAAK,KAAK,MAAM,EAAE;AAAA,IAC3B,OAAO;AACL,aAAO,MAAM;AAAA,IACf;AAAA,EACF;AACF;;;ADnFA,SAAS,YAAAE,iBAAgB;AAElB,IAAM,eAAe,MAAM;AAChC,QAAM,SAAS,kBAAkB;AACjC,QAAM,QAAc,gBAAQ,MAAM;AAChC,WAAO,KAAK,SAAS,MAAM;AAAA,EAC7B,GAAG,CAAC,MAAM,CAAC;AACX,SAAO;AACT;AAMO,IAAM,cAAc,MAAM;AAC/B,QAAM,QAAQ,aAAa;AAE3B,QAAM,OAAOA,UAAS,OAAO,WAAS,MAAM,SAAS,IAAI;AAEzD,SAAa,gBAAQ,MAAM,MAAM,CAAC,IAAI,CAAC;AACzC;AAEO,IAAM,cAAc,MAAM;AAC/B,QAAM,QAAQ,aAAa;AAE3B,QAAM,OAAOA,UAAS,OAAO,WAAS,MAAM,MAAM,QAAQ,IAAI;AAE9D,SAAa,gBAAQ,MAAM,MAAM,CAAC,IAAI,CAAC;AACzC;AAMO,IAAM,YAAY,MAAM;AAC7B,QAAM,QAAQ,aAAa;AAC3B,QAAM,OAAOA,UAAS,OAAO,WAAS,MAAM,IAAI;AAEhD,SAAa,gBAAQ,MAAM,MAAM,MAAM,MAAM,CAAC,IAAI,CAAC;AACrD;AAMO,IAAM,kBAAkB,MAAM;AACnC,QAAM,QAAQ,aAAa;AAC3B,QAAM,OAAOA,UAAS,OAAO,WAAS,MAAM,IAAI;AAEhD,SAAa,gBAAQ,MAAM,MAAM,YAAY,MAAM,CAAC,IAAI,CAAC;AAC3D;AAMO,IAAM,cAAc,MAAM;AAC/B,QAAM,QAAQ,aAAa;AAC3B,QAAM,OAAOA,UAAS,OAAO,WAAS,MAAM,IAAI;AAEhD,SAAa,gBAAQ,MAAM,MAAM,QAAQ,GAAG,CAAC,IAAI,CAAC;AACpD;AAEO,IAAM,iBAAiB,MAAM;AAClC,QAAM,SAAS,kBAAkB;AAEjC,QAAM,UAAgB;AAAA,IACpB,CAAC,SAAqC;AACpC,WAAK,QAAQ,QAAQ,IAAI;AAAA,IAC3B;AAAA,IACA,CAAC,MAAM;AAAA,EACT;AAEA,QAAM,UAAgB,oBAAY,MAAM;AACtC,WAAO,KAAK,QAAQ,MAAM;AAAA,EAC5B,GAAG,CAAC,MAAM,CAAC;AAEX,SAAa,gBAAQ,OAAO,EAAE,SAAS,QAAQ,IAAI,CAAC,SAAS,OAAO,CAAC;AACvE;;;AEjFA,YAAYC,aAAW;AACvB,SAAS,UAAAC,UAAQ,WAAAC,UAAS,QAAAC,OAAM,gBAAgB;AAkE1C,gBAAAC,aAAA;AA1DC,IAAM,qBAA2B,aAAK,MAAM;AACjD,QAAM,SAAS,kBAAkB;AACjC,QAAM,SAAS,UAAU;AACzB,QAAM,WAAW,YAAY;AAC7B,QAAM,eAAe,gBAAgB;AACrC,QAAM,QAAc,gBAAQ,MAAM;AAChC,QAAI,CAAC,UAAU,CAAC;AAAc,aAAO;AACrC,QAAI,aAAa,SAAS;AACxB,YAAM,QAAQC,SAAO,MAAM,QAAQ;AAAA,QACjC,IAAI;AAAA,QACJ,OAAO,OAAKC,SAAQ,UAAU,CAAC;AAAA,QAC/B,MAAM;AAAA,MACR,CAAC;AACD,UAAI,CAAC;AAAO,eAAO;AACnB,YAAM,UAAU,SAAS,UAAU,QAAQ,MAAM,EAAE;AACnD,YAAM,OAAO,QAAQ,sBAAsB;AAC3C,UAAI,EAAE,GAAG,EAAE,IAAI;AACf,YAAM,EAAE,QAAQ,MAAM,IAAI;AAC1B,YAAM,EAAE,GAAG,GAAG,IAAI;AAClB,YAAM,QAAQ;AAEd,UAAI,KAAK,IAAI,SAAS,GAAG;AACvB,aAAK,SAAS;AAAA,MAChB,OAEK;AACH,cAAM,WAAWD,SAAO,SAAS,QAAQ;AAAA,UACvC,IAAI,MAAM;AAAA,UACV,OAAO,CAAC,GAAG,MAAM;AACf,gBAAI,CAACC,SAAQ,UAAU,CAAC;AAAG,qBAAO;AAClC,kBAAM,WAAW,SAAS,KAAK,QAAQ,MAAM,EAAE;AAC/C,gBAAI,CAAC;AAAU,qBAAO;AACtB,kBAAM,YAAY,SAAS,KAAK,QAAQ,CAAC;AACzC,gBAAI,CAAC;AAAW,qBAAO;AAEvB,mBAAOC,MAAK,OAAO,SAAS,IAAI,UAAU,EAAE;AAAA,UAC9C;AAAA,UACA,MAAM;AAAA,QACR,CAAC;AACD,YAAI,UAAU;AACZ,gBAAM,kBAAkB,SAAS,UAAU,QAAQ,SAAS,EAAE;AAC9D,gBAAM,eAAe,gBAAgB,sBAAsB;AAC3D,cAAI,aAAa,IAAI,aAAa,SAAS;AAAA,QAC7C,OAAO;AACL,eAAK;AAAA,QACP;AAAA,MACF;AACA,YAAM,CAAC,IAAI,EAAE,IAAI,SAAS,mBAAmB,QAAQ,GAAG,CAAC;AACzD,aAAO,CAAC,IAAI,QAAQ,IAAI,IAAI,OAAO,CAAC,CAAC;AAAA,IACvC;AAEA,WAAO,iBAAiB,QAAQ,QAAQF,SAAO,MAAM,QAAQ,MAAM,CAAC;AAAA,EACtE,GAAG,CAAC,cAAc,QAAQ,UAAU,MAAM,CAAC;AAE3C,QAAM,EAAE,WAAW,WAAW,IAAI,yBAAyB;AAC3D,MAAI,CAAC,SAAS,MAAM,WAAW;AAAG,WAAO;AACzC,MAAI,aAAa,SAAS;AACxB,WACE,gBAAAD;AAAA,MAAC;AAAA;AAAA,QACC,MAAM,OAAO,OAAO,CAAC,GAAG,MAAM,GAAG,OAAO,GAAG;AAAA,UACzC,OAAO;AAAA,QACT,CAAC;AAAA;AAAA,IACH;AAAA,EAEJ;AACA,SACE,gBAAAA;AAAA,IAAC;AAAA;AAAA,MACC,MAAM,OAAO,OAAO,CAAC,GAAG,MAAM,GAAG,OAAO,GAAG;AAAA,QACzC,OAAO;AAAA,QACP,OAAO;AAAA,MACT,CAAC;AAAA;AAAA,EACH;AAEJ,CAAC;AAED,mBAAmB,cAAc;;;ACpFjC,OAAOI,aAAW;;;ACAlB,OAAOC,aAAW;AAClB,SAAS,YAAAC,iBAAgB;AACzB,OAAO,aAAa;;;ACFpB,OAAOC,YAAW;AAElB,OAAOC,aAAyC;AAgBhD,IAAM,wBAAwB,oBAAI,QAGhC;AAEF,IAAMC,YAAW,CAAC,WAAmB;AACnC,MAAI,QAAQ,sBAAsB,IAAI,MAAM;AAC5C,MAAI,CAAC,OAAO;AACV,YAAQD,QAAsC,OAAO;AAAA,MACnD,YAAY,CAAC;AAAA,IACf,EAAE;AACF,0BAAsB,IAAI,QAAQ,KAAK;AAAA,EACzC;AACA,SAAO;AACT;AAEO,IAAM,OAAO;AAAA,EAClB,UAAAC;AAAA,EAEA,MAAoC,QAAgB,WAAwB,QAAW,CAAC,GAAQ;AAC9F,UAAM,QAAQA,UAAS,MAAM;AAC7B,UAAM,SAAS,WAAS;AACtB,YAAM,EAAE,WAAW,IAAI;AACvB,UAAI,WAAW,KAAK,OAAK,EAAE,cAAc,SAAS;AAAG,eAAO;AAC5D,aAAO;AAAA,QACL,YAAY,CAAC,GAAG,YAAY,EAAE,WAAW,MAAM,CAAiB;AAAA,MAClE;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEA,QAAQ,QAAgB,WAAqB;AAC3C,UAAM,QAAQA,UAAS,MAAM;AAC7B,UAAM,SAAS,WAAS;AACtB,YAAM,EAAE,WAAW,IAAI;AACvB,UAAI,CAAC,WAAW,KAAK,OAAK,EAAE,cAAc,SAAS;AAAG,eAAO;AAC7D,aAAO;AAAA,QACL,YAAY,WAAW,OAAO,OAAK,EAAE,cAAc,SAAS;AAAA,MAC9D;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEA,QAAQ,CACN,QACA,OACAC,aAA4D,MAAM,SAC/D;AACH,UAAM,QAAQD,UAAS,MAAM;AAC7B,UAAM,SAAS,WAAS;AACtB,YAAM,EAAE,WAAW,IAAI;AACvB,aAAO;AAAA,QACL,YAAY,WAAW,IAAI,CAAC,GAAG,UAAU;AACvC,cAAI,CAACC,WAAU,EAAE,WAAW,KAAK;AAAG,mBAAO;AAC3C,iBAAO,EAAE,GAAG,GAAG,OAAOH,OAAM,EAAE,OAAO,KAAK,EAAE;AAAA,QAC9C,CAAC;AAAA,MACH;AAAA,IACF,CAAC;AAAA,EACH;AACF;;;ADrEO,IAAM,eAAe,MAAM;AAChC,QAAM,SAAS,kBAAkB;AACjC,SAAOI,QAAM,QAAQ,MAAM,KAAK,SAAS,MAAM,GAAG,CAAC,MAAM,CAAC;AAC5D;AAEO,IAAM,oBAAoB,MAAM;AACrC,QAAM,QAAQ,aAAa;AAC3B,SAAOC,UAAS,OAAO,WAAS,MAAM,YAAY,OAAO;AAC3D;AAEO,IAAM,gBAAgB,CAAC,cAAwB;AACpD,QAAM,aAAa,kBAAkB;AACrC,QAAM,SAAS,kBAAkB;AACjC,QAAM,OAAO,WAAW,KAAK,OAAK,EAAE,cAAc,SAAS;AAC3D,SAAOD,QAAM,QAAQ,MAAM;AACzB,WAAO;AAAA,MACL,MAAM,MAAM,UAAU;AAAA,MACtB,CAAC,WAAoB;AACnB,aAAK,OAAO,QAAQ,EAAE,OAAO,GAAG,OAAK,MAAM,SAAS;AAAA,MACtD;AAAA,IACF;AAAA,EACF,GAAG,CAAC,QAAQ,MAAM,SAAS,CAAC;AAC9B;;;ADtBI,qBAAAE,WAEI,OAAAC,aAFJ;AAHG,IAAM,QAAQC,QAAM,KAAK,MAAM;AACpC,QAAM,QAAQ,kBAAkB;AAChC,SACE,gBAAAD,MAAAD,WAAA,EACG,gBAAM,IAAI,CAAC,EAAE,WAAW,WAAW,MAAM,GAAG,UAC3C,gBAAAC,MAAC,aAAuB,GAAG,SAAX,KAAkB,CACnC,GACH;AAEJ,CAAC;AACD,MAAM,cAAc;;;AGbpB,YAAYE,aAAW;AACvB,SAAS,SAAAC,eAAa;AAgDhB,qBAAAC,WAWI,OAAAC,OAXJ,QAAAC,aAAA;AA9BN,IAAM,sBAAuD;AAAA,EAC3D,CAAC,EAAE,oBAAoB,kBAAkB,MAAM;AAC7C,UAAM,YAAY,6BAA6B;AAC/C,UAAM,QAAQ,yBAAyB;AACvC,UAAM,UAAU,2BAA2B;AAC3C,UAAM,QAAQ,yBAAyB;AACvC,UAAM,SAAS,kBAAkB;AAEjC,QACE,MAAM,WAAW,KACjB,CAAC,iBACD,CAAC,WACD,CAAC,aACD,YAAY,IAAI,MAAM,KACrB,CAAC,eAAe,IAAI,MAAM,KAAKC,QAAM,YAAY,SAAS;AAE3D,aAAO;AACT,UAAM,SAAS,MAAM;AACrB,UAAM,QAAQ,MAAM,MAAM,SAAS;AAEnC,UAAM,YAAiC;AAAA,MACrC,UAAU;AAAA,MACV,OAAO;AAAA,MACP,QAAQ;AAAA,MACR,cAAc;AAAA,MACd,oBAAoB;AAAA,MACpB,YAAY,MAAM;AAAA,IACpB;AAEA,WACE,gBAAAD,MAAAF,WAAA,EACE;AAAA,sBAAAC;AAAA,QAAC;AAAA;AAAA,UACC,MAAM,OAAO,OAAO,CAAC,GAAG,OAAO,OAAO,GAAG;AAAA,YACvC,OAAO,MAAM;AAAA,YACb,OAAO;AAAA,YACP,MAAM,OAAO,OAAO;AAAA,UACtB,CAAC;AAAA,UACD,OAAO;AAAA,YACL,QAAQ;AAAA,UACV;AAAA,UAEA,0BAAAA;AAAA,YAAC;AAAA;AAAA,cACC,cAAc;AAAA,cACd,OAAO;AAAA,gBACL,GAAG;AAAA,gBACH,KAAK;AAAA,gBACL,MAAM;AAAA,cACR;AAAA;AAAA,UACF;AAAA;AAAA,MACF;AAAA,MACA,gBAAAA;AAAA,QAAC;AAAA;AAAA,UACC,MAAM,OAAO,OAAO,CAAC,GAAG,MAAM,OAAO,GAAG;AAAA,YACtC,OAAO,MAAM;AAAA,YACb,OAAO;AAAA,YACP,MAAM,MAAM,QAAQ;AAAA,UACtB,CAAC;AAAA,UACD,OAAO;AAAA,YACL,QAAQ;AAAA,UACV;AAAA,UAEA,0BAAAA;AAAA,YAAC;AAAA;AAAA,cACC,cAAc;AAAA,cACd,OAAO;AAAA,gBACL,GAAG;AAAA,gBACH,QAAQ;AAAA,gBACR,OAAO;AAAA,cACT;AAAA;AAAA,UACF;AAAA;AAAA,MACF;AAAA,OACF;AAAA,EAEJ;AACF;AACA,oBAAoB,cAAc;;;AtCrC9B,gBAAAG,OAylBE,QAAAC,aAzlBF;AAHJ,IAAM,WAAW,CAAC,UAAyE;AACzF,QAAM,SAAS,YAAY;AAC3B,SACE,gBAAAD,MAAO,kBAAN,EACE,+BAAY,EAAE,GAAG,OAAO,MAAM,QAAQ,WAAW,OAAO,UAAU,CAAC,GACtE;AAEJ;AAmBO,IAAM,kBAAkB,CAAC,UAAyB;AACvD,QAAM;AAAA,IACJ,YAAY;AAAA,IACZ;AAAA,IACA,UAAU,eAAe;AAAA,IACzB;AAAA,IACA,QAAQ,CAAC;AAAA,IACT,IAAI,YAAY;AAAA,IAChB,uBAAuB;AAAA,OACpB;AAAA,EACL,IAAI;AACJ,QAAM,SAAS,kBAAkB;AAEjC,QAAM,MAAY,eAAuB,IAAI;AAC7C,QAAM,CAAC,UAAU,WAAW,IAAI,YAAY;AAE5C,QAAM,cAAoB,eAAO,KAAK;AACtC,QAAM,SAAS,UAAU;AACzB,QAAM,WAAW,YAAY;AAC7B,QAAM,EAAE,SAAS,QAAQ,IAAI,eAAe;AAE5C,QAAM,CAAC,UAAU,WAAW,IAAU,iBAAS,KAAK;AAGpD,QAAM,iBAAuB,eAAsB,IAAI;AAEvD,EAAM,kBAAU,MAAM;AACpB,QAAI,eAAe,CAAC,UAAU;AAC5B,YAAM,cAAc,YAAY;AAAA,QAC9B;AAAA,QACA,CAAC,CAAC,IAAI,MAAM;AACV,cAAI,SAAS,SAAS,IAAI,KAAK,CAAC,KAAK,SAAS,KAAK,OAAKE,SAAO,OAAO,QAAQ,CAAC,CAAC;AAC9E,mBAAO,MAAM;AAAA,QACjB;AAAA,QACA;AAAA,MACF;AAEA,aAAO,MAAM;AACX,oBAAY;AAAA,MACd;AAAA,IACF;AAAA,EACF,GAAG,CAAC,QAAQ,aAAa,QAAQ,CAAC;AAElC,4BAA0B,MAAM;AAC9B,gBAAY,YAAY;AAAA,EAC1B,GAAG,CAAC,YAAY,CAAC;AAEjB,4BAA0B,MAAM;AAC9B,WAAO,QAAQ,QAAQ,MAAM,QAAQ,OAAO;AAAA,EAC9C,GAAG,CAAC,QAAQ,IAAI,CAAC;AAEjB,4BAA0B,MAAM;AAC9B,QAAI;AAA2B,uBAAiB,SAAS,QAAQ,yBAAyB;AAAA,EAC5F,GAAG,CAAC,QAAQ,yBAAyB,CAAC;AAEtC,QAAM,CAAC,SAAS,UAAU,IAAI,WAAW;AAEzC,QAAM,gBAAsB,eAAqB,IAAI;AACrD,QAAM,gBAAsB,eAAO,KAAK;AAExC,QAAM,sBAAsB,MAAM;AAChC,QAAI,eAAe;AAAS,mBAAa,eAAe,OAAO;AAAA,EACjE;AAEA,QAAM,0BAA0B,CAAC,UAAmC;AAClE,UAAM,cAAc,aAAa,IAAI,MAAM;AAC3C,UAAM,aAAa,YAAY,IAAI,MAAM;AACzC,QAAI,CAAC,eAAe,CAAC,cAAc,CAAC,MAAM;AAAkB,iBAAW,KAAK;AAAA,EAC9E;AAEA,QAAM,kBAAkB,CAAC,OAAqB,OAAO,MAAM,aAAa,SAAS;AAC/E,QAAI,CAAC;AAAO;AACZ,UAAM,EAAE,UAAU,IAAI;AACtB,QAAI,CAAC,QAAQ,aAAaC,QAAM,SAAS,WAAW,KAAK,GAAG;AAC1D;AAAA,IACF;AACA,QAAI,SAAuB;AAE3B,QAAI,YAAY,IAAI,MAAM,GAAG;AAC3B,eAAS;AAAA,IACX,OAAO;AACL,eAAS,iBAAiB,IAAI,MAAM,KAAK,YAAY,UAAU,SAAS,cAAc;AAAA,IACxF;AACA,QAAI,CAAC;AAAQ;AACb,UAAM,QAAe,EAAE,QAAQ,OAAO,MAAM;AAC5C,QAAI,aAAa,cAAcA,QAAM,OAAO,OAAO,SAAS,GAAG;AAC7D,aAAO,MAAM;AACb,iBAAW,IAAI;AACf,aAAO;AAAA,IACT;AACA,IAAAC,YAAW,OAAO,QAAQ,KAAK;AAC/B,WAAO;AAAA,EACT;AAEA,QAAM,yBAAyB,CAAC,UAAsB;AACpD,QAAI,MAAM;AAAkB;AAC5B,wBAAoB;AAEpB,QAAI,eAAe,IAAI,MAAM,GAAG;AAC9B,4BAAsB,KAAK;AAC3B,kBAAY,IAAI,QAAQ,KAAK;AAAA,IAC/B,WAAW,cAAc,IAAI,MAAM,GAAG;AACpC,kBAAY,IAAI,QAAQ,KAAK;AAC7B,mBAAa,IAAI,QAAQ,KAAK;AAC9B,oBAAc,IAAI,QAAQ,KAAK;AAC/B,YAAM,eAAe;AACrB,aAAO,YAAY,KAAK;AAAA,IAC1B;AAAA,EACF;AAEA,QAAM,wBAAwB,CAAC,UAAmC;AAChE,UAAM,OAAO,QAAQ;AACrB,UAAM,cAAc,aAAa,IAAI,MAAM;AAC3C,QACE,QACC,YAAY,IAAI,MAAM,KAAK,CAAC,cAAc,IAAI,MAAM,KACpD,gBACE,CAAC,MAAM,oBAAqB,iBAAiB,cAAc,MAAM,WAAW,IAC/E;AACA,UAAI,WAAW,CAAC,qBAAqB,MAAM,MAAM,KAAK,kBAAkB,GAAG;AACzE,eAAO,MAAM;AAAA,MACf;AACA,YAAM,QAAQ,SAAS,eAAe,QAAQ,KAAK;AACnD,UAAI,iBAAiB;AACrB,UAAI,SAAS,MAAM;AACjB,cAAM,EAAE,MAAM,MAAM,OAAO,OAAO,IAAI;AACtC,cAAM,YAAYF,SAAO,MAAM,QAAQ,IAAI;AAC3C,YAAI,CAACC,QAAM,SAAS,WAAW,KAAK,GAAG;AACrC,gBAAM,WAAW,wBAAwB,KAAK,QAAQ,yBAAyB,CAAC;AAChF,cAAI,SAAS,SAAS;AACpB,kBAAM,OAAO,KAAK,YAAY,MAAM;AACpC,gBAAI,QAAQ,SAAS,SAAS,GAAG;AAC/B,oBAAM,WAAWD,SAAO,SAAS,QAAQ;AAAA,gBACvC,QAAQ;AAAA,kBACN;AAAA,kBACA,QAAQ;AAAA,gBACV;AAAA,gBACA,OAAO;AAAA,kBACL;AAAA,kBACA,QAAQ;AAAA,gBACV;AAAA,cACF,CAAC;AACD,cAAAE,YAAW,YAAY,QAAQ,EAAE,IAAI,KAAK,CAAC;AAC3C,oBAAM,KAAK,SAAS,MAAM;AAC1B,cAAAA,YAAW,YAAY,QAAQ,UAAU;AAAA,gBACvC,IAAI,IAAI,OAAO,QAAQ;AAAA,gBACvB,QAAQ;AAAA,cACV,CAAC;AAAA,YACH;AAAA,UACF,OAAO;AACL,kBAAM,mBAAmBF,SAAO,SAAS,QAAQA,SAAO,MAAM,QAAQ,KAAK,CAAC;AAC5E,YAAAE,YAAW,OAAO,QAAQ;AAAA,cACxB,IAAI;AAAA,cACJ,MAAM;AAAA,cACN,SAAS;AAAA,YACX,CAAC;AACD,kBAAM,cAAc,iBAAiB,MAAM;AAC3C,YAAAA,YAAW,OAAO,QAAQ,eAAe,KAAK;AAC9C,YAAAA,YAAW,eAAe,QAAQ,QAAQ;AAC1C,kBAAM,QAAQ,OAAO,WAAW;AAChC,gBAAI,eAAe,OAAO;AACxB,kBAAI,SAAS,YAAY;AACzB,oBAAM,gBAAgBF,SAAO,MAAM,QAAQ;AAAA,gBACzC,IAAI;AAAA,gBACJ,OAAO,UAAQG,SAAQ,UAAU,IAAI;AAAA,gBACrC,OAAO;AAAA,cACT,CAAC;AAED,oBAAM,WAAWC,MAAK,KAAK,OAAO,IAAI;AAEtC,kBAAI,iBAAiBJ,SAAO,QAAQ,QAAQ,QAAQ,GAAG;AACrD,sBAAM,YAAYA,SAAO,MAAM,QAAQ,QAAQ;AAC/C,sBAAM,UAAUA,SAAO,MAAM,QAAQ;AAAA,kBACnC,IAAI;AAAA,kBACJ,OAAO,UAAQG,SAAQ,UAAU,IAAI;AAAA,kBACrC,OAAO;AAAA,gBACT,CAAC;AACD,oBAAI,WAAW,cAAc,OAAO,QAAQ,IAAI;AAC9C,2BAAS,UAAU;AAAA,gBACrB;AAAA,cACF;AACA,cAAAD,YAAW,OAAO,QAAQ;AAAA,gBACxB;AAAA,gBACA;AAAA,cACF,CAAC;AAAA,YACH;AAAA,UACF;AAEA,sBAAY,UAAU;AAAA,QACxB,OAAO;AACL,UAAAA,YAAW,OAAO,QAAQ,KAAK;AAAA,QACjC;AAAA,MACF,OAAO;AACL,cAAM,EAAE,UAAU,IAAI;AACtB,YACE,YAAY,IAAI,MAAM,KACtB,SACA,aACA,6BAA6B,QAAQ,WAAW,KAAK,GACrD;AACA,2BAAiB;AAAA,QACnB,OAAO;AAEL,2BACE,gBAAgB,OAAO,CAAC,cAAc,SAAS,CAAC,qBAAqB,MAAM,MAAM,CAAC,MAClF;AAAA,QACJ;AAAA,MACF;AAEA,UAAI,YAAY,IAAI,MAAM,KAAK,CAAC,cAAc,IAAI,MAAM,GAAG;AAEzD,YAAI;AAAgB,iBAAO,aAAa;AAAA;AACnC,iBAAO,cAAc;AAAA,MAC5B;AACA,cAAQ,IAAI;AACZ,UAAI,CAAC,YAAY,YAAY,CAAC,YAAY,IAAI,MAAM,KAAK,CAAC;AACxD,eAAO,YAAY;AAAA,IACvB;AAEA,kBAAc,UAAU;AACxB,kBAAc,UAAU;AACxB,mBAAe,IAAI,QAAQ,KAAK;AAChC,gBAAY,IAAI,QAAQ,KAAK;AAC7B,iBAAa,IAAI,QAAQ,KAAK;AAAA,EAChC;AAEA,QAAM,0BAA0B,CAAC,UAAmC;AAClE,UAAM,OAAO,QAAQ;AACrB,UAAM,cAAc,aAAa,IAAI,MAAM;AAE3C,QAAI,YAAY,IAAI,MAAM,KAAK,CAAC,cAAc,IAAI,MAAM,GAAG;AACzD,0BAAoB;AACpB;AAAA,IACF;AACA,UAAM,gBAAgB,aAAa,KAAK;AACxC,mBAAe,IAAI,QAAQ,aAAa;AAExC,QACE,CAAC,iBACD,CAAC,SACC,aAAa,KAAK,KAAK,MAAM,WAAW,KACxC,CAAC,eACD,MAAM,oBACN,cAAc;AAEhB;AACF,UAAM,QAAQ,MAAM,mBAAmB,OAAO,SAAS,eAAe,QAAQ,KAAK;AACnF,QAAI,SAAS,YAAY,aAAa,KAAK,GAAG;AAC5C,cAAQ;AAAA,QACN,IAAI;AAAA,UACF,QAAQ;AAAA,UACR,OAAO;AAAA,QACT;AAAA,QACA,UAAU;AAAA,UACR,GAAG,MAAM;AAAA,UACT,GAAG,MAAM;AAAA,QACX;AAAA,MACF,CAAC;AACD;AAAA,IACF;AAEA,QAAI;AAAe,YAAM,eAAe;AACxC,UAAM,QAAQ,gBAAgB,KAAK;AACnC,QAAI;AAAO,aAAO,YAAY;AAAA,EAChC;AAEA,QAAM,uBAAuB,CAAC,UAA4B;AACxD,QAAI,MAAM;AAAkB;AAC5B,QACE,CAAC,MAAM,UACP,CAAC,IAAI,SAAS,SAAS,MAAM,MAAiB,KAC9C,qBAAqB,MAAM,MAAM,KACjC,qBAAqB,MAAM,MAAM;AAEjC;AAEF,UAAM,EAAE,UAAU,IAAI;AAEtB,gBAAY,IAAI,QAAQ,IAAI;AAC5B,kBAAc,IAAI,QAAQ,KAAK;AAC/B,wBAAoB;AAEpB,mBAAe,UAAU,WAAW,MAAM;AACxC,oBAAc,IAAI,QAAQ,IAAI;AAE9B,UAAI,QAAQ,GAAG,MAAM,GAAG;AACtB,4BAAoB,KAAK;AAAA,MAC3B,WAAW,CAAC,aAAaD,QAAM,YAAY,SAAS,GAAG;AACrD,oBAAY,IAAI,QAAQ,KAAK;AAC7B,cAAM,QAAQ,SAAS,eAAe,QAAQ,KAAK;AACnD,YAAI;AACF,iBAAO,WAAW;AAAA,YAChB,IAAI;AAAA,cACF,QAAQ;AAAA,cACR,OAAO;AAAA,YACT;AAAA,UACF,CAAC;AAAA,MACL;AAAA,IACF,GAAG,GAAG;AAAA,EACR;AAEA,QAAM,sBAAsB,CAAC,MAA2C;AACtE,UAAM,QAAQ,eAAe,CAAC;AAC9B,QAAI,EAAE,oBAAoB,aAAa,KAAK,KAAK,MAAM,WAAW;AAAG;AACrE,QACE,CAAC,MAAM,UACP,CAAC,IAAI,SAAS,SAAS,MAAM,MAAiB,KAC9C,qBAAqB,MAAM,MAAM,KACjC,qBAAqB,MAAM,MAAM;AAEjC;AAEF,iBAAa,IAAI,QAAQ,IAAI;AAC7B,QAAI,iBAAiB,SAAS;AAC5B,UAAI,YAAY,KAAK,GAAG;AACtB;AAAA,MACF,OAAO;AACL,yBAAiB,UAAU;AAAA,MAC7B;AAAA,IACF;AACA,eAAW,IAAI;AACf,UAAM,QAAQ,SAAS,eAAe,QAAQ,KAAK;AACnD,QAAI,OAAO;AACT,YAAM,UAAU,iBAAiB,IAAI,MAAM;AAC3C,UAAI,CAAC,SAAS;AACZ,cAAM,EAAE,UAAU,IAAI;AACtB,YAAI,iBAAiB,cAAc,MAAM,WAAW,GAAG;AACrD,wBAAc,UAAU;AAAA,QAC1B,WAGE,aACA,WACA,6BAA6B,QAAQ,WAAW,OAAO,aAAa,GACpE;AAEA,cAAI,CAAC,eAAe;AAClB,kBAAM,eAAe,IAAI,aAAa;AACtC,4BAAgB,cAAc;AAAA,cAC5B,UAAU,OAAO,YAAY,SAAS;AAAA,YACxC,CAAC;AACD,oBAAQ;AAAA,cACN,MAAM;AAAA,cACN,MAAM;AAAA,cACN,UAAU;AAAA,gBACR,GAAG,MAAM;AAAA,gBACT,GAAG,MAAM;AAAA,cACX;AAAA,YACF,CAAC;AACD,mBAAO,cAAc;AAAA,UACvB;AACA;AAAA,QACF;AACA,sBAAc,UAAU;AAAA,MAC1B;AACA,YAAM,QAAQ;AAAA,QACZ;AAAA,QACA,CAAC,cAAc;AAAA,QACf,CAAC,qBAAqB,MAAM,MAAM;AAAA,MACpC;AACA,UAAI;AAAO,eAAO,cAAc;AAAA,IAClC;AAAO,oBAAc,UAAU;AAAA,EACjC;AAEA,QAAM,oBAAoB,MAAM;AAC9B,kBAAc,UAAU;AAAA,EAC1B;AAEA,QAAM,mBAAyB,eAAO,KAAK;AAC3C,QAAM,wBAA8B,eAAe;AACnD,QAAM,EAAE,qBAAqB,YAAY,IAAI,iBAAiB;AAAA,IAC5D,SAAS,MAAM;AACb,uBAAiB,UAAU;AAAA,IAC7B;AAAA,IACA,iBAAiB,CAAC,OAAO,UAAU;AACjC,YAAM,EAAE,UAAU,IAAI;AACtB,UAAI,CAAC,aAAa,MAAM;AAAkB;AAC1C,YAAM,eAAe;AACrB,YAAM,YAAY,SAAS,UAAU,QAAQ,MAAM;AACnD,UAAII,WAAU,MAAM,MAAM,KAAK,CAAC,UAAU,SAAS,MAAM,MAAM;AAAG;AAClE,YAAM,cAAcJ,QAAM,YAAY,SAAS;AAC/C,UAAI,UAAU,KAAK,CAAC,aAAa;AAC/B,eAAO;AAAA,MACT,WAAW,UAAU,GAAG;AACtB,eAAO,WAAW;AAClB,yBAAiB,UAAU;AAC3B,YAAI,sBAAsB;AAAS,uBAAa,sBAAsB,OAAO;AAC7E,8BAAsB,UAAU,WAAW,MAAM;AAC/C,2BAAiB,UAAU;AAAA,QAC7B,GAAG,GAAG;AACN;AAAA,MACF,WAAW,UAAU,GAAG;AACtB,eAAO,WAAW;AAClB,yBAAiB,UAAU;AAC3B,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF,CAAC;AAED,QAAM,CAAC,6BAA6B,8BAA8B,IAAU;AAAA,IAC1E,OAAO;AAAA,EACT;AAEA,4BAA0B,MAAM;AAC9B,UAAM,eAAe,MAAM;AACzB,YAAM,EAAE,UAAU,IAAI;AACtB,qCAA+B,YAAY,OAAO,OAAO,CAAC,GAAG,SAAS,IAAI,IAAI;AAAA,IAChF;AACA,WAAO,GAAG,UAAU,YAAY;AAEhC,UAAM,cAAc,CAAC,UAAyB;AAC5C,UAAI,MAAM,IAAI,YAAY,MAAM,SAAS;AACvC,yBAAiB,IAAI,QAAQ,KAAK;AAAA,MACpC;AAAA,IACF;AAEA,QAAIK,UAAwB;AAC5B,QAAI,IAAI,YAAYA,UAAS,eAAe,IAAI,OAAO,IAAI;AACzD,uBAAiB,IAAI,QAAQA,OAAM;AACnC,wBAAkB,IAAI,QAAQ,IAAI,OAAO;AACzC,sBAAgB,IAAI,QAAQ,IAAI,OAAO;AACvC,sBAAgB,IAAI,IAAI,SAAS,MAAM;AACvC,kBAAY,IAAI;AAEhB,MAAAA,QAAO,iBAAiB,SAAS,WAAW;AAC5C,MAAAA,QAAO,iBAAiB,aAAa,uBAAuB;AAC5D,MAAAA,QAAO,iBAAiB,WAAW,qBAAqB;AACxD,UAAI,eAAe;AACjB,QAAAA,QAAO,iBAAiB,YAAY,sBAAsB;AAC1D,QAAAA,QAAO,iBAAiB,aAAa,yBAAyB,EAAE,SAAS,MAAM,CAAC;AAAA,MAClF,OAAO;AACL,QAAAA,QAAO,iBAAiB,aAAa,uBAAuB;AAAA,MAC9D;AAAA,IACF,OAAO;AACL,sBAAgB,OAAO,MAAM;AAAA,IAC/B;AAEA,WAAO,MAAM;AACX,aAAO,IAAI,UAAU,YAAY;AACjC,MAAAA,SAAQ,oBAAoB,SAAS,WAAW;AAChD,MAAAA,SAAQ,oBAAoB,aAAa,uBAAuB;AAChE,MAAAA,SAAQ,oBAAoB,WAAW,qBAAqB;AAC5D,UAAI,eAAe;AACjB,QAAAA,SAAQ,oBAAoB,YAAY,sBAAsB;AAC9D,QAAAA,SAAQ,oBAAoB,aAAa,uBAAuB;AAAA,MAClE,OAAO;AACL,QAAAA,SAAQ,oBAAoB,aAAa,uBAAuB;AAAA,MAClE;AAAA,IACF;AAAA,EACF,GAAG,CAAC,QAAQ,yBAAyB,yBAAyB,qBAAqB,CAAC;AAEpF,EAAM,kBAAU,MAAM;AAEpB,QAAI,YAAY,SAAS;AACvB,aAAO,YAAY;AACnB,kBAAY,UAAU;AAAA,IACxB;AAAA,EACF,GAAG,CAAC,6BAA6B,MAAM,CAAC;AAExC,4BAA0B,MAAM;AAC9B,qBAAiB,aAAa,QAAQ,2BAA2B;AAAA,EACnE,GAAG,CAAC,2BAA2B,CAAC;AAGhC,QAAM,iBAAiB,CAAC,UAA2B;AACjD,UAAM,eAAe;AACrB,QAAI;AAAU;AACd,UAAM,QAAQ,SAAS,eAAe,QAAQ,KAAK;AACnD,QAAI,OAAO;AACT,YAAM,YAAY;AAAA,QAChB,QAAQ;AAAA,QACR,OAAO;AAAA,MACT;AACA,YAAM,WAAW;AAAA,QACf,GAAG,MAAM;AAAA,QACT,GAAG,MAAM;AAAA,MACX;AACA,UAAI,CAAC,UAAU;AACb,gBAAQ;AAAA,UACN,MAAM;AAAA,UACN,MAAM;AAAA,UACN,MAAM,MAAM;AAAA,QACd,CAAC;AAAA,MACH;AACA,cAAQ;AAAA,QACN;AAAA,QACA,IAAI;AAAA,MACN,CAAC;AAAA,IACH;AAAA,EACF;AAEA,QAAM,aAAa,CAAC,UAA2B;AAC7C,UAAM,eAAe;AACrB,UAAM,gBAAgB;AACtB,YAAQ,IAAI;AACZ,QAAI;AAAU;AACd,UAAM,QAAQ,SAAS,eAAe,QAAQ,KAAK;AACnD,QAAI,OAAO;AACT,MAAAJ,YAAW,OAAO,QAAQ,KAAK;AAC/B,YAAM,iBAAiB,IAAI,eAAe,SAAS,EAAE,eAAe,MAAM,aAAa,CAAC;AACxF,aAAO,QAAQ,cAAc;AAAA,IAC/B;AAAA,EACF;AAEA,QAAM,oBAAoB,CAAC,UAA4B;AACrD,QAAI,CAAC;AAAe,aAAO,cAAc,MAAM,WAAW;AAAA,EAC5D;AAEA,QAAM,SAAe,gBAAQ,MAAM;AACjC,QAAI,YAAY,QAAQ;AACtB,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT,GAAG,CAAC,QAAQ,QAAQ,CAAC;AAErB,QAAM,oBAAoB,eAAe,MAAM;AAE/C,QAAM,8BAAoC;AAAA,IACxC,CAAC,UAA4B;AAC3B,YAAM,gBAAgB;AACtB,YAAM,EAAE,UAAU,IAAI;AACtB,UAAI,CAAC;AAAW;AAChB,oBAAc,UAAUD,QAAM,IAAI,SAAS;AAC3C,mBAAa,IAAI,QAAQ,IAAI;AAC7B,aAAO,cAAc;AAAA,IACvB;AAAA,IACA,CAAC,MAAM;AAAA,EACT;AAEA,QAAM,6BAAmC;AAAA,IACvC,CAAC,UAA4B;AAC3B,YAAM,gBAAgB;AACtB,YAAM,EAAE,UAAU,IAAI;AACtB,UAAI,CAAC;AAAW;AAChB,oBAAc,UAAUA,QAAM,MAAM,SAAS;AAC7C,mBAAa,IAAI,QAAQ,IAAI;AAC7B,aAAO,cAAc;AAAA,IACvB;AAAA,IACA,CAAC,MAAM;AAAA,EACT;AAEA,SACE,gBAAAF;AAAA,IAAC;AAAA;AAAA,MACC,OAAO;AAAA,QACL,GAAG;AAAA,QACH,UAAU;AAAA,MACZ;AAAA,MAEA;AAAA,wBAAAD;AAAA,UAAC;AAAA;AAAA,YACC,MAAM,WAAW,SAAY;AAAA,YAC5B,GAAG;AAAA,YACH,GAAG,EAAE,CAAC,qBAAqB,SAAS;AAAA,YACrC,QAAQ;AAAA,YACR;AAAA,YACA,OAAO;AAAA,cAEL,SAAS;AAAA,cAET,YAAY;AAAA,cAEZ,WAAW;AAAA,cAEX,YAAY;AAAA,cAEZ;AAAA,cAEA,cAAc;AAAA,YAChB;AAAA,YACA,cAAc,gBAAgB,uBAAuB;AAAA,YACrD,aAAa,gBAAgB,SAAY;AAAA,YACzC,WAAW;AAAA,YACX,SAAS;AAAA,YACT,YAAY;AAAA,YACZ,QAAQ;AAAA,YACR,eAAe;AAAA,YAEf,0BAAAA,MAAC,YAAS,mBAAsC;AAAA;AAAA,QAClD;AAAA,QACA,gBAAAC,MAAC,kBAAgB,KAAK,aAAW,iBAAiB,IAAI,QAAQ,OAAO,GACnE;AAAA,0BAAAD,MAAC,kBAAe;AAAA,UAChB,gBAAAA,MAAC,sBAAmB;AAAA,UACpB,gBAAAA,MAAC,sBAAmB;AAAA,UACpB,gBAAAA,MAAC,kBAAe,WAAsB;AAAA,WACxC;AAAA,QACA,gBAAAA;AAAA,UAAC;AAAA;AAAA,YACC,oBAAoB;AAAA,YACpB,mBAAmB;AAAA;AAAA,QACrB;AAAA,QACC,YAAY,gBAAAA,MAAC,SAAM;AAAA;AAAA;AAAA,EACtB;AAEJ;AAEA,IAAM,+BAA+B,CACnC,QACA,WACA,OACA,qBAAqB,UAClB;AACH,SACGG,QAAM,SAAS,WAAW,KAAK,MAC5B,CAACM,OAAM,OAAON,QAAM,IAAI,SAAS,GAAG,KAAK,KACzC,CAACM,OAAM,OAAON,QAAM,MAAM,SAAS,GAAG,KAAK,KAC1CA,QAAM,YAAY,SAAS,KAC1B,CAAC,CAACD,SAAO,MAAM,QAAQ,EAAE,OAAO,OAAKA,SAAO,OAAO,QAAQ,CAAC,EAAE,CAAC,MACpE,sBACCC,QAAM,YAAY,SAAS,KAC3BM,OAAM,OAAON,QAAM,MAAM,SAAS,GAAG,KAAK;AAEhD;;;AuC/qBA,YAAYO,aAAW;AACvB,SAAqB,QAAAC,OAAM,UAAAC,UAAQ,YAAAC,iBAAgB;AACnD,OAAOC,aAAyC;AA6D5C,gBAAAC,aAAA;AAxDJ,IAAM,oBAAoB,oBAAI,QAA0D;AAEjF,IAAM,mBAAmB,CAAC,UAK3B;AACJ,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA,QAAQ,CAAC,EAAE,MAAM,aAAa,UAAU,CAAC,EAAE,MAAM,GAAG,CAAC,EAAE,CAAC;AAAA,IACxD;AAAA,OACG;AAAA,EACL,IAAI;AAEJ,QAAM,QAAc,gBAAQ,MAAM;AAChC,UAAMC,SAAQ,kBAAkB,IAAI,MAAM;AAC1C,QAAIA,QAAO;AACT,aAAOA;AAAA,IACT;AACA,QAAI,CAACC,MAAK,WAAW,KAAK,GAAG;AAC3B,YAAM,IAAI;AAAA,QACR,oEACcC,UAAS,UAAU,KAAK;AAAA,MACxC;AAAA,IACF;AACA,QAAI,CAACC,SAAO,SAAS,MAAM,GAAG;AAC5B,YAAM,IAAI,MAAM,4CAAiDD,UAAS,UAAU,MAAM,GAAG;AAAA,IAC/F;AACA,WAAO,WAAW;AAClB,WAAO,OAAO,QAAQ,IAAI;AAC1B,UAAM,WAAWE,QAAsB,OAAO;AAAA,MAC5C,QAAQ,CAAC,MAAM;AAAA,IACjB,EAAE;AACF,sBAAkB,IAAI,QAAQ,QAAQ;AACtC,WAAO,cAAc,CAAC,QAAQ,CAAC,CAAC,CAAC;AACjC,WAAO;AAAA,EACT,GAAG,CAAC,QAAQ,OAAO,IAAI,CAAC;AAExB,4BAA0B,MAAM;AAC9B,UAAM,eAAe,MAAM;AACzB,UAAI,UAAU;AACZ,iBAAS,OAAO,QAAQ;AAAA,MAC1B;AACA,YAAM,SAAS;AAAA,QACb,QAAQ,CAAC,MAAM;AAAA,MACjB,CAAC;AAAA,IACH;AACA,WAAO,GAAG,UAAU,YAAY;AAChC,WAAO,MAAM;AACX,aAAO,IAAI,UAAU,YAAY;AAAA,IACnC;AAAA,EACF,GAAG,CAAC,QAAQ,QAAQ,CAAC;AAErB,SACE,gBAAAL;AAAA,IAAC,qBAAqB;AAAA,IAArB;AAAA,MACC,OAAO;AAAA,QACL;AAAA,QACA;AAAA,MACF;AAAA,MAEC;AAAA;AAAA,EACH;AAEJ;;;ACxEA,YAAYM,aAAW;AACvB,SAAS,QAAAC,OAAM,YAA2B;AAO1C,IAAM,mBAAmB,MAAM;AAC7B,QAAM,SAAS,kBAAkB;AACjC,QAAM,OAAO,QAAQ;AAErB,QAAM,CAAC,WAAW,YAAY,IAAU,iBAA+B,IAAI;AAC3E,QAAM,cAAc,eAAe;AAEnC,4BAA0B,MAAM;AAC9B,QAAI,QAAQ,aAAa;AACvB,YAAMC,aAAY,KAAK,aAAa,QAAQ,CAAC,MAAM,SAAS,SAAS,QAAQ,IAAI,CAAC,CAAC;AACnF,UAAIA,YAAW;AACb,qBAAa,UAAQ;AACnB,cACE,CAAC,QACD,CAACC,MAAK,OAAO,KAAK,OAAOD,WAAU,KAAK,KACxC,CAACC,MAAK,OAAO,KAAK,KAAKD,WAAU,GAAG,GACpC;AACA,kBAAM,OAAO,SAAS,SAAS,QAAQ,IAAI;AAC3C,kBAAM,YAAY,KAAK,OAAOA,WAAU,KAAK;AAC7C,kBAAM,UAAU,KAAK,OAAOA,WAAU,GAAG;AACzC,kBAAM,gBAAgB,KAAK,MAAM,QAAQ,CAAC,MAAM,IAAI,GAAGA,UAAS;AAChE,kBAAM,EAAE,OAAO,YAAY,KAAK,SAAS,IAAI,KAAK;AAAA,cAChD;AAAA,cACA,CAAC,MAAM,IAAI;AAAA,cACX;AAAA,YACF;AACA,kBAAM,WAAW,KAAK,OAAO,UAAU;AACvC,kBAAM,SAAS,KAAK,OAAO,QAAQ;AAEnC,gBAAI,CAACC,MAAK,OAAO,WAAW,QAAQ,KAAK,CAACA,MAAK,OAAO,SAAS,MAAM,GAAG;AACtE,mBAAK,OAAO,QAAQ,CAAC,MAAM,IAAI,GAAG,aAAa;AAC/C,qBAAO;AAAA,YACT;AACA,mBAAOD;AAAA,UACT;AACA,iBAAO;AAAA,QACT,CAAC;AACD;AAAA,MACF;AAAA,IACF;AACA,iBAAa,IAAI;AAAA,EAEnB,GAAG,CAAC,QAAQ,OAAO,WAAW,WAAW,CAAC;AAE1C,SAAO;AACT;;;ACrDA,YAAYE,aAAW;AACvB,SAAS,YAAAC,WAAU,QAAAC,aAAY;AAO/B,IAAM,uBAAuB,MAAM;AACjC,QAAM,SAAS,kBAAkB;AAEjC,QAAM,OAAO,QAAQ;AAErB,QAAM,YAAY,iBAAiB;AAEnC,QAAM,CAAC,MAAM,OAAO,IAAU,iBAAyB,IAAI;AAE3D,4BAA0B,MAAM;AAC9B,QAAI,CAAC,aAAa,CAAC;AAAM,aAAO,QAAQ,IAAI;AAC5C,UAAM,EAAE,OAAO,IAAI,IAAIC,UAAS,MAAM,SAAS;AAC/C,QAAIA,UAAS,MAAM,OAAO,GAAG;AAAG,aAAO,QAAQ,IAAI;AACnD,UAAM,OAAO,SAAS,SAAS,QAAQ,IAAI;AAC3C,UAAM,YAAYC,MAAK,QAAQ,QAAQ,MAAM,KAAK;AAClD,QAAI,CAAC;AAAW,aAAO,QAAQ,IAAI;AACnC,UAAM,UAAUA,MAAK,QAAQ,QAAQ,MAAM,GAAG;AAC9C,QAAI,CAAC;AAAS,aAAO,QAAQ,IAAI;AACjC,UAAM,UAAU,SAAS,UAAU,QAAQ,UAAU,EAAE;AACvD,UAAM,QAAQ,SAAS,UAAU,QAAQ,QAAQ,EAAE;AACnD,UAAM,UAAU,SAAS,UAAU,QAAQ,IAAI;AAC/C,UAAM,YAAY,QAAQ,sBAAsB;AAChD,UAAM,YAAY,QAAQ,sBAAsB;AAChD,UAAM,UAAU,MAAM,sBAAsB;AAC5C,UAAM,QACJ,QAAQ,OAAO,UAAU,OACrB,UAAU,QAAQ,QAAQ,OAC1B,QAAQ,QAAQ,UAAU;AAChC,UAAM,SAAS,KAAK,IAAI,QAAQ,SAAS,UAAU,KAAK,UAAU,MAAM;AACxE,UAAM,MAAM,UAAU,MAAM,UAAU;AACtC,UAAM,OAAO,KAAK,IAAI,UAAU,OAAO,UAAU,MAAM,QAAQ,OAAO,UAAU,IAAI;AACpF,YAAQ,IAAI,QAAQ,MAAM,KAAK,OAAO,MAAM,CAAC;AAAA,EAC/C,GAAG,CAAC,QAAQ,WAAW,IAAI,CAAC;AAE5B,SAAO;AACT;;;AC3CA,YAAYC,aAAW;AACvB,SAAuB,QAAAC,aAAY;AAMnC,IAAM,kBAAkB;AAAA,EACtB,MAAM,CAAC;AAAA,EACP,MAAM,CAAC;AAAA,EACP,SAAS;AAAA,EACT,SAAS;AAAA,EACT,SAAS;AAAA,EACT,OAAO,CAAC;AAAA,EACR,OAAO;AACT;AAEA,IAAM,kBAAkB,MAAM;AAC5B,QAAM,SAAS,kBAAkB;AAEjC,QAAM,OAAO,QAAQ;AAErB,QAAM,YAAY,iBAAiB;AAEnC,QAAM,WAA+B,gBAAQ,MAAM;AACjD,QAAI,CAAC;AAAM,aAAO;AAClB,UAAM,MAAMC,MAAK,YAAY,QAAQ,SAAS,SAAS,QAAQ,IAAI,GAAG,aAAa,MAAS;AAC5F,WAAO,OAAO;AAAA,EAChB,GAAG,CAAC,QAAQ,WAAW,IAAI,CAAC;AAE5B,SAAO;AACT;;;AC9BA;AAAA,EACE,UAAAC;AAAA,EACA,QAAAC;AAAA,EACA,QAAAC;AAAA,EAEA,cAAAC;AAAA,EACA,SAAAC;AAAA,EACA,SAAAC;AAAA,EACA;AAAA,OAEK;;;ACPP,SAAS,SAAAC,SAAO,UAAAC,gBAAc;AAG9B,IAAM,mBAAmB,CAAC,MAAe,gBAAyB;AAChE,QAAM,UAAU,YAAY,MAAM,YAAY,UAAU;AAExD,SAAO,KAAK,OAAO,UAAU,KAAK,UAAU;AAC9C;AAEA,IAAM,oBAAoB,CAAC,QAAkB,QAAe,WAAkB;AAC5E,QAAM,QAAQ,SAAS,WAAW,QAAQ,MAAM,EAAE,sBAAsB;AACxE,QAAM,QAAQ,SAAS,WAAW,QAAQ,MAAM,EAAE,sBAAsB;AAExE,SAAO,iBAAiB,OAAO,KAAK,KAAK,iBAAiB,OAAO,KAAK;AACxE;AAUO,IAAM,uBAAuB,CAAC,QAAkB,gBAA8B;AACnF,QAAM,sBAAsBC,SAAO,MAAM,QAAQC,QAAM,IAAI,WAAW,CAAC;AACvE,QAAM,YAAY,MAAM,KAAKD,SAAO,UAAU,QAAQ,EAAE,IAAI,YAAY,CAAC,CAAC;AAE1E,MAAI,OAAO;AACX,MAAI,QAAQ,UAAU;AACtB,MAAI,SAAS,KAAK,MAAM,QAAQ,CAAC;AAEjC,MAAI,kBAAkB,QAAQA,SAAO,MAAM,QAAQ,UAAU,KAAK,GAAG,mBAAmB,GAAG;AACzF,WAAOA,SAAO,MAAM,QAAQ,UAAU,OAAO,mBAAmB;AAAA,EAClE;AAEA,MAAI,UAAU,SAAS,GAAG;AACxB,WAAOA,SAAO,MAAM,QAAQ,UAAU,UAAU,SAAS,IAAI,mBAAmB;AAAA,EAClF;AAEA,SAAO,WAAW,UAAU,UAAU,WAAW,MAAM;AACrD,QAAI,kBAAkB,QAAQA,SAAO,MAAM,QAAQ,UAAU,OAAO,GAAG,mBAAmB,GAAG;AAC3F,cAAQ;AAAA,IACV,OAAO;AACL,aAAO;AAAA,IACT;AAEA,aAAS,KAAK,OAAO,OAAO,SAAS,CAAC;AAAA,EACxC;AAEA,SAAOA,SAAO,MAAM,QAAQ,UAAU,QAAQ,mBAAmB;AACnE;;;ACrDO,IAAM,WAAN,MAAc;AAAA,EAAd;AAOL,kBAAyD,CAAC;AAE1D,wBAAmC;AAEnC,uBAAc;AAAA;AAAA,EAVd,OAAO,cAAc,SAAkB,MAA+B;AACpE,WAAO,QAAQ,cAAc,IAAI;AAAA,EACnC;AAAA,EAUA,cAAc,MAA+B;AAC3C,UAAM,aAAa,KAAK,OAAO;AAE/B,QAAI,OAAO,eAAe,YAAY;AACpC,aAAO;AAAA,IACT,WAAW,eAAe,QAAW;AACnC,aAAO,WAAW;AAAA,IACpB;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,aAAqC;AACnC,WAAO,OAAO,KAAK,KAAK,MAAM;AAAA,EAChC;AAAA,EAEA,gBAAgB,OAAqB;AACnC,SAAK,eAAe;AACpB,WAAO;AAAA,EACT;AAAA,EAEA,kBAA0B;AACxB,WAAO,KAAK,gBAAgB,SAAQ;AAAA,EACtC;AAAA,EAEA,KAAK,SAA0B,MAAsB;AACnD,UAAM,UAAU,KAAK,OAAO;AAE5B,QAAI,YAAY;AAAW,aAAO;AAElC,QAAI,OAAO,YAAY,YAAY;AACjC,cAAQ,GAAG,IAAI;AAAA,IACjB,OAAO;AACL,YAAM,MAAM,QAAQ;AACpB,eAAS,IAAI,GAAG,IAAI,KAAK,EAAE;AAAG,gBAAQ,GAAG,GAAG,IAAI;AAAA,IAClD;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,GAAG,MAAuB,UAAoB,UAAU,OAAa;AACnE,QAAI,WAAW,KAAK,OAAO;AAC3B,QAAI,aAAa,QAAW;AAE1B,WAAK,OAAO,QAAQ;AACpB,QAAE,KAAK;AAAA,IACT,OAAO;AACL,UAAI,OAAO,aAAa,YAAY;AAElC,mBAAW,KAAK,OAAO,QAAQ,UAAU,CAAC,UAAU,QAAQ,IAAI,CAAC,UAAU,QAAQ;AAAA,MAErF,WAAW,SAAS;AAClB,iBAAS,QAAQ,QAAQ;AAAA,MAC3B,OAAO;AACL,iBAAS,KAAK,QAAQ;AAAA,MACxB;AAGA,YAAM,WAAW,KAAK,gBAAgB;AACtC,UAAI,WAAW,KAAK,SAAS,SAAS,UAAU;AAG9C,cAAM,IAAI,IAAI;AAAA,UACZ,iDACE,SAAS,SACT,MACA,OAAO,IAAI,IACX;AAAA,QAGJ;AACA,gBAAQ,KAAK,CAAC;AAAA,MAChB;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,IAAI,MAAuB,UAA0B;AACnD,UAAM,OAAO,KAAK,OAAO;AACzB,QAAI,SAAS;AAAW,aAAO;AAE/B,QAAI,SAAS,UAAU;AACrB,UAAI,EAAE,KAAK,gBAAgB;AAAG,aAAK,SAAS,CAAC;AAAA,WACxC;AACH,eAAO,KAAK,OAAO;AAAA,MACrB;AAAA,IACF,WAAW,OAAO,SAAS,YAAY;AACrC,UAAI,WAAW;AAEf,eAAS,IAAI,KAAK,SAAS,GAAG,KAAK,GAAG,KAAK;AACzC,YAAI,KAAK,OAAO,UAAU;AACxB,qBAAW;AACX;AAAA,QACF;AAAA,MACF;AAEA,UAAI,WAAW;AAAG,eAAO;AAEzB,UAAI,aAAa;AAAG,aAAK,MAAM;AAAA,WAC1B;AACH,aAAK,OAAO,UAAU,CAAC;AAAA,MACzB;AAEA,UAAI,KAAK,WAAW;AAAG,aAAK,OAAO,QAAQ,KAAK;AAAA,IAClD;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,KAAK,MAAuB,UAAoB,UAAU,OAAa;AACrE,UAAM,UAAU,IAAI,SAAgB;AAClC,WAAK,IAAI,MAAM,OAAO;AACtB,eAAS,GAAG,IAAI;AAAA,IAClB;AACA,WAAO,KAAK,GAAG,MAAM,SAAS,OAAO;AAAA,EACvC;AACF;AAlIO,IAAM,UAAN;AAAM,QAKJ,sBAA8B;;;ACJvC,IAAM,kBAA8C,oBAAI,QAAQ;AAqBzD,IAAM,eAAe;AAAA,EAC1B,KAAK,CAAC,WAAqB;AACzB,QAAI,QAAQ,gBAAgB,IAAI,MAAM;AACtC,QAAI,CAAC,OAAO;AACV,cAAQ,IAAI,QAAQ;AACpB,sBAAgB,IAAI,QAAQ,KAAK;AAAA,IACnC;AACA,WAAO;AAAA,EACT;AAAA,EACA,IAAI,CACF,QACA,MACA,SACA,UAAU,UACP;AACH,iBAAa,IAAI,MAAM,EAAE,GAAG,MAAM,SAAS,OAAO;AAAA,EACpD;AAAA,EAEA,KAAK,CAAsB,QAAkB,MAAS,YAA6B;AACjF,iBAAa,IAAI,MAAM,EAAE,IAAI,MAAM,OAAO;AAAA,EAC5C;AAAA,EAEA,MAAM,CACJ,QACA,MACA,SACA,UAAU,UACP;AACH,iBAAa,IAAI,MAAM,EAAE,KAAK,MAAM,SAAS,OAAO;AAAA,EACtD;AAAA,EAEA,MAAM,CAAsB,QAAkB,SAAY,SAAsC;AAC9F,iBAAa,IAAI,MAAM,EAAE,KAAK,MAAM,GAAG,IAAI;AAAA,EAC7C;AACF;;;AC1DA,SAAS,mBAAAE,kBAAiB,UAAAC,UAAQ,cAAAC,aAAY,SAAAC,SAAO,QAAAC,aAAY;AAI1D,IAAM,YAAY,CAAmB,WAAc;AACxD,QAAM,IAAI;AAEV,IAAE,UAAU,CAAC,UAAkB;AAC7B,QAAI,CAAC,OAAO;AAAW;AACvB,QAAI,SAAS,YAAY,MAAM,GAAG;AAChC,YAAM,EAAE,WAAW,MAAM,IAAI;AAC7B,UAAI,CAAC,MAAM,IAAI,IAAIC,SAAO,KAAK,QAAQ,SAAS;AAChD,UAAI,OAAO;AAET,cAAM,kBAAmC;AAAA,UACvC,MAAM;AAAA,UACN,GAAG;AAAA,UACH,aAAa;AAAA,YACX,MAAM;AAAA,YACN,QAAQ;AAAA,YACR,SAAS;AAAA,UACX;AAAA,QACF;AACA,QAAAC,YAAW,YAAY,QAAQ,eAAe;AAC9C,UAAE,QAAQ;AAAA,MACZ,WAAWC,MAAK,OAAO,IAAI,GAAG;AAC5B,cAAM,cAAcC,iBAAgB,kBAAkB,IAAI,IAAI,KAAK,cAAc;AACjF,cAAM,SAAS,aAAa,UAAUC,QAAM,MAAM,SAAS,EAAE;AAE7D,QAAAH,YAAW;AAAA,UACT;AAAA,UACA;AAAA,YACE,aAAa;AAAA,cACX,GAAG;AAAA,cACH,MAAM;AAAA,cACN;AAAA,YACF;AAAA,UACF;AAAA,UACA,EAAE,IAAI,KAAK;AAAA,QACb;AACA,cAAM,QAAQ,EAAE,MAAM,QAAQ,SAAS,MAAM,OAAO;AACpD,QAAAA,YAAW,OAAO,QAAQ;AAAA,UACxB,QAAQ;AAAA,UACR,OAAO;AAAA,QACT,CAAC;AAAA,MACH;AAAA,IACF,OAAO;AACL,aAAO,WAAW,KAAK;AAAA,IACzB;AACA,MAAE,KAAK,SAAS,KAAK;AAAA,EACvB;AAEA,IAAE,gBAAgB,WAAS;AACzB,MAAE,KAAK,eAAe,KAAK;AAAA,EAC7B;AAEA,IAAE,qBAAqB,UAAQ;AAC7B,QAAI,OAAO,aAAaG,QAAM,WAAW,OAAO,SAAS,GAAG;AAC1D,MAAAJ,SAAO,eAAe,MAAM;AAAA,IAC9B;AACA,iBAAa,IAAI,QAAQ,IAAI;AAC7B,MAAE,KAAK,oBAAoB,IAAI;AAAA,EACjC;AAEA,IAAE,mBAAmB,CAAC,UAAkB;AACtC,UAAM,EAAE,UAAU,IAAI;AACtB,QAAI,CAAC;AAAW;AAChB,UAAM,CAAC,MAAM,IAAI,IAAIA,SAAO,KAAK,QAAQ,SAAS;AAClD,QAAIE,MAAK,OAAO,IAAI,GAAG;AACrB,YAAM,cAAcC,iBAAgB,kBAAkB,IAAI,IAAI,KAAK,cAAc;AACjF,MAAAF,YAAW;AAAA,QACT;AAAA,QACA;AAAA,UACE,aAAa;AAAA,QACf;AAAA,QACA,EAAE,IAAI,KAAK;AAAA,MACb;AACA,YAAM,QAAQ,EAAE,MAAM,QAAQ,aAAa,UAAU,UAAU,OAAO,OAAO;AAC7E,YAAM,QAAQ,aAAa,UACvB;AAAA,QACE,QAAQ,EAAE,MAAM,QAAQ,EAAE;AAAA,QAC1B,OAAO,EAAE,MAAM,QAAQ,EAAE;AAAA,MAC3B,IACA;AACJ,MAAAA,YAAW,OAAO,QAAQ,KAAK;AAE/B,mBAAa,IAAI,QAAQ,KAAK;AAC9B,MAAAA,YAAW,WAAW,QAAQ,KAAK;AAAA,IACrC;AACA,MAAE,KAAK,kBAAkB,KAAK;AAAA,EAChC;AAEA,SAAO;AACT;;;AC7FA,SAAS,UAAAI,UAAQ,cAAAC,aAAY,QAAAC,OAAM,SAAAC,eAAa;AAChD,OAAOC,mBAAkB;;;ACDzB,SAAS,UAAU,cAAc,mBAAmB;AAOpD,IAAM,UAA6C;AAAA,EACjD,SAAS,CAAC,QAAQ,QAAQ,SAAS,MAAM,aAAa,OAAO;AAAA,EAC7D,WAAW;AAAA,EACX,KAAK;AAAA,EACL,MAAM;AAAA,EACN,OAAO;AAAA,EACP,WAAW;AAAA,EACX,QAAQ;AAAA,EACR,UAAU;AAAA,EACV,cAAc;AAAA,EACd,aAAa;AAAA,EACb,OAAO;AAAA,EACP,kBAAkB;AAAA,EAClB,iBAAiB;AAAA,EACjB,UAAU;AAAA,EACV,YAAY;AAAA,EACZ,gBAAgB;AAAA,EAChB,eAAe;AAAA,EACf,gBAAgB;AAAA,EAChB,eAAe;AAAA,EACf,iBAAiB;AAAA,EACjB,YAAY;AAAA,EACZ,MAAM;AACR;AAEA,IAAM,gBAAmD;AAAA,EACvD,kBAAkB;AAAA,EAClB,iBAAiB;AAAA,EACjB,kBAAkB;AAAA,EAClB,iBAAiB;AAAA,EACjB,eAAe;AAAA,EACf,aAAa;AAAA,EACb,iBAAiB;AAAA,EACjB,eAAe;AAAA,EACf,gBAAgB,CAAC,kBAAkB,QAAQ;AAAA,EAC3C,eAAe,CAAC,eAAe,QAAQ;AAAA,EACvC,oBAAoB;AAAA,EACpB,mBAAmB,CAAC,qBAAqB,QAAQ;AAAA,EACjD,oBAAoB;AAAA,EACpB,mBAAmB;AAAA,EACnB,oBAAoB;AAAA,EACpB,mBAAmB;AAAA,EACnB,MAAM;AAAA,EACN,oBAAoB;AACtB;AAEA,IAAM,kBAAqD;AAAA,EACzD,oBAAoB;AAAA,EACpB,mBAAmB;AAAA,EACnB,MAAM,CAAC,UAAU,cAAc;AACjC;AAMA,IAAMC,WAAS,CAAC,QAAgB;AAC9B,QAAM,UAAU,QAAQ;AACxB,QAAM,QAAQ,cAAc;AAC5B,QAAM,UAAU,gBAAgB;AAChC,QAAM,YAAY,WAAW,YAAY,OAAO;AAChD,QAAM,UAAU,SAAS,YAAY,KAAK;AAC1C,QAAM,YAAY,WAAW,YAAY,OAAO;AAEhD,SAAO,CAAC,UAAyB;AAC/B,QAAI,aAAa,UAAU,KAAK;AAAG,aAAO;AAC1C,QAAI,YAAY,WAAW,QAAQ,KAAK;AAAG,aAAO;AAClD,QAAI,CAAC,YAAY,aAAa,UAAU,KAAK;AAAG,aAAO;AACvD,WAAO;AAAA,EACT;AACF;AAMA,IAAM,UAAU;AAAA,EACd,aAAaA,SAAO,WAAW;AAAA,EAC/B,OAAOA,SAAO,KAAK;AAAA,EACnB,QAAQA,SAAO,MAAM;AAAA,EACrB,SAASA,SAAO,OAAO;AAAA,EACvB,aAAaA,SAAO,WAAW;AAAA,EAC/B,UAAUA,SAAO,QAAQ;AAAA,EACzB,YAAYA,SAAO,UAAU;AAAA,EAC7B,WAAWA,SAAO,SAAS;AAAA,EAC3B,gBAAgBA,SAAO,cAAc;AAAA,EACrC,eAAeA,SAAO,aAAa;AAAA,EACnC,kBAAkBA,SAAO,gBAAgB;AAAA,EACzC,iBAAiBA,SAAO,eAAe;AAAA,EACvC,sBAAsBA,SAAO,oBAAoB;AAAA,EACjD,qBAAqBA,SAAO,mBAAmB;AAAA,EAC/C,sBAAsBA,SAAO,oBAAoB;AAAA,EACjD,qBAAqBA,SAAO,mBAAmB;AAAA,EAC/C,YAAYA,SAAO,UAAU;AAAA,EAC7B,cAAcA,SAAO,YAAY;AAAA,EACjC,kBAAkBA,SAAO,gBAAgB;AAAA,EACzC,iBAAiBA,SAAO,eAAe;AAAA,EACvC,sBAAsBA,SAAO,oBAAoB;AAAA,EACjD,qBAAqBA,SAAO,mBAAmB;AAAA,EAC/C,oBAAoBA,SAAO,kBAAkB;AAAA,EAC7C,mBAAmBA,SAAO,iBAAiB;AAAA,EAC3C,oBAAoBA,SAAO,kBAAkB;AAAA,EAC7C,mBAAmBA,SAAO,iBAAiB;AAAA,EAC3C,iBAAiBA,SAAO,eAAe;AAAA,EACvC,eAAeA,SAAO,aAAa;AAAA,EACnC,mBAAmBA,SAAO,iBAAiB;AAAA,EAC3C,iBAAiBA,SAAO,eAAe;AAAA,EACvC,SAASA,SAAO,OAAO;AAAA,EACvB,QAAQA,SAAO,MAAM;AAAA,EACrB,aAAaA,SAAO,iBAAiB;AAAA,EACrC,cAAcA,SAAO,YAAY;AAAA,EACjC,sBAAsBA,SAAO,oBAAoB;AAAA,EACjD,QAAQA,SAAO,MAAM;AACvB;AAEA,IAAO,kBAAQ;AAUf,SAAS,MACP,MAKA,OACa;AACb,MAAI,OAAO,SAAS,YAAY,MAAM,QAAQ,IAAI,GAAG;AACnD,WAAO,SAAS,MAAM,KAAK;AAAA,EAC7B,WAAW,OAAO,SAAS,YAAY;AACrC,WAAO,KAAK,KAAK;AAAA,EACnB,OAAO;AACL,eAAW,OAAO,MAAM;AACtB,YAAM,QAAQ,KAAK;AACnB,UAAI,MAAM,OAAO,KAAK,GAAG;AACvB,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AACO,IAAM,SAAS;AAAA,EACpB,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,QAAQ,CAAC,KAAa,OAAO,QAAQ;AACnC,QAAI,OAAO,IAAI,YAAY,EAAE,MAAM,GAAG;AACtC,WAAO,KAAK,IAAI,CAAAC,SAAO;AACrB,UAAIA,SAAQ,OAAO;AACjB,eAAO,WAAW,WAAM;AAAA,MAC1B,WAAWA,SAAQ,OAAO;AACxB,eAAO,WAAW,WAAW;AAAA,MAC/B,WAAWA,KAAI,SAAS,GAAG;AACzB,eAAOA,KAAI,UAAU,GAAG,CAAC,EAAE,YAAY,IAAIA,KAAI,UAAU,CAAC,EAAE,YAAY;AAAA,MAC1E;AACA,aAAOA,KAAI,YAAY;AAAA,IACzB,CAAC;AACD,WAAO,KAAK,KAAK,IAAI;AAAA,EACvB;AAAA,EACA;AACF;;;ADrKO,IAAM,cAAc,CAAmB,WAAc;AAC1D,QAAM,IAAI;AAEV,IAAE,YAAY,CAAC,UAAyB;AACtC,MAAE,KAAK,WAAW,KAAK;AACvB,QAAI,MAAM;AAAkB;AAC5B,UAAM,EAAE,UAAU,IAAI;AACtB,UAAM,UAAU,OAAO,SAAS,cAAc,OAAO,UAAU,MAAM,KAAK,KAAK;AAC/E,UAAM,QAAQC,cAAaC,MAAK,OAAO,OAAO,CAAC,MAAM;AAErD,QAAI,gBAAQ,QAAQ,KAAK,GAAG;AAC1B,uBAAiB,IAAI,GAAG,IAAI;AAAA,IAC9B;AAEA,QAAI,gBAAQ,YAAY,KAAK,GAAG;AAC9B,YAAM,eAAe;AACrB,MAAAC,YAAW,OAAO,GAAGC,SAAO,MAAM,GAAG,CAAC,CAAC,CAAC;AACxC;AAAA,IACF;AAEA,QAAI,gBAAQ,MAAM,KAAK,GAAG;AACxB,YAAM,eAAe;AACrB,QAAE,IAAI;AACN;AAAA,IACF;AAEA,QAAI,gBAAQ,OAAO,KAAK,GAAG;AACzB,YAAM,eAAe;AACrB,QAAE,KAAK;AACP;AAAA,IACF;AAEA,QAAI,gBAAQ,QAAQ,KAAK,GAAG;AAC1B,oBAAc,IAAI,GAAG,KAAK;AAC1B;AAAA,IACF;AAEA,QAAI,gBAAQ,YAAY,KAAK,GAAG;AAC9B,oBAAc,IAAI,GAAG,IAAI;AACzB;AAAA,IACF;AAEA,QAAI,gBAAQ,gBAAgB,KAAK,GAAG;AAClC,YAAM,eAAe;AACrB,MAAAD,YAAW,KAAK,GAAG,EAAE,MAAM,QAAQ,CAAC;AACpC;AAAA,IACF;AAEA,QAAI,gBAAQ,iBAAiB,KAAK,GAAG;AACnC,YAAM,eAAe;AACrB,MAAAA,YAAW,KAAK,GAAG,EAAE,MAAM,SAAS,SAAS,KAAK,CAAC;AACnD;AAAA,IACF;AAEA,QAAI,gBAAQ,WAAW,KAAK,GAAG;AAC7B,YAAM,eAAe;AACrB,YAAM,QAAQ,SAAS,sBAAsB,CAAC;AAC9C,UAAI,SAAS;AACX,QAAAA,YAAW,OAAO,QAAQ;AAAA,UACxB,QAAQ,UAAU;AAAA,UAClB,OAAO;AAAA,QACT,CAAC;AACH;AAAA,IACF;AAEA,QAAI,gBAAQ,aAAa,KAAK,GAAG;AAC/B,YAAM,eAAe;AACrB,YAAM,QAAQ,SAAS,kBAAkB,CAAC;AAC1C,UAAI,SAAS;AACX,QAAAA,YAAW,OAAO,QAAQ;AAAA,UACxB,QAAQ,UAAU;AAAA,UAClB,OAAO;AAAA,QACT,CAAC;AACH;AAAA,IACF;AAEA,QAAI,gBAAQ,SAAS,KAAK,GAAG;AAC3B,YAAM,eAAe;AACrB,YAAM,QAAQ,SAAS,sBAAsB,CAAC;AAC9C,UAAI;AAAO,QAAAA,YAAW,OAAO,QAAQ,KAAK;AAC1C;AAAA,IACF;AAEA,QAAI,gBAAQ,WAAW,KAAK,GAAG;AAC7B,YAAM,eAAe;AACrB,YAAM,QAAQ,SAAS,kBAAkB,CAAC;AAC1C,UAAI;AAAO,QAAAA,YAAW,OAAO,QAAQ,KAAK;AAC1C;AAAA,IACF;AAEA,QAAI,gBAAQ,qBAAqB,KAAK,GAAG;AACvC,YAAM,eAAe;AACrB,MAAAA,YAAW,KAAK,GAAG;AAAA,QACjB,MAAM;AAAA,QACN,MAAM;AAAA,QACN,SAAS;AAAA,MACX,CAAC;AACD;AAAA,IACF;AAEA,QAAI,gBAAQ,oBAAoB,KAAK,GAAG;AACtC,YAAM,eAAe;AACrB,MAAAA,YAAW,KAAK,GAAG,EAAE,MAAM,QAAQ,MAAM,QAAQ,CAAC;AAClD;AAAA,IACF;AAEA,QAAI,gBAAQ,mBAAmB,KAAK,GAAG;AACrC,YAAM,eAAe;AAErB,UAAI,aAAaE,QAAM,WAAW,SAAS,GAAG;AAC5C,QAAAF,YAAW,SAAS,QAAQ,EAAE,MAAM,QAAQ,CAAC;AAAA,MAC/C;AACA,UAAI,WAAW;AACb,cAAM,EAAE,MAAM,IAAI;AAClB,cAAM,EAAE,MAAM,UAAU,IAAI;AAC5B,YAAIC,SAAO,QAAQ,QAAQ,OAAO,SAAS,GAAG;AAC5C,UAAAD,YAAW,KAAK,GAAG,EAAE,SAAS,CAAC,MAAM,CAAC;AACtC;AAAA,QACF;AACA,cAAM,EAAE,MAAM,OAAO,IAAI,SAAS,qBAAqB,GAAG,KAAK;AAC/D,YAAI,MAAM;AACR,gBAAM,aAAa,sBAAsB,MAAM,MAAM;AACrD,gBAAM,WAAW,SAAS,gBAAgB,GAAG,WAAW,UAAU;AAClE,UAAAA,YAAW,OAAO,QAAQ,QAAQ;AAClC;AAAA,QACF;AAAA,MACF;AACA,MAAAA,YAAW,KAAK,GAAG,EAAE,MAAM,QAAQ,SAAS,CAAC,MAAM,CAAC;AACpD;AAAA,IACF;AAEA,QAAI,gBAAQ,kBAAkB,KAAK,GAAG;AACpC,YAAM,eAAe;AAErB,UAAI,aAAaE,QAAM,WAAW,SAAS,GAAG;AAC5C,QAAAF,YAAW,SAAS,QAAQ,EAAE,MAAM,QAAQ,CAAC;AAAA,MAC/C;AACA,UAAI,WAAW;AACb,cAAM,EAAE,MAAM,IAAI;AAClB,cAAM,EAAE,MAAM,UAAU,IAAI;AAC5B,YAAIC,SAAO,MAAM,QAAQ,OAAO,SAAS,GAAG;AAC1C,UAAAD,YAAW,KAAK,GAAG,EAAE,SAAS,MAAM,CAAC;AACrC;AAAA,QACF;AACA,cAAM,EAAE,MAAM,OAAO,IAAI,SAAS,qBAAqB,GAAG,KAAK;AAC/D,YAAI,MAAM;AACR,gBAAM,aAAa,qBAAqB,MAAM,MAAM;AACpD,UAAAA,YAAW,OAAO,QAAQ,SAAS,gBAAgB,GAAG,WAAW,UAAU,CAAC;AAC5E;AAAA,QACF;AAAA,MACF;AACA,MAAAA,YAAW,KAAK,GAAG,EAAE,MAAM,QAAQ,SAAS,MAAM,CAAC;AACnD;AAAA,IACF;AAEA,QAAI,gBAAQ,eAAe,KAAK,GAAG;AACjC,YAAM,eAAe;AAErB,UAAI,aAAaE,QAAM,YAAY,SAAS,GAAG;AAC7C,QAAAF,YAAW,KAAK,GAAG,EAAE,SAAS,CAAC,MAAM,CAAC;AAAA,MACxC,OAAO;AACL,QAAAA,YAAW,SAAS,QAAQ,EAAE,MAAM,QAAQ,CAAC;AAAA,MAC/C;AAEA;AAAA,IACF;AAEA,QAAI,gBAAQ,cAAc,KAAK,GAAG;AAChC,YAAM,eAAe;AAErB,UAAI,aAAaE,QAAM,YAAY,SAAS,GAAG;AAC7C,QAAAF,YAAW,KAAK,GAAG,EAAE,SAAS,MAAM,CAAC;AAAA,MACvC,OAAO;AACL,QAAAA,YAAW,SAAS,QAAQ,EAAE,MAAM,MAAM,CAAC;AAAA,MAC7C;AAEA;AAAA,IACF;AAEA,QAAI,gBAAQ,gBAAgB,KAAK,GAAG;AAClC,YAAM,eAAe;AAErB,YAAM,QAAQ,SAAS,kBAAkB,CAAC;AAC1C,UAAI,OAAO;AACT,QAAAA,YAAW,OAAO,QAAQ,KAAK;AAAA,MACjC;AAEA;AAAA,IACF;AAEA,QAAI,gBAAQ,cAAc,KAAK,GAAG;AAChC,YAAM,eAAe;AAErB,YAAM,QAAQ,SAAS,kBAAkB,GAAG,EAAE,MAAM,MAAM,CAAC;AAC3D,UAAI,OAAO;AACT,QAAAA,YAAW,OAAO,QAAQ,KAAK;AAAA,MACjC;AAEA;AAAA,IACF;AAEA,QAAI,gBAAQ,kBAAkB,KAAK,GAAG;AACpC,YAAM,eAAe;AAErB,QAAE,MAAM,IAAI;AAEZ;AAAA,IACF;AAEA,QAAI,gBAAQ,gBAAgB,KAAK,GAAG;AAClC,YAAM,eAAe;AAErB,QAAE,MAAM,KAAK;AAEb;AAAA,IACF;AAEA,QAAI,gBAAQ,YAAY,KAAK,GAAG;AAC9B,YAAM,eAAe;AACrB,MAAAC,SAAO,gBAAgB,MAAM;AAC7B;AAAA,IACF;AAEA,QAAI,gBAAQ,aAAa,KAAK,GAAG;AAC/B,YAAM,eAAe;AACrB,MAAAA,SAAO,YAAY,MAAM;AACzB;AAAA,IACF;AAEA,QAAI,gBAAQ,iBAAiB,KAAK,GAAG;AACnC,YAAM,eAAe;AACrB,UAAI,aAAaC,QAAM,WAAW,SAAS,GAAG;AAC5C,QAAAD,SAAO,eAAe,MAAM;AAAA,MAC9B,OAAO;AACL,QAAAA,SAAO,eAAe,MAAM;AAAA,MAC9B;AACA;AAAA,IACF;AAEA,QAAI,gBAAQ,gBAAgB,KAAK,GAAG;AAClC,YAAM,eAAe;AAErB,UAAI,aAAaC,QAAM,WAAW,SAAS,GAAG;AAC5C,QAAAD,SAAO,eAAe,QAAQ,EAAE,WAAW,UAAU,CAAC;AAAA,MACxD,OAAO;AACL,QAAAA,SAAO,cAAc,MAAM;AAAA,MAC7B;AAEA;AAAA,IACF;AAEA,QAAI,gBAAQ,qBAAqB,KAAK,GAAG;AACvC,YAAM,eAAe;AAErB,UAAI,aAAaC,QAAM,WAAW,SAAS,GAAG;AAC5C,QAAAD,SAAO,eAAe,QAAQ,EAAE,WAAW,WAAW,CAAC;AAAA,MACzD,OAAO;AACL,QAAAA,SAAO,eAAe,QAAQ,EAAE,MAAM,OAAO,CAAC;AAAA,MAChD;AAEA;AAAA,IACF;AAEA,QAAI,gBAAQ,oBAAoB,KAAK,GAAG;AACtC,YAAM,eAAe;AAErB,UAAI,aAAaC,QAAM,WAAW,SAAS,GAAG;AAC5C,QAAAD,SAAO,eAAe,QAAQ,EAAE,WAAW,UAAU,CAAC;AAAA,MACxD,OAAO;AACL,QAAAA,SAAO,cAAc,QAAQ,EAAE,MAAM,OAAO,CAAC;AAAA,MAC/C;AAEA;AAAA,IACF;AAEA,QAAI,gBAAQ,qBAAqB,KAAK,GAAG;AACvC,YAAM,eAAe;AAErB,UAAI,aAAaC,QAAM,WAAW,SAAS,GAAG;AAC5C,QAAAD,SAAO,eAAe,QAAQ,EAAE,WAAW,WAAW,CAAC;AAAA,MACzD,OAAO;AACL,QAAAA,SAAO,eAAe,QAAQ,EAAE,MAAM,OAAO,CAAC;AAAA,MAChD;AAEA;AAAA,IACF;AAEA,QAAI,gBAAQ,oBAAoB,KAAK,GAAG;AACtC,YAAM,eAAe;AAErB,UAAI,aAAaC,QAAM,WAAW,SAAS,GAAG;AAC5C,QAAAD,SAAO,eAAe,QAAQ,EAAE,WAAW,UAAU,CAAC;AAAA,MACxD,OAAO;AACL,QAAAA,SAAO,cAAc,QAAQ,EAAE,MAAM,OAAO,CAAC;AAAA,MAC/C;AAEA;AAAA,IACF;AAAA,EACF;AACF;;;AElTA,SAAS,UAAAE,UAAQ,cAAAC,aAAY,QAAAC,cAAkB;AAGxC,IAAM,oBAAoB,CAAmB,WAAc;AAChE,QAAM,IAAI;AAEV,QAAM,EAAE,cAAc,IAAI;AAE1B,IAAE,gBAAgB,WAAS;AACzB,UAAM,CAAC,MAAM,IAAI,IAAI;AACrB,QAAIF,SAAO,QAAQ,GAAG,IAAI,GAAG;AAC3B,YAAM,EAAE,SAAS,WAAW,IAAI;AAChC,UAAI,WAAW;AACf,YAAM,cAAc,CAAC,QAAQ,SAAS;AAEtC,iBAAW,CAAC,OAAO,SAAS,KAAKE,OAAK,SAAS,QAAQ,IAAI,GAAG;AAC5D,YAAIF,SAAO,QAAQ,GAAG,KAAK,GAAG;AAC5B,cAAI,CAAC,YAAY,CAAC,eAAe,MAAM,SAAS,MAAM;AACpD,YAAAC,YAAW,YAAY,QAAQ,EAAE,IAAI,UAAU,CAAC;AAChD;AAAA,UACF,WAAW,aAAa;AACtB,YAAAA,YAAW,SAAS,QAAQ,YAAY,EAAE,IAAI,UAAU,CAAC;AACzD,uBAAW;AAAA,UACb;AAAA,QACF;AAAA,MACF;AACA,UAAI,UAAU;AACZ,QAAAA,YAAW,YAAY,QAAQ,EAAE,IAAI,KAAK,CAAC;AAC3C;AAAA,MACF;AAAA,IACF;AACA,kBAAc,KAAK;AAAA,EACrB;AAEA,SAAO;AACT;;;ACnCA,SAAS,wBAAwB;AACjC,SAAS,UAAAE,UAAQ,cAAAC,aAAY,SAAAC,SAAO,QAAAC,cAAY;AAChD,SAAS,sBAAsB;AAC/B,SAAS,sBAAsB;;;ACD/B,SAAS,oBAAAC,yBAAwB;AAEjC,IAAM,kBAAkB,MAAM;AAC5B,QAAM,YAAY,SAAS,aAAa;AACxC,MAAI,CAAC,WAAW,YAAY;AAC1B,WAAO,WAAY;AAAA,IAAC;AAAA,EACtB;AACA,MAAI,SAA6B;AACjC,MAAI,gBAAgB,SAAS;AAC7B,MAAI,iBAAiB,cAAc,YAAY;AAC7C,oBAAgB,cAAc,WAAW;AAAA,EAC3C;AACA,MAAIA,kBAAiB,aAAa,GAAG;AACnC,aAAS;AAAA,EACX;AACA,QAAM,SAAkB,CAAC;AACzB,WAAS,IAAI,GAAG,IAAI,UAAU,YAAY,KAAK;AAC7C,WAAO,KAAK,UAAU,WAAW,CAAC,CAAC;AAAA,EACrC;AACA,UACE,QAAQ,QAAQ,YAAY,GAC5B;AAAA,IACA,KAAK;AAAA,IACL,KAAK;AACH,aAAO,KAAK;AACZ;AAAA,IAEF;AACE,eAAS;AACT;AAAA,EACJ;AAEA,YAAU,gBAAgB;AAC1B,SAAO,MAAM;AACX,QAAI,UAAU,SAAS,SAAS;AAC9B,gBAAU,gBAAgB;AAAA,IAC5B;AAEA,QAAI,CAAC,UAAU,YAAY;AACzB,aAAO,QAAQ,WAAS;AACtB,kBAAU,SAAS,KAAK;AAAA,MAC1B,CAAC;AAAA,IACH;AACA,QAAI,QAAQ;AACV,aAAO,MAAM;AAAA,IACf;AAAA,EACF;AACF;AAEO,IAAM,6BAA6B,MAAM;AAC9C,SAAO,IAAI,QAA6B,CAAC,SAAS,WAAW;AAC3D,QAAI,WAAuC;AAC3C,QAAI,mBAAwC;AAE5C,QAAI,YAA8B;AAClC,QAAI;AACF,yBAAmB,gBAAgB;AAEnC,kBAAY,SAAS,aAAa;AAElC,iBAAW,SAAS,cAAc,UAAU;AAC5C,eAAS,MAAM,UAAU;AAEzB,eAAS,iBAAiB,SAAS,OAAK;AACtC,UAAE,eAAe;AACjB,UAAE,gBAAgB;AAClB,gBAAQ,EAAE,aAAa;AAAA,MACzB,CAAC;AAED,eAAS,KAAK,YAAY,QAAQ;AAElC,eAAS,MAAM;AAEf,YAAM,aAAa,SAAS,YAAY,OAAO;AAC/C,UAAI,CAAC;AAAY,cAAM,IAAI,MAAM,cAAc;AAAA,IACjD,SAAS,OAAP;AACA,aAAO,KAAK;AAAA,IACd,UAAE;AACA,UAAI,WAAW;AACb,kBAAU,gBAAgB;AAAA,MAC5B;AACA,UAAI;AAAU,iBAAS,KAAK,YAAY,QAAQ;AAChD,UAAI;AAAkB,yBAAiB;AAAA,IACzC;AAAA,EACF,CAAC;AACH;AAEO,IAAM,oBAAoB,YAAY;AAC3C,MAAI,OAAO;AACX,MAAI,OAAO;AACX,MAAI,WAAW;AACf,QAAM,eAAe,IAAI,aAAa;AACtC,MAAI;AACF,UAAM,QAAQ,MAAM,UAAU,UAAU,KAAK;AAC7C,eAAW,QAAQ,OAAO;AACxB,UAAI;AACF,gBAAQ,OAAO,MAAM,KAAK,QAAQ,UAAU,GAAG,KAAK;AAAA,MACtD,QAAE;AAAA,MAAO;AACT,UAAI;AACF,gBAAQ,OAAO,MAAM,KAAK,QAAQ,SAAS,GAAG,KAAK;AAAA,MACrD,QAAE;AAAA,MAAO;AACT,UAAI,CAAC,UAAU;AACb,YAAI;AACF,qBAAW,OAAO,MAAM,KAAK,QAAQ,yBAAyB,GAAG,KAAK;AAAA,QACxE,SAAS,OAAP;AACA,qBAAW,4BAA4B,IAAI;AAAA,QAC7C;AAAA,MACF;AAEA,iBAAW,QAAQ,KAAK,OAAO;AAC7B,YAAI,CAAC,CAAC,2BAA2B,YAAY,SAAS,EAAE,QAAQ,IAAI;AAAG;AACvE,cAAM,OAAO,MAAM,KAAK,QAAQ,IAAI;AACpC,cAAM,OAAO,IAAI,KAAK,CAAC,IAAI,GAAG,UAAU;AAAA,UACtC;AAAA,QACF,CAAC;AACD,qBAAa,MAAM,IAAI,IAAI;AAAA,MAC7B;AAAA,IACF;AAAA,EACF,SAAS,OAAP;AACA,QAAI;AACF,YAAM,OAAO,MAAM,2BAA2B;AAC9C,UAAI;AAAM,eAAO;AAAA,IACnB,SAASC,QAAP;AACA,cAAQ,MAAMA,MAAK;AAAA,IACrB;AAAA,EACF;AACA,eAAa,QAAQ,YAAY,IAAI;AACrC,eAAa,QAAQ,WAAW,IAAI;AACpC,eAAa,QAAQ,2BAA2B,QAAQ;AACxD,SAAO;AACT;AAEO,IAAM,8BAA8B,CAAC,SAAuB;AACjE,SAAO,IAAI,QAAiB,CAAC,SAAS,WAAW;AAC/C,QAAI,OAA2B;AAC/B,QAAI,mBAAwC;AAC5C,QAAI,YAA8B;AAClC,QAAI,QAAsB;AAC1B,QAAI;AACF,yBAAmB,gBAAgB;AAEnC,cAAQ,SAAS,YAAY;AAC7B,kBAAY,SAAS,aAAa;AAElC,aAAO,SAAS,cAAc,MAAM;AACpC,WAAK,MAAM,UAAU;AACrB,WAAK,aAAa;AAClB,WAAK,cAAc;AACnB,WAAK,MAAM,aAAa;AACxB,WAAK,iBAAiB,QAAQ,OAAK;AACjC,UAAE,gBAAgB;AAClB,cAAM,EAAE,cAAc,IAAI;AAC1B,YAAI,eAAe;AACjB,YAAE,eAAe;AACjB,wBAAc,UAAU;AACxB,wBAAc,QAAQ,YAAY,KAAK,QAAQ,UAAU,CAAC;AAC1D,wBAAc,QAAQ,WAAW,KAAK,QAAQ,SAAS,CAAC;AACxD,wBAAc,QAAQ,2BAA2B,KAAK,QAAQ,yBAAyB,CAAC;AACxF,gBAAM,QAAQ,uBAAuB,IAAI;AACzC,qBAAW,QAAQ,OAAO;AACxB,0BAAc,MAAM,IAAI,IAAI;AAAA,UAC9B;AACA,kBAAQ,IAAI;AAAA,QACd,OAAO;AACL,kBAAQ,KAAK;AAAA,QACf;AAAA,MACF,CAAC;AACD,eAAS,KAAK,YAAY,IAAI;AAE9B,YAAM,mBAAmB,IAAI;AAC7B,iBAAW,SAAS,KAAK;AAEzB,YAAM,aAAa,SAAS,YAAY,MAAM;AAC9C,UAAI,CAAC;AAAY,cAAM,IAAI,MAAM,aAAa;AAAA,IAChD,SAAS,OAAP;AACA,aAAO,KAAK;AAAA,IACd,UAAE;AACA,UAAI,WAAW;AACb,YAAI,SAAS,OAAO,UAAU,eAAe,YAAY;AACvD,oBAAU,YAAY,KAAK;AAAA,QAC7B,OAAO;AACL,oBAAU,gBAAgB;AAAA,QAC5B;AAAA,MACF;AACA,UAAI;AAAM,iBAAS,KAAK,YAAY,IAAI;AACxC,UAAI;AAAkB,yBAAiB;AAAA,IACzC;AAAA,EACF,CAAC;AACH;AAEO,IAAM,qBAAqB,CAAC,SAAuB;AACxD,MAAI;AACF,UAAM,QAAQ,uBAAuB,IAAI;AAEzC,cAAU,UAAU,MAAM;AAAA,MACxB,IAAI,cAAc;AAAA,QAChB,CAAC,aAAa,IAAI,KAAK,CAAC,KAAK,QAAQ,UAAU,CAAC,GAAG,EAAE,MAAM,WAAW,CAAC;AAAA,QACvE,CAAC,YAAY,IAAI,KAAK,CAAC,KAAK,QAAQ,SAAS,CAAC,GAAG,EAAE,MAAM,UAAU,CAAC;AAAA,QAIpE,GAAG,MAAM,OAAO,CAAC,KAAK,UAAU,EAAE,GAAG,KAAK,CAAC,KAAK,OAAO,KAAK,IAAI,CAAC,CAAC;AAAA,MACpE,CAAC;AAAA,IACH,CAAC;AAAA,EACH,SAAS,OAAP;AACA,QAAI;AACF,kCAA4B,IAAI;AAAA,IAClC,SAASA,QAAP;AACA,cAAQ,MAAMA,MAAK;AAAA,IACrB;AAAA,EACF;AACF;;;ADtMO,IAAM,mBAAmB,CAAmB,WAAc;AAC/D,QAAM,IAAI;AAEV,IAAE,iBAAiB,WAAS;AAC1B,UAAM,WAAW,EAAE,YAAY,KAAK;AACpC,UAAM,iBAAiB,iBAAiB,QAAQ;AAEhD,UAAM,OAAO,SAAS,IAAI,UAAQ,eAAe,oBAAoB,GAAG,IAAI,CAAC,EAAE,KAAK,IAAI;AAExF,QAAI,OAAO,SAAS,IAAI,UAAQ,eAAe,oBAAoB,GAAG,IAAI,CAAC,EAAE,KAAK,EAAE;AACpF,WAAO,QAAQ,2BAA2B,mBAAmB;AAC7D,WAAO,4CAA4C,0CAA0C;AAC7F,UAAM,eAAe,IAAI,aAAa;AACtC,iBAAa,QAAQ,YAAY,IAAI;AACrC,iBAAa,QAAQ,WAAW,IAAI;AACpC,iBAAa,QAAQ,2BAA2B,cAAc;AAC9D,WAAO;AAAA,EACT;AAEA,IAAE,QAAQ,WAAS;AACjB,QAAI,MAAM;AAAkB;AAC5B,UAAM,EAAE,UAAU,IAAI;AACtB,UAAM,EAAE,cAAc,IAAI;AAC1B,QAAI;AAAe,yBAAmB,aAAa;AACnD,QAAI,WAAW;AACb,UAAIC,QAAM,WAAW,SAAS,GAAG;AAC/B,QAAAC,SAAO,eAAe,CAAC;AAAA,MACzB,OAAO;AACL,cAAM,OAAOC,OAAK,OAAO,GAAG,UAAU,OAAO,IAAI;AACjD,YAAID,SAAO,OAAO,GAAG,IAAI,GAAG;AAC1B,UAAAE,YAAW,OAAO,CAAC;AAAA,QACrB;AAAA,MACF;AAAA,IACF;AACA,MAAE,KAAK,OAAO,KAAK;AAAA,EACrB;AAEA,IAAE,SAAS,WAAS;AAClB,QAAI,MAAM;AAAkB;AAC5B,UAAM,EAAE,cAAc,IAAI;AAC1B,QAAI;AAAe,yBAAmB,aAAa;AACnD,MAAE,KAAK,QAAQ,KAAK;AAAA,EACtB;AAEA,IAAE,UAAU,WAAS;AACnB,QAAI,MAAM;AAAkB;AAC5B,UAAM,EAAE,cAAc,IAAI;AAC1B,QAAI,CAAC;AAAe;AACpB,UAAM,eAAe;AACrB,UAAM,EAAE,MAAM,UAAU,MAAM,MAAM,IAAI,kBAAkB,aAAa;AACvE,UAAM,cAAc,MAAM,SAAS;AACnC,QAAI,CAAC,eAAe,SAAS,SAAS,GAAG;AACvC,QAAE,eAAe,QAAQ;AAAA,IAC3B,WAAW,CAAC,eAAe,MAAM;AAC/B,YAAMC,YAAW,IAAI,UAAU,EAAE,gBAAgB,MAAM,SAAS;AAChE,YAAMC,YAAW,iBAAiB,oBAAoB,GAAGD,UAAS,IAAI;AACtE,QAAE,eAAeC,SAAQ;AAAA,IAC3B,OAAO;AACL,YAAM,QAAQ,KAAK,MAAM,YAAY;AACrC,UAAI,QAAQ;AAEZ,iBAAW,QAAQ,OAAO;AACxB,YAAI,OAAO;AACT,UAAAF,YAAW,WAAW,GAAG,EAAE,QAAQ,KAAK,CAAC;AAAA,QAC3C;AACA,UAAE,mBAAmB,eAAa;AAChC,cAAI,cAAc,EAAE;AAAW,cAAE,YAAY;AAC7C,YAAE,WAAW,IAAI;AAAA,QACnB,CAAC;AACD,gBAAQ;AAAA,MACV;AAAA,IACF;AACA,eAAW,QAAQ,OAAO;AACxB,QAAE,WAAW,IAAI;AAAA,IACnB;AACA,MAAE,KAAK,SAAS,KAAK;AAAA,EACvB;AAEA,IAAE,OAAO,WAAS;AAChB,UAAM,OAAO,EAAE,eAAe,KAAK;AACnC,UAAM,QAAQ,IAAI,eAAe,QAAQ,EAAE,eAAe,KAAK,CAAC;AAChE,MAAE,OAAO,KAAK;AAAA,EAChB;AAEA,IAAE,MAAM,WAAS;AACf,UAAM,OAAO,EAAE,eAAe,KAAK;AACnC,UAAM,QAAQ,IAAI,eAAe,QAAQ,EAAE,eAAe,KAAK,CAAC;AAChE,QAAI,OAAO;AACT,MAAAA,YAAW,OAAO,GAAG,KAAK;AAAA,IAC5B;AACA,MAAE,MAAM,KAAK;AAAA,EACf;AAEA,IAAE,sBAAsB,WAAS;AAC/B,QAAI,OAAO;AACT,MAAAA,YAAW,OAAO,GAAG,KAAK;AAAA,IAC5B;AACA,sBAAkB,EAAE,KAAK,UAAQ;AAC/B,YAAM,QAAQ,IAAI,eAAe,SAAS,EAAE,eAAe,KAAK,CAAC;AACjE,QAAE,QAAQ,KAAK;AAAA,IACjB,CAAC;AAAA,EACH;AAEA,IAAE,0BAA0B,WAAS;AACnC,QAAI,OAAO;AACT,MAAAA,YAAW,OAAO,GAAG,KAAK;AAAA,IAC5B;AACA,sBAAkB,EAAE,KAAK,UAAQ;AAC/B,oBAAc,IAAI,GAAG,IAAI;AACzB,YAAM,QAAQ,IAAI,eAAe,aAAa,EAAE,eAAe,KAAK,CAAC;AACrE,QAAE,QAAQ,KAAK;AAAA,IACjB,CAAC;AAAA,EACH;AAEA,SAAO;AACT;;;ARsNW,gBAAAG,aAAA;AAhTJ,IAAM,eAAe,CAAmB,WAAc;AAC3D,QAAM,IAAI;AAEV,YAAU,CAAC;AAEX,cAAY,CAAC;AAEb,oBAAkB,CAAC;AAEnB,mBAAiB,CAAC;AAElB,QAAM,EAAE,OAAO,UAAU,gBAAgB,cAAc,IAAI;AAI3D,2BAAyB,IAAI,GAAG,oBAAI,QAAQ,CAAC;AAE7C,IAAE,gBAAgB,UAAQ;AACxB,UAAM,EAAE,UAAU,IAAI;AAEtB,QAAI,aAAaC,QAAM,YAAY,SAAS,GAAG;AAC7C,YAAM,CAAC,IAAI,IAAIC,SAAO,MAAM,QAAQ;AAAA,QAClC,OAAO,OAAK,EAAE,WAAW,CAAC;AAAA,MAC5B,CAAC;AAED,UAAI,MAAM;AACR,cAAM,CAAC,EAAE,QAAQ,IAAI;AACrB,cAAM,MAAMA,SAAO,IAAI,QAAQ,QAAQ;AACvC,YAAIC,OAAM,OAAO,UAAU,QAAQ,GAAG,GAAG;AACvC;AAAA,QACF;AAAA,MACF;AAAA,IACF;AACA,kBAAc,IAAI;AAAA,EACpB;AAEA,IAAE,iBAAiB,UAAQ;AACzB,UAAM,EAAE,UAAU,IAAI;AAEtB,QAAI,aAAaF,QAAM,YAAY,SAAS,GAAG;AAC7C,YAAM,CAAC,IAAI,IAAIC,SAAO,MAAM,QAAQ;AAAA,QAClC,OAAO,OAAK,EAAE,WAAW,CAAC;AAAA,MAC5B,CAAC;AAED,UAAI,MAAM;AACR,cAAM,CAAC,EAAE,QAAQ,IAAI;AACrB,cAAM,QAAQA,SAAO,MAAM,QAAQ,QAAQ;AAE3C,YAAIC,OAAM,OAAO,UAAU,QAAQ,KAAK,GAAG;AACzC;AAAA,QACF;AAAA,MACF;AACA,YAAM,OAAO,KAAK,MAAM,CAAC;AACzB,UAAI,QAAQD,SAAO,QAAQ,GAAG,UAAU,OAAO,KAAK,EAAE,GAAG;AACvD,aAAK,WAAW,CAAC;AACjB;AAAA,MACF;AAAA,IACF;AACA,QAAI,SAAS,QAAQ;AACnB,aAAO,eAAe,IAAI;AAAA,IAC5B;AAEA,QAAI,aAAaD,QAAM,YAAY,SAAS,GAAG;AAC7C,YAAM,mBAAmBC,SAAO,MAAM,QAAQ;AAAA,QAC5C,OAAO,OAAKA,SAAO,QAAQ,QAAQ,CAAC;AAAA,QACpC,IAAI;AAAA,MACN,CAAC;AAED,UAAI,kBAAkB;AACpB,cAAM,CAAC,EAAE,eAAe,IAAI;AAC5B,cAAM,qBAAqBA,SAAO,MAAM,QAAQ,iBAAiB,UAAU,MAAM;AAEjF,cAAM,mBAAmB,qBAAqB,GAAG,kBAAkB;AAEnE,YAAI,CAACD,QAAM,YAAY,gBAAgB,GAAG;AACxC,UAAAG,YAAW,OAAO,QAAQ,EAAE,IAAI,iBAAiB,CAAC;AAAA,QACpD;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAIA,IAAE,QAAQ,CAAC,OAAkB;AAC3B,UAAM,UAAyB,CAAC;AAEhC,YAAQ,GAAG,MAAM;AAAA,MACf,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK,cAAc;AACjB,gBAAQ,KAAK,GAAG,WAAW,GAAG,GAAG,IAAI,CAAC;AACtC;AAAA,MACF;AAAA,MAEA,KAAK,iBAAiB;AACpB;AAAA,MACF;AAAA,MAEA,KAAK;AAAA,MACL,KAAK,eAAe;AAClB,gBAAQ,KAAK,GAAG,WAAW,GAAGC,MAAK,OAAO,GAAG,IAAI,CAAC,CAAC;AACnD;AAAA,MACF;AAAA,MAEA,KAAK,cAAc;AACjB,cAAM,WAAWA,MAAK,SAAS,GAAG,IAAI;AACtC,gBAAQ,KAAK,GAAG,WAAW,GAAG,QAAQ,CAAC;AACvC;AAAA,MACF;AAAA,MAEA,KAAK,aAAa;AAChB,cAAM,aAAaA,MAAK,OAAOA,MAAK,OAAO,GAAG,IAAI,GAAGA,MAAK,OAAO,GAAG,OAAO,CAAC;AAC5E,gBAAQ,KAAK,GAAG,WAAW,GAAG,UAAU,CAAC;AACzC;AAAA,MACF;AAAA,IACF;AAEA,UAAM,EAAE;AAER,eAAW,CAAC,MAAM,GAAG,KAAK,SAAS;AACjC,YAAM,CAAC,IAAI,IAAIH,SAAO,KAAK,GAAG,IAAI;AAClC,kBAAY,IAAI,MAAM,GAAG;AAAA,IAC3B;AACA,QAAI,CAAC,SAAS,UAAU,CAAC,KAAK,kBAAkB,GAAG;AACjD,QAAE,MAAM;AAAA,IACV;AAAA,EACF;AAEA,IAAE,KAAK,CAAC,MAAM,SAAS,YAAY;AACjC,iBAAa,GAAG,GAAG,MAAM,SAAS,OAAO;AAAA,EAC3C;AAEA,IAAE,MAAM,CAAC,MAAM,YAAY;AACzB,iBAAa,IAAI,GAAG,MAAM,OAAO;AAAA,EACnC;AAEA,IAAE,OAAO,CAAC,MAAM,SAAS,YAAY;AACnC,iBAAa,GAAG,GAAG,MAAM,SAAS,OAAO;AAAA,EAC3C;AAEA,IAAE,OAAO,CAAC,SAAS,SAAS;AAC1B,iBAAa,KAAK,GAAG,MAAM,GAAG,IAAI;AAAA,EACpC;AAEA,MAAI,gBAA8B;AAClC,MAAI,iBAA8B;AAClC,MAAI,gBAA6B;AAEjC,IAAE,WAAW,MAAM;AACjB,SACI,CAAC,iBAAiB,CAAC,EAAE,cAAc,kBAAkB,EAAE,aACxD,iBACC,EAAE,cACD,CAACD,QAAM,OAAO,eAAe,EAAE,SAAS,KACvC,mBAAmBK,OAAK,IAAI,GAAG,EAAE,UAAU,OAAO,IAAI,KACtD,kBAAkBA,OAAK,IAAI,GAAG,EAAE,UAAU,MAAM,IAAI,IACxD;AACA,QAAE,kBAAkB;AACpB,sBAAgB,EAAE,YAAY,OAAO,OAAO,CAAC,GAAG,EAAE,SAAS,IAAI;AAC/D,uBAAiB,EAAE,YAAYA,OAAK,IAAI,GAAG,EAAE,UAAU,OAAO,IAAI,IAAI;AACtE,sBAAgB,EAAE,YAAYA,OAAK,IAAI,GAAG,EAAE,UAAU,MAAM,IAAI,IAAI;AAAA,IACtE;AACA,gBAAY,QAAQ,CAAC;AACrB,aAAS;AACT,MAAE,KAAK,QAAQ;AAAA,EACjB;AAEA,IAAE,OAAO,MAAY;AACnB,UAAM,SAAS,iBAAiB,IAAI,MAAM;AAC1C,UAAM,WAAW,gBAAgB,IAAI,MAAM;AAC3C,QAAI,YAAY,UAAU,OAAO,kBAAkB,UAAU;AAC3D,eAAS,KAAK;AAAA,IAChB;AAAA,EACF;AAIA,IAAE,QAAQ,CAAC,UAAgB;AACzB,QAAI,CAAC,OAAO,WAAW;AACrB,YAAM,OAAO,SAAS,SAAS,GAAG,CAAC;AACnC,YAAM,QAAQ,QAAQJ,SAAO,MAAM,GAAG,IAAI,IAAIA,SAAO,IAAI,GAAG,IAAI;AAChE,MAAAE,YAAW,OAAO,GAAG,KAAK;AAAA,IAC5B,WAAW,UAAU,MAAM;AACzB,YAAM,OAAO,SAAS,SAAS,GAAG,CAAC;AACnC,MAAAA,YAAW,OAAO,GAAGF,SAAO,MAAM,GAAG,IAAI,CAAC;AAAA,IAC5C,WAAW,UAAU,OAAO;AAC1B,YAAM,OAAO,SAAS,SAAS,GAAG,CAAC;AACnC,MAAAE,YAAW,OAAO,GAAGF,SAAO,IAAI,GAAG,IAAI,CAAC;AAAA,IAC1C;AAEA,UAAM,SAAS,iBAAiB,IAAI,MAAM;AAC1C,UAAM,WAAW,gBAAgB,IAAI,MAAM;AAC3C,QAAI,YAAY,UAAU,OAAO,kBAAkB,UAAU;AAC3D,eAAS,MAAM,EAAE,eAAe,KAAK,CAAC;AAAA,IACxC;AAAA,EACF;AAEA,IAAE,aAAa,CAAC,UAAU,CAAC,MAAM;AAC/B,UAAM,EAAE,IAAI,OAAO,QAAQ,IAAI;AAC/B,QAAI,IAAI;AACN,MAAAE,YAAW,OAAO,GAAG,EAAE;AAAA,IACzB;AACA,UAAM,EAAE,UAAU,IAAI;AACtB,QAAI,CAAC;AAAW;AAChB,UAAM,QAAQ,CAAC,SAAS,KAAK,EAAE,SAAS,IAAI,IAAIH,QAAM,IAAI,SAAS,IAAIA,QAAM,MAAM,SAAS;AAC5F,UAAM,EAAE,MAAM,OAAO,IAAI,SAAS,qBAAqB,GAAG,KAAK;AAC/D,QAAI,MAAM;AACR,YAAM,EAAE,KAAK,IAAI;AACjB,YAAM,CAAC,aAAa,SAAS,IAAI,aAAa,MAAM,MAAM;AAC1D,MAAAG,YAAW,OAAO,GAAG;AAAA,QACnB,QAAQ,SAAS,gBAAgB,GAAG,MAAM,aAAa,IAAI;AAAA,QAC3D,OAAO,SAAS,gBAAgB,GAAG,MAAM,SAAS;AAAA,MACpD,CAAC;AACD,QAAE,YAAY;AAAA,IAChB;AAAA,EACF;AAEA,IAAE,aAAa,CAAC,UAAU,CAAC,MAAM;AAC/B,UAAM,EAAE,IAAI,OAAO,QAAQ,IAAI;AAC/B,QAAI,IAAI;AACN,MAAAA,YAAW,OAAO,GAAG,EAAE;AAAA,IACzB;AACA,UAAM,EAAE,UAAU,IAAI;AACtB,QAAI,CAAC;AAAW;AAChB,UAAM,QAAQ,CAAC,SAAS,KAAK,EAAE,SAAS,IAAI,IAAIH,QAAM,IAAI,SAAS,IAAIA,QAAM,MAAM,SAAS;AAC5F,UAAM,EAAE,KAAK,IAAI;AACjB,UAAM,OAAOK,OAAK,IAAI,GAAG,IAAI;AAC7B,QAAI,WAAW;AACf,QAAI,CAACJ,SAAO,QAAQ,GAAG,IAAI,GAAG;AAC5B,YAAM,QAAQA,SAAO,MAAM,GAAG;AAAA,QAC5B,OAAO,OAAKA,SAAO,QAAQ,GAAG,CAAC;AAAA,QAC/B,IAAI;AAAA,MACN,CAAC;AAED,iBAAW,QAAQ,MAAM,KAAK,MAAM,GAAG,CAAC;AAAA,IAC1C;AAEA,UAAM,QAAQA,SAAO,MAAM,GAAG,QAAQ;AACtC,IAAAE,YAAW,OAAO,GAAG,KAAK;AAC1B,MAAE,YAAY;AAAA,EAChB;AAEA,IAAE,UAAU,CAAC,UAAyB;AACpC,QAAI,MAAM,IAAI,YAAY,MAAM,SAAS;AACvC,uBAAiB,IAAI,QAAQ,KAAK;AAAA,IACpC;AACA,MAAE,KAAK,SAAS,KAAK;AAAA,EACvB;AAEA,IAAE,UAAU,MAAM;AAChB,MAAE,MAAM;AACR,gBAAY,QAAQ,CAAC;AACrB,MAAE,KAAK,OAAO;AAAA,EAChB;AAEA,IAAE,SAAS,MAAM;AACf,gBAAY,QAAQ,CAAC;AACrB,MAAE,KAAK,MAAM;AAAA,EACf;AAEA,IAAE,gBAAgB,MAAM;AACtB,MAAE,KAAK,aAAa;AAAA,EACtB;AAEA,IAAE,cAAc,MAAM;AACpB,MAAE,KAAK,WAAW;AAAA,EACpB;AAEA,IAAE,cAAc,MAAM;AACpB,MAAE,KAAK,WAAW;AAAA,EACpB;AAEA,IAAE,oBAAoB,MAAM;AAC1B,MAAE,KAAK,iBAAiB;AAAA,EAC1B;AAEA,IAAE,cAAc,WAAS;AACvB,MAAE,KAAK,aAAa,KAAK;AAAA,EAC3B;AAEA,IAAE,eAAe,MAAM;AACrB,MAAE,KAAK,YAAY;AAAA,EACrB;AAEA,IAAE,gBAAgB,WAAS;AACzB,MAAE,KAAK,eAAe,KAAK;AAAA,EAC7B;AAEA,IAAE,YAAY,MAAM;AAClB,MAAE,KAAK,SAAS;AAAA,EAClB;AAEA,IAAE,0BAA0B,CAAC,EAAE,WAAW,MAAM;AAC9C,WAAO;AAAA,EACT;AAEA,IAAE,uBAAuB,CAAC,EAAE,WAAW,MAAM;AAC3C,WAAO;AAAA,EACT;AAEA,IAAE,gBAAgB,CAAC,UAA8B;AAC/C,UAAM,EAAE,YAAY,UAAU,QAAQ,IAAI;AAC1C,UAAM,MAAM,EAAE,SAAS,OAAO,IAAI,SAAS;AAC3C,WAAO,gBAAAJ,MAAC,OAAK,GAAG,YAAa,UAAS;AAAA,EACxC;AAEA,IAAE,aAAa,CAAC,UAA2B;AACzC,UAAM,EAAE,YAAY,SAAS,IAAI;AACjC,WAAO,gBAAAA,MAAC,UAAM,GAAG,YAAa,UAAS;AAAA,EACzC;AAEA,IAAE,oBAAoB,CAAC,EAAE,YAAY,SAAS,MAAM;AAClD,WACE,gBAAAA;AAAA,MAAC;AAAA;AAAA,QACC,OAAO;AAAA,UACL,eAAe;AAAA,UACf,YAAY;AAAA,UACZ,OAAO;AAAA,QACT;AAAA,QAEA,0BAAAA;AAAA,UAAC;AAAA;AAAA,YACC,OAAO;AAAA,cACL,UAAU;AAAA,cACV,SAAS;AAAA,cACT,OAAO;AAAA,cACP,YAAY;AAAA,cACZ,YAAY;AAAA,cACZ,cAAc;AAAA,cACd,UAAU;AAAA,cACV,UAAU;AAAA,YACZ;AAAA,YACC,GAAG;AAAA,YAEH;AAAA;AAAA,QACH;AAAA;AAAA,IACF;AAAA,EAEJ;AAEA,QAAM,EAAE,YAAY,IAAI;AAExB,IAAE,cAAc,MAAM;AACpB,UAAM,EAAE,UAAU,IAAI;AAEtB,QAAI,CAAC,SAAS,SAAS,MAAM,KAAK,CAAC,aAAaC,QAAM,WAAW,SAAS,GAAG;AAC3E,kBAAY;AACZ;AAAA,IACF;AACA,UAAM,SAAS,KAAK,MAAM,MAAM;AAChC,QAAI,CAAC,QAAQ;AACX,kBAAY;AACZ;AAAA,IACF;AACA,SAAK,UAAU,MAAM;AAAA,EACvB;AAEA,IAAE,aAAa,CAAC,GAAG,UAAU;AAC3B,QAAI,OAAO;AACT,MAAAG,YAAW,OAAO,GAAG,KAAK;AAAA,IAC5B;AAAA,EACF;AAEA,SAAO;AACT;AAEA,IAAM,aAAa,CAAC,GAAa,SAAe;AAC9C,QAAM,UAAyB,CAAC;AAChC,aAAW,CAAC,GAAG,CAAC,KAAKF,SAAO,OAAO,GAAG,EAAE,IAAI,KAAK,CAAC,GAAG;AACnD,UAAM,MAAM,SAAS,QAAQ,GAAG,CAAC;AACjC,YAAQ,KAAK,CAAC,GAAG,GAAG,CAAC;AAAA,EACvB;AACA,SAAO;AACT;","names":["React","useStore","useStore","match","key","React","Editor","Range","Transforms","Point","Path","Element","isDOMNode","Editor","Range","Element","React","Editor","Node","Range","React","React","Editor","Path","Node","Editor","Node","Element","Path","Range","isDOMElement","React","rects","isDOMElement","rects","match","element","isDOMElement","node","range","lineRect","create","useStore","getStore","create","useStore","isFocused","create","useStore","EDITABLE_TO_FOCUSED_STORE","getStore","create","useStore","isReadOnly","Editor","match","Range","n","window","isDOMElement","node","nodes","Node","textNode","Element","block","Path","path","String","Path","Node","Editor","jsx","jsxs","React","React","useStore","create","useStore","jsx","Text","ranges","key","React","Editor","useStore","Editor","Range","create","create","Editor","Range","useStore","Editor","actives","jsx","Element","Editor","Node","children","Range","React","React","React","jsx","Element","Editor","Range","React","React","React","jsx","root","React","Range","React","useStore","create","Range","getStore","create","Range","useStore","rects","jsx","Range","Range","Fragment","jsx","Range","Range","React","useEffect","jsx","event","Range","rect","React","create","Editor","Element","Path","create","Editor","Path","Element","useStore","React","Editor","Element","Path","jsx","Editor","Element","Path","React","React","useStore","merge","create","getStore","predicate","React","useStore","Fragment","jsx","React","React","Range","Fragment","jsx","jsxs","Range","jsx","jsxs","Editor","Range","Transforms","Element","Path","isDOMNode","window","Point","React","Node","Editor","Scrubber","create","jsx","store","Node","Scrubber","Editor","create","React","Path","selection","Path","React","GridCell","Grid","GridCell","Grid","React","Grid","Grid","Editor","Node","Path","Transforms","Range","Point","Range","Editor","Editor","Range","CompositionText","Editor","Transforms","Range","Text","Editor","Transforms","Text","CompositionText","Range","Editor","Transforms","Node","Range","getDirection","create","key","getDirection","Node","Transforms","Editor","Range","Editor","Transforms","Node","Editor","Transforms","Range","Node","isDOMHTMLElement","error","Range","Editor","Node","Transforms","document","fragment","jsx","Range","Editor","Point","Transforms","Path","Node"]}
\ No newline at end of file
+{"version":3,"sources":["../src/utils/constants.ts","../src/utils/data-transfer.ts","../src/hooks/use-locale.ts","../src/plugin/locale.ts","../src/hooks/use-editable.tsx","../src/components/content.tsx","../src/hooks/use-children.tsx","../src/components/element.tsx","../src/components/text.tsx","../src/components/leaf.tsx","../src/components/string.tsx","../src/plugin/editable.ts","../src/utils/weak-maps.ts","../src/utils/dom.ts","../src/utils/environment.ts","../src/utils/nearby.ts","../src/utils/text.ts","../src/utils/selection.ts","../src/hooks/use-focused.ts","../src/utils/event.ts","../src/hooks/use-read-only.ts","../src/hooks/use-isomorphic-layout-effect.ts","../src/hooks/use-decorate.ts","../src/plugin/decorate.ts","../src/hooks/use-placeholder.ts","../src/plugin/placeholder.ts","../src/hooks/use-node-selected.ts","../src/hooks/use-node-focused.ts","../src/hooks/use-grid.ts","../src/hooks/use-multiple-click.ts","../src/hooks/use-cancellable-promises.ts","../src/components/shadow.tsx","../src/components/caret.tsx","../src/hooks/use-selection-drawing.ts","../src/plugin/selection-drawing.ts","../src/components/selection.tsx","../src/components/input.tsx","../src/hooks/use-drag.ts","../src/plugin/drag.ts","../src/components/drag-caret.tsx","../src/components/slot.tsx","../src/hooks/use-slot.ts","../src/plugin/solt.ts","../src/components/touch-point.tsx","../src/components/editable.tsx","../src/hooks/use-grid-selection.ts","../src/hooks/use-grid-selection-rect.ts","../src/hooks/use-grid-selected.ts","../src/plugin/with-editable.tsx","../src/utils/lines.ts","../src/plugin/emitter.ts","../src/plugin/event.ts","../src/plugin/with-input.ts","../src/plugin/with-keydown.ts","../src/utils/hotkeys.ts","../src/plugin/with-normalize-node.ts","../src/plugin/with-data-transfer.ts","../src/utils/clipboard.ts"],"sourcesContent":["export const APPLICATION_FRAGMENT_TYPE = 'application/x-editable-fragment'\nexport const TEXT_HTML = 'text/html'\nexport const TEXT_PLAIN = 'text/plain'\nexport const DATA_EDITABLE_FRAGMENT = `data-ea-fragment`\nexport const DATA_EDITABLE_NODE = `data-ea-node`\nexport const DATA_EDITABLE_INLINE = `data-ea-inline`\nexport const DATA_EDITABLE_STRING = `data-ea-string`\nexport const DATA_EDITABLE_COMPOSITION = `data-ea-composition`\nexport const DATA_EDITABLE_ZERO_WIDTH = `data-ea-zero-width`\nexport const DATA_EDITABLE_LENGTH = `data-ea-length`\nexport const DATA_EDITABLE_VOID = `data-ea-void`\nexport const DATA_EDITABLE_PLACEHOLDER = `data-ea-placeholder`\nexport const DATA_EDITABLE_LEAF = `data-ea-leaf`\n\nexport const Constants = {\n  applicationType: APPLICATION_FRAGMENT_TYPE,\n  htmlType: TEXT_HTML,\n  plainType: TEXT_PLAIN,\n  dataFragment: DATA_EDITABLE_FRAGMENT,\n  dataNode: DATA_EDITABLE_NODE,\n  dataInline: DATA_EDITABLE_INLINE,\n  dataString: DATA_EDITABLE_STRING,\n  dataComposition: DATA_EDITABLE_COMPOSITION,\n  dataZeroWidth: DATA_EDITABLE_ZERO_WIDTH,\n  dataLength: DATA_EDITABLE_LENGTH,\n  dataVoid: DATA_EDITABLE_VOID,\n  dataPlaceholder: DATA_EDITABLE_PLACEHOLDER,\n  dataLeaf: DATA_EDITABLE_LEAF,\n}\n","import { Descendant } from '@editablejs/models'\nimport {\n  APPLICATION_FRAGMENT_TYPE,\n  DATA_EDITABLE_FRAGMENT,\n  TEXT_HTML,\n  TEXT_PLAIN,\n} from './constants'\n\ninterface DataTransferFormatData {\n  html: string\n  text: string\n  fragment: Descendant[]\n  files: File[]\n}\n\n/**\n * Convert fragment to string\n * @param fragment\n * @returns string representation of the fragment\n **/\nexport const fragmentToString = (fragment: Descendant[]) => {\n  const string = JSON.stringify(fragment)\n  return window.btoa(encodeURIComponent(string))\n}\n\n/**\n * Parse fragment from string\n * @param fragment string representation of the fragment\n * @returns fragment\n **/\nexport const parseFragmentFromString = (fragment: string): Descendant[] => {\n  const string = decodeURIComponent(window.atob(fragment))\n  try {\n    return JSON.parse(string)\n  } catch (error) {\n    return []\n  }\n}\n\n/**\n * Match fragment string from HTML\n * @param html\n * @returns string representation of the fragment\n **/\nexport const matchFragmentStringFromHTML = (html: string) => {\n  const reg = new RegExp(`${DATA_EDITABLE_FRAGMENT}=\"(.+?)\"`)\n  return html.match(reg)?.[1] ?? ''\n}\n\n/**\n * Parse files from DataTransfer object\n * @param dataTransfer\n * @returns array of files\n **/\nexport const parseDataTransferFiles = (dataTransfer: DataTransfer) => {\n  let files: File[] = []\n\n  try {\n    if (dataTransfer.items && dataTransfer.items.length > 0) {\n      for (const item of dataTransfer.items) {\n        let file = item.kind === 'file' ? item.getAsFile() : null\n        if (file !== null) {\n          if (file.type && file.type.indexOf('image/png') > -1 && !file.lastModified) {\n            file = new File([file], 'image.png', {\n              type: file.type,\n            })\n          }\n        }\n        if (file) files.push(file)\n      }\n    } else if (dataTransfer.files && dataTransfer.files.length > 0) {\n      files = Array.from(dataTransfer.files)\n    }\n  } catch (err) {\n    if (dataTransfer.files && dataTransfer.files.length > 0) {\n      files = Array.from(dataTransfer.files)\n    }\n  }\n  return files\n}\n\n/**\n * Parse Data from DataTransfer\n * @param dataTransfer\n * @returns DataTransferFormatData\n **/\nexport const parseDataTransfer = (dataTransfer: DataTransfer): DataTransferFormatData => {\n  const text = dataTransfer.getData(TEXT_PLAIN)\n  const html = dataTransfer.getData(TEXT_HTML)\n  let fragment = dataTransfer.getData(APPLICATION_FRAGMENT_TYPE)\n  if (!fragment) fragment = matchFragmentStringFromHTML(html)\n  return {\n    text,\n    html,\n    fragment: fragment ? parseFragmentFromString(fragment) : [],\n    files: parseDataTransferFiles(dataTransfer),\n  }\n}\n\n/**\n * Set Data to DataTransfer\n * @param dataTransfer\n * @param data\n **/\nexport const setDataTransfer = (\n  dataTransfer: DataTransfer,\n  data: Partial<DataTransferFormatData>,\n) => {\n  const { text, html, fragment, files } = data\n  if (text) dataTransfer.setData(TEXT_PLAIN, text)\n  if (html) dataTransfer.setData(TEXT_HTML, html)\n  if (fragment) dataTransfer.setData(APPLICATION_FRAGMENT_TYPE, fragmentToString(fragment))\n  if (files) {\n    for (const file of files) {\n      dataTransfer.items.add(file)\n    }\n  }\n}\n","import * as React from 'react'\nimport { useStore } from 'zustand'\nimport { Editable } from '../plugin/editable'\nimport { Locale, LocaleComponentName } from '../plugin/locale'\nimport { useEditableStatic } from './use-editable'\n\nexport const useLocaleStore = (editor: Editable) => {\n  return React.useMemo(() => {\n    return Locale.getStore(editor)\n  }, [editor])\n}\n\nexport const useLang = (editor: Editable): string => {\n  const store = useLocaleStore(editor)\n  return useStore(store, state => state.lang)\n}\n\nexport const useLocale = <\n  L extends Locale,\n  T extends LocaleComponentName<L> = LocaleComponentName<L>,\n>(\n  componentName: T,\n  defaultLocale?: L[T] | (() => L[T]),\n): L[T] => {\n  const editor = useEditableStatic()\n  const lang = useLang(editor)\n  const localeContext = useLocales<L>(editor, lang)\n  const componentLocaleContext = localeContext[componentName]\n\n  const componentLocale = React.useMemo(() => {\n    const locale = componentLocaleContext || defaultLocale\n    return {\n      ...(locale instanceof Function ? locale() : locale),\n    } as L[T]\n  }, [defaultLocale, componentLocaleContext])\n\n  return componentLocale\n}\n\nexport const useLocales = <T extends Locale>(editor: Editable, lang: string): T => {\n  const store = useLocaleStore(editor)\n\n  const locales = useStore(store, state => state.locales[lang] ?? state.locales['en-US'])\n  return locales as T\n}\n\nexport const useLocaleFormat = <\n  L extends Locale,\n  T extends LocaleComponentName<L> = LocaleComponentName<L>,\n>(\n  componentName: T,\n) => {\n  const locale = useLocale<L>(componentName)\n  return {\n    format: (key: keyof typeof locale, options?: Record<string, string | number>) => {\n      const value = locale[key]\n      if (typeof value === 'string') {\n        if (!options) return value\n        return value.replace(/{(\\w+)}/g, (match, key) => String(options[key]) || match)\n      }\n      return ''\n    },\n  }\n}\n","import merge from 'lodash.merge'\nimport create, { StoreApi, UseBoundStore } from 'zustand'\nimport { Editor } from '@editablejs/models'\nexport interface Locale {\n  locale: string\n}\n\nexport interface LocaleState {\n  lang: string\n  locales: Record<string, Locale>\n}\n\nconst EDITOR_TO_LOCALE_STORE: WeakMap<Editor, UseBoundStore<StoreApi<LocaleState>>> = new WeakMap()\n\nconst getStore = (editor: Editor) => {\n  let store = EDITOR_TO_LOCALE_STORE.get(editor)\n  if (!store) {\n    store = create<LocaleState>(() => ({\n      lang: 'en-US',\n      locales: {},\n    }))\n    EDITOR_TO_LOCALE_STORE.set(editor, store)\n  }\n  return store\n}\n\nexport const Locale = {\n  getStore,\n\n  setLocale: <T extends Locale>(editor: Editor, ...locales: Record<string, T>[]) => {\n    const store = getStore(editor)\n    store.setState(state => {\n      const { lang, locales: prevLocales } = state\n      const newLocales = Object.assign({}, prevLocales)\n      for (const locale of locales) {\n        for (const key in locale) {\n          newLocales[key] = merge(newLocales[key], locale[key])\n        }\n      }\n      return {\n        lang,\n        locales: newLocales,\n      }\n    })\n  },\n\n  getLang: (editor: Editor) => {\n    const state = getStore(editor).getState()\n    return state.lang\n  },\n\n  setLang: (editor: Editor, lang: string) => {\n    const store = getStore(editor)\n    store.setState(state => {\n      return {\n        lang,\n        locales: state.locales,\n      }\n    })\n  },\n\n  getLocale: <T extends Locale>(editor: Editor): T => {\n    const lang = Locale.getLang(editor)\n    const locales = Locale.getLocales(editor)\n    return (locales[lang] ?? locales['en-US']) as any\n  },\n\n  getLocales: (editor: Editor): Record<string, Locale> => {\n    const state = getStore(editor).getState()\n    return state.locales\n  },\n}\n\nexport type LocaleComponentName<T extends Locale> = Exclude<keyof T, 'locale'>\n","import * as React from 'react'\nimport { StoreApi, UseBoundStore, useStore } from 'zustand'\nimport { Editable } from '../plugin/editable'\n\nexport interface EditableStore {\n  editor: [Editable]\n}\n\nexport const useEditableStore = () => {\n  const contenxt = React.useContext(EditableStoreContext)\n  if (!contenxt) {\n    throw new Error(\n      `The \\`useEditableStore\\` hook must be used inside the <EditableProvider> component's context.`,\n    )\n  }\n\n  return contenxt.store\n}\n\nexport interface EditableStoreContext {\n  store: UseBoundStore<StoreApi<EditableStore>>\n  editor: Editable\n}\n\nexport const EditableStoreContext = React.createContext<EditableStoreContext | null>(null)\n\n/**\n * 静态的编辑器对象\n * @returns\n */\nexport const useEditableStatic = (): Editable => {\n  const contenxt = React.useContext(EditableStoreContext)\n\n  if (!contenxt) {\n    throw new Error(\n      `The \\`useEditableStatic\\` hook must be used inside the <EditableProvider> component's context.`,\n    )\n  }\n\n  return contenxt.editor\n}\n\n/**\n * 实时变化的编辑器对象\n * @returns\n */\nexport const useEditable = (): Editable => {\n  const store = useEditableStore()\n\n  return useStore(store, state => {\n    return state.editor\n  })[0]\n}\n","import * as React from 'react'\nimport {\n  Editor,\n  Range,\n  Transforms,\n  Point,\n  Path,\n  Element,\n  DOMNode,\n  getDefaultView,\n  isDOMNode,\n} from '@editablejs/models'\n\nimport useChildren from '../hooks/use-children'\nimport { useEditable, useEditableStatic } from '../hooks/use-editable'\nimport { Editable } from '../plugin/editable'\nimport { useReadOnly } from '../hooks/use-read-only'\nimport { useIsomorphicLayoutEffect } from '../hooks/use-isomorphic-layout-effect'\nimport { inAbsoluteDOMElement } from '../utils/dom'\nimport {\n  EDITOR_TO_ELEMENT,\n  ELEMENT_TO_NODE,\n  NODE_TO_ELEMENT,\n  EDITOR_TO_WINDOW,\n  IS_SHIFT_PRESSED,\n  EDITOR_TO_SHADOW,\n  IS_MOUSEDOWN,\n  IS_TOUCHMOVING,\n  IS_TOUCHING,\n  IS_TOUCH_HOLD,\n} from '../utils/weak-maps'\nimport { useMultipleClick } from '../hooks/use-multiple-click'\nimport { Focused, useFocused } from '../hooks/use-focused'\nimport ShadowContainer from './shadow'\nimport { CaretComponent } from './caret'\nimport { SelectionComponent } from './selection'\nimport { InputComponent } from './input'\nimport { useDragging, useDragMethods, useDragTo } from '../hooks/use-drag'\nimport { SelectionDrawing, SelectionDrawingStyle } from '../plugin/selection-drawing'\nimport { APPLICATION_FRAGMENT_TYPE, DATA_EDITABLE_NODE } from '../utils/constants'\nimport { DragCaretComponent } from './drag-caret'\nimport { parseFragmentFromString, setDataTransfer } from '../utils/data-transfer'\nimport { Slots } from './slot'\nimport { Drag } from '../plugin/drag'\nimport { Placeholder } from '../plugin/placeholder'\nimport { usePlaceholder } from '../hooks/use-placeholder'\nimport { isTouchDevice } from '../utils/environment'\nimport { TouchPointComponent } from './touch-point'\nimport { getNativeEvent, isMouseEvent, isTouchEvent } from '../utils/event'\nimport { canForceTakeFocus, isEditableDOMElement } from '../utils/dom'\nimport { Locale } from '../plugin/locale'\n\nconst Children = (props: Omit<Parameters<typeof useChildren>[0], 'node' | 'selection'>) => {\n  const editor = useEditable()\n  return (\n    <React.Fragment>\n      {useChildren({ ...props, node: editor, selection: editor.selection })}\n    </React.Fragment>\n  )\n}\n\n/**\n * `EditableProps` are passed to the `<Editable>` component.\n */\nexport type EditableProps = {\n  readOnly?: boolean\n  lang?: string\n  autoFocus?: boolean\n  placeholder?: React.ReactNode\n  role?: string\n  style?: React.CSSProperties\n  as?: React.ElementType\n  className?: string\n  selectionDrawingStyle?: SelectionDrawingStyle\n}\n\n/**\n * ContentEditable.\n */\nexport const ContentEditable = (props: EditableProps) => {\n  const {\n    autoFocus = true,\n    placeholder,\n    readOnly: readOnlyProp = false,\n    lang,\n    style = {},\n    as: Component = 'div',\n    selectionDrawingStyle: selectionDrawingStyleProp,\n    ...attributes\n  } = props\n  const editor = useEditableStatic()\n\n  const ref = React.useRef<HTMLDivElement>(null)\n  const [readOnly, setReadOnly] = useReadOnly()\n  // 标记是否是刚拖拽完毕\n  const isDragEnded = React.useRef(false)\n  const dragTo = useDragTo()\n  const dragging = useDragging()\n  const { getDrag, setDrag } = useDragMethods()\n\n  const [rendered, setRendered] = React.useState(false)\n\n  // Touch hold timer\n  const touchHoldTimer = React.useRef<number | null>(null)\n\n  React.useEffect(() => {\n    if (placeholder && !readOnly) {\n      const unsubscribe = Placeholder.subscribe(\n        editor,\n        ([node]) => {\n          if (Editable.isEditor(node) && !node.children.some(n => Editor.isList(editor, n)))\n            return () => placeholder\n        },\n        true,\n      )\n\n      return () => {\n        unsubscribe()\n      }\n    }\n  }, [editor, placeholder, readOnly])\n\n  useIsomorphicLayoutEffect(() => {\n    setReadOnly(readOnlyProp)\n  }, [readOnlyProp])\n\n  useIsomorphicLayoutEffect(() => {\n    Locale.setLang(editor, props.lang || 'en-US')\n  }, [editor, lang])\n\n  useIsomorphicLayoutEffect(() => {\n    if (selectionDrawingStyleProp) SelectionDrawing.setStyle(editor, selectionDrawingStyleProp)\n  }, [editor, selectionDrawingStyleProp])\n\n  const [focused, setFocused] = useFocused()\n\n  const startPointRef = React.useRef<Point | null>(null)\n  const isContextMenu = React.useRef(false)\n\n  const clearTouchHoldTimer = () => {\n    if (touchHoldTimer.current) clearTimeout(touchHoldTimer.current)\n  }\n\n  const handleDocumentMouseDown = (event: MouseEvent | TouchEvent) => {\n    const isMouseDown = IS_MOUSEDOWN.get(editor)\n    const isTouching = IS_TOUCHING.get(editor)\n    if (!isMouseDown && !isTouching && !event.defaultPrevented) setFocused(false)\n  }\n\n  const handleSelecting = (point: Point | null, rest = true, forceFocus = true) => {\n    if (!point) return\n    const { selection } = editor\n    if (!rest && selection && Range.includes(selection, point)) {\n      return\n    }\n    let anchor: Point | null = null\n\n    if (IS_TOUCHING.get(editor)) {\n      anchor = point\n    } else {\n      anchor = IS_SHIFT_PRESSED.get(editor) && selection ? selection.anchor : startPointRef.current\n    }\n    if (!anchor) return\n    const range: Range = { anchor, focus: point }\n    if (selection && forceFocus && Range.equals(range, selection)) {\n      editor.focus()\n      setFocused(true)\n      return true\n    }\n    Transforms.select(editor, range)\n    return range\n  }\n\n  const handleDocumentTouchEnd = (event: TouchEvent) => {\n    if (event.defaultPrevented) return\n    clearTouchHoldTimer()\n    // touch move 之后不会触发 mouse up 事件，所以需要在 touch end 时触发\n    if (IS_TOUCHMOVING.get(editor)) {\n      handleDocumentMouseUp(event)\n      IS_TOUCHING.set(editor, false)\n    } else if (IS_TOUCH_HOLD.get(editor)) {\n      IS_TOUCHING.set(editor, false)\n      IS_MOUSEDOWN.set(editor, false)\n      IS_TOUCH_HOLD.set(editor, false)\n      event.preventDefault()\n      editor.onTouchHold(event)\n    }\n  }\n\n  const handleDocumentMouseUp = (event: MouseEvent | TouchEvent) => {\n    const drag = getDrag()\n    const isMouseDown = IS_MOUSEDOWN.get(editor)\n    if (\n      drag ||\n      (IS_TOUCHING.get(editor) && !IS_TOUCH_HOLD.get(editor)) ||\n      (isMouseDown &&\n        (!event.defaultPrevented || (event instanceof MouseEvent && event.button === 2)))\n    ) {\n      if (focused && !isEditableDOMElement(event.target) && canForceTakeFocus()) {\n        editor.focus()\n      }\n      const point = Editable.findEventPoint(editor, event)\n      let isSelectedSame = false\n      if (point && drag) {\n        const { from, data, type = 'text' } = drag\n        const fromRange = Editor.range(editor, from)\n        if (!Range.includes(fromRange, point)) {\n          const fragment = parseFragmentFromString(data.getData(APPLICATION_FRAGMENT_TYPE))\n          if (type === 'block') {\n            const path = Drag.toBlockPath(editor)\n            if (path && fragment.length > 0) {\n              const rangeRef = Editor.rangeRef(editor, {\n                anchor: {\n                  path,\n                  offset: 0,\n                },\n                focus: {\n                  path,\n                  offset: 0,\n                },\n              })\n              Transforms.removeNodes(editor, { at: from })\n              const at = rangeRef.unref()\n              Transforms.insertNodes(editor, fragment, {\n                at: at?.anchor.path ?? path,\n                select: true,\n              })\n            }\n          } else {\n            const deleteAfterRange = Editor.rangeRef(editor, Editor.range(editor, point))\n            Transforms.delete(editor, {\n              at: from,\n              unit: 'line',\n              hanging: true,\n            })\n            const anchorRange = deleteAfterRange.unref()\n            Transforms.select(editor, anchorRange ?? point)\n            Transforms.insertFragment(editor, fragment)\n            const focus = editor.selection?.focus\n            if (anchorRange && focus) {\n              let anchor = anchorRange.anchor\n              const anchorElement = Editor.above(editor, {\n                at: anchorRange,\n                match: node => Element.isElement(node),\n                voids: true,\n              })\n\n              const nextPath = Path.next(anchor.path)\n\n              if (anchorElement && Editor.hasPath(editor, nextPath)) {\n                const nextRange = Editor.range(editor, nextPath)\n                const element = Editor.above(editor, {\n                  at: nextRange,\n                  match: node => Element.isElement(node),\n                  voids: true,\n                })\n                if (element && anchorElement[0] !== element[0]) {\n                  anchor = nextRange.anchor\n                }\n              }\n              Transforms.select(editor, {\n                anchor,\n                focus,\n              })\n            }\n          }\n\n          isDragEnded.current = true\n        } else {\n          Transforms.select(editor, point)\n        }\n      } else {\n        const { selection } = editor\n        if (\n          IS_TOUCHING.get(editor) &&\n          point &&\n          selection &&\n          isSelectedOnCurrentSelection(editor, selection, point)\n        ) {\n          isSelectedSame = true\n        } else {\n          // 是否选中在同一个位置\n          isSelectedSame =\n            handleSelecting(point, !isContextMenu.current, !isEditableDOMElement(event.target)) ===\n            true\n        }\n      }\n      // 修复 touch 时，触发了 mouse up 事件，导致无法触发 onSelectStart\n      if (IS_TOUCHING.get(editor) && !IS_TOUCH_HOLD.get(editor)) {\n        // touch 在同一个位置，触发 onTouchTrack\n        if (isSelectedSame) editor.onTouchTrack()\n        else editor.onSelectStart()\n      }\n      setDrag(null)\n      if (!isDragEnded.current && (!IS_TOUCHING.get(editor) || !isSelectedSame))\n        editor.onSelectEnd()\n    }\n\n    isContextMenu.current = false\n    startPointRef.current = null\n    IS_TOUCHMOVING.set(editor, false)\n    IS_TOUCHING.set(editor, false)\n    IS_MOUSEDOWN.set(editor, false)\n  }\n\n  const handleDocumentMouseMove = (event: MouseEvent | TouchEvent) => {\n    const darg = getDrag()\n    const isMouseDown = IS_MOUSEDOWN.get(editor)\n    // 未长按不触发 move 事件\n    if (IS_TOUCHING.get(editor) && !IS_TOUCH_HOLD.get(editor)) {\n      clearTouchHoldTimer()\n      return\n    }\n    const isTouchMoving = isTouchEvent(event)\n    IS_TOUCHMOVING.set(editor, isTouchMoving)\n\n    if (\n      !isTouchMoving &&\n      !darg &&\n      ((isMouseEvent(event) && event.button !== 0) ||\n        !isMouseDown ||\n        event.defaultPrevented ||\n        isContextMenu.current)\n    )\n      return\n    const point = event.defaultPrevented ? null : Editable.findEventPoint(editor, event)\n    if (point && dragging && isMouseEvent(event)) {\n      setDrag({\n        to: {\n          anchor: point,\n          focus: point,\n        },\n        position: {\n          x: event.clientX,\n          y: event.clientY,\n        },\n      })\n      return\n    }\n    // 阻止 touchmove 时页面滚动\n    if (isTouchMoving) event.preventDefault()\n    const range = handleSelecting(point)\n    if (range) editor.onSelecting()\n  }\n\n  const handleRootTouchStart = (event: React.TouchEvent) => {\n    if (event.defaultPrevented) return\n    if (\n      !event.target ||\n      !ref.current?.contains(event.target as DOMNode) ||\n      isEditableDOMElement(event.target) ||\n      inAbsoluteDOMElement(event.target)\n    )\n      return\n\n    const { selection } = editor\n\n    IS_TOUCHING.set(editor, true)\n    IS_TOUCH_HOLD.set(editor, false)\n    clearTouchHoldTimer()\n    // touch hold\n    touchHoldTimer.current = setTimeout(() => {\n      IS_TOUCH_HOLD.set(editor, true)\n\n      if (Focused.is(editor)) {\n        handleRootMouseDown(event)\n      } else if (!selection || Range.isCollapsed(selection)) {\n        IS_TOUCHING.set(editor, false)\n        const point = Editable.findEventPoint(editor, event)\n        if (point)\n          editor.selectWord({\n            at: {\n              anchor: point,\n              focus: point,\n            },\n          })\n      }\n    }, 530)\n  }\n\n  const handleRootMouseDown = (e: React.MouseEvent | React.TouchEvent) => {\n    const event = getNativeEvent(e)\n    if (e.defaultPrevented && isMouseEvent(event) && event.button !== 2) return\n    if (\n      !event.target ||\n      !ref.current?.contains(event.target as DOMNode) ||\n      isEditableDOMElement(event.target) ||\n      inAbsoluteDOMElement(event.target)\n    )\n      return\n\n    IS_MOUSEDOWN.set(editor, true)\n    if (isDoubleClickRef.current) {\n      if (isSamePoint(event)) {\n        return\n      } else {\n        isDoubleClickRef.current = false\n      }\n    }\n    setFocused(true)\n    const point = Editable.findEventPoint(editor, event)\n    if (point) {\n      const isShift = IS_SHIFT_PRESSED.get(editor)\n      if (!isShift) {\n        const { selection } = editor\n        if (event instanceof MouseEvent && event.button === 2) {\n          isContextMenu.current = true\n        }\n        // Perform drag on existing selection while selected.\n        else if (\n          selection &&\n          focused &&\n          isSelectedOnCurrentSelection(editor, selection, point, isTouchDevice)\n        ) {\n          // Drag not performed on touch devices.\n          if (!isTouchDevice) {\n            const dataTransfer = new DataTransfer()\n            setDataTransfer(dataTransfer, {\n              fragment: editor.getFragment(selection),\n            })\n            setDrag({\n              from: selection,\n              data: dataTransfer,\n              position: {\n                x: event.clientX,\n                y: event.clientY,\n              },\n            })\n            editor.onSelectStart()\n          }\n          return\n        }\n        startPointRef.current = point\n      }\n      const range = handleSelecting(\n        point,\n        !isContextMenu.current,\n        !isEditableDOMElement(event.target),\n      )\n      if (range) editor.onSelectStart()\n    } else startPointRef.current = null\n  }\n\n  const handleRootMouseUp = () => {\n    startPointRef.current = null\n  }\n\n  const isDoubleClickRef = React.useRef(false)\n  const isDoubleClickTimerRef = React.useRef<number>()\n  const { handleMultipleClick, isSamePoint } = useMultipleClick({\n    onClick: () => {\n      isDoubleClickRef.current = false\n    },\n    onMultipleClick: (event, count) => {\n      const { selection } = editor\n      if (!selection || event.defaultPrevented) return\n      event.preventDefault()\n      const container = Editable.toDOMNode(editor, editor)\n      if (isDOMNode(event.target) && !container.contains(event.target)) return\n      const isCollapsed = Range.isCollapsed(selection)\n      if (count === 1 && !isCollapsed) {\n        return false\n      } else if (count === 2) {\n        editor.selectWord()\n        isDoubleClickRef.current = true\n        if (isDoubleClickTimerRef.current) clearTimeout(isDoubleClickTimerRef.current)\n        isDoubleClickTimerRef.current = setTimeout(() => {\n          isDoubleClickRef.current = false\n        }, 500)\n        return\n      } else if (count === 3) {\n        editor.selectLine()\n        isDoubleClickRef.current = false\n        return false\n      }\n    },\n  })\n\n  const [awaitUpdateDrawingSelection, setAwaitUpdateDrawingSelection] = React.useState(\n    editor.selection,\n  )\n\n  useIsomorphicLayoutEffect(() => {\n    const handleChange = () => {\n      const { selection } = editor\n      setAwaitUpdateDrawingSelection(selection ? Object.assign({}, selection) : null)\n    }\n    editor.on('change', handleChange)\n\n    const handleShift = (event: KeyboardEvent) => {\n      if (event.key.toLowerCase() === 'shift') {\n        IS_SHIFT_PRESSED.set(editor, false)\n      }\n    }\n\n    let window: Window | null = null\n    if (ref.current && (window = getDefaultView(ref.current))) {\n      EDITOR_TO_WINDOW.set(editor, window)\n      EDITOR_TO_ELEMENT.set(editor, ref.current)\n      NODE_TO_ELEMENT.set(editor, ref.current)\n      ELEMENT_TO_NODE.set(ref.current, editor)\n      setRendered(true)\n\n      window.addEventListener('keyup', handleShift)\n      window.addEventListener('mousedown', handleDocumentMouseDown)\n      window.addEventListener('mouseup', handleDocumentMouseUp)\n      if (isTouchDevice) {\n        window.addEventListener('touchend', handleDocumentTouchEnd)\n        window.addEventListener('touchmove', handleDocumentMouseMove, { passive: false })\n      } else {\n        window.addEventListener('mousemove', handleDocumentMouseMove)\n      }\n    } else {\n      NODE_TO_ELEMENT.delete(editor)\n    }\n\n    return () => {\n      editor.off('change', handleChange)\n      window?.removeEventListener('keyup', handleShift)\n      window?.removeEventListener('mousedown', handleDocumentMouseDown)\n      window?.removeEventListener('mouseup', handleDocumentMouseUp)\n      if (isTouchDevice) {\n        window?.removeEventListener('touchend', handleDocumentTouchEnd)\n        window?.removeEventListener('touchmove', handleDocumentMouseMove)\n      } else {\n        window?.removeEventListener('mousemove', handleDocumentMouseMove)\n      }\n    }\n  }, [editor, handleDocumentMouseDown, handleDocumentMouseMove, handleDocumentMouseUp])\n\n  React.useEffect(() => {\n    // 在拖拽完成后触发onSelectEnd，否则内容可能还未渲染完毕\n    if (isDragEnded.current) {\n      editor.onSelectEnd()\n      isDragEnded.current = false\n    }\n  }, [awaitUpdateDrawingSelection, editor])\n\n  useIsomorphicLayoutEffect(() => {\n    SelectionDrawing.setSelection(editor, awaitUpdateDrawingSelection)\n  }, [awaitUpdateDrawingSelection])\n\n  // 处理文件拖拽\n  const handleDragOver = (event: React.DragEvent) => {\n    event.preventDefault()\n    if (readOnly) return\n    const point = Editable.findEventPoint(editor, event)\n    if (point) {\n      const dragRange = {\n        anchor: point,\n        focus: point,\n      }\n      const position = {\n        x: event.clientX,\n        y: event.clientY,\n      }\n      if (!dragging) {\n        setDrag({\n          type: 'text',\n          from: dragRange,\n          data: event.dataTransfer,\n        })\n      }\n      setDrag({\n        position,\n        to: dragRange,\n      })\n    }\n  }\n\n  const handleDrop = (event: React.DragEvent) => {\n    event.preventDefault()\n    event.stopPropagation()\n    setDrag(null)\n    if (readOnly) return\n    const point = Editable.findEventPoint(editor, event)\n    if (point) {\n      Transforms.select(editor, point)\n      const clipboardEvent = new ClipboardEvent('paset', { clipboardData: event.dataTransfer })\n      editor.onPaste(clipboardEvent)\n    }\n  }\n\n  const handleContextMenu = (event: React.MouseEvent) => {\n    if (!isTouchDevice) editor.onContextMenu(event.nativeEvent)\n  }\n\n  const cursor = React.useMemo(() => {\n    if (dragging && dragTo) {\n      return 'default'\n    }\n    return 'text'\n  }, [dragTo, dragging])\n\n  const renderPlaceholder = usePlaceholder(editor)\n\n  const handleAnchorTouchPointStart = React.useCallback(\n    (event: React.TouchEvent) => {\n      event.stopPropagation()\n      const { selection } = editor\n      if (!selection) return\n      startPointRef.current = Range.end(selection)\n      IS_MOUSEDOWN.set(editor, true)\n      editor.onSelectStart()\n    },\n    [editor],\n  )\n\n  const handleFocusTouchPointStart = React.useCallback(\n    (event: React.TouchEvent) => {\n      event.stopPropagation()\n      const { selection } = editor\n      if (!selection) return\n      startPointRef.current = Range.start(selection)\n      IS_MOUSEDOWN.set(editor, true)\n      editor.onSelectStart()\n    },\n    [editor],\n  )\n\n  return (\n    <div\n      style={{\n        ...style,\n        position: 'relative',\n      }}\n    >\n      <Component\n        role={readOnly ? undefined : 'textbox'}\n        {...attributes}\n        {...{ [DATA_EDITABLE_NODE]: 'editor' }}\n        zindex={-1}\n        ref={ref}\n        style={{\n          // Prevent the default outline styles.\n          outline: 'none',\n          // Preserve adjacent whitespace and new lines.\n          whiteSpace: 'pre-wrap',\n          // Allow words to break if they are too long.\n          wordBreak: 'break-word',\n          // Disable the default user-select behavior.\n          userSelect: 'none',\n          // Set cursor to text.\n          cursor,\n          //\n          overflowWrap: 'break-word',\n        }}\n        onTouchStart={isTouchDevice ? handleRootTouchStart : undefined}\n        onMouseDown={isTouchDevice ? undefined : handleRootMouseDown}\n        onMouseUp={handleRootMouseUp}\n        onClick={handleMultipleClick}\n        onDragOver={handleDragOver}\n        onDrop={handleDrop}\n        onContextMenu={handleContextMenu}\n      >\n        <Children renderPlaceholder={renderPlaceholder} />\n      </Component>\n      <ShadowContainer ref={current => EDITOR_TO_SHADOW.set(editor, current)}>\n        <CaretComponent />\n        <DragCaretComponent />\n        <SelectionComponent />\n        <InputComponent autoFocus={autoFocus} />\n      </ShadowContainer>\n      <TouchPointComponent\n        onAnchorTouchStart={handleAnchorTouchPointStart}\n        onFocusTouchStart={handleFocusTouchPointStart}\n      />\n      {rendered && <Slots />}\n    </div>\n  )\n}\n\nconst isSelectedOnCurrentSelection = (\n  editor: Editor,\n  selection: Range,\n  point: Point,\n  compareOnCollapsed = false,\n) => {\n  return (\n    (Range.includes(selection, point) &&\n      ((!Point.equals(Range.end(selection), point) &&\n        !Point.equals(Range.start(selection), point)) ||\n        (Range.isCollapsed(selection) &&\n          !!Editor.above(editor, { match: n => Editor.isVoid(editor, n) })))) ||\n    (compareOnCollapsed &&\n      Range.isCollapsed(selection) &&\n      Point.equals(Range.start(selection), point))\n  )\n}\n","import { Editor, Range, Element, Ancestor, Descendant } from '@editablejs/models'\n\nimport ElementComponent from '../components/element'\nimport TextComponent from '../components/text'\nimport { Editable } from '../plugin/editable'\nimport { useEditableStatic } from './use-editable'\nimport { NODE_TO_INDEX, NODE_TO_PARENT } from '../utils/weak-maps'\nimport { NodeSelectedContext } from './use-node-selected'\nimport { NodeFocusedContext } from './use-node-focused'\nimport { GridContext } from './use-grid'\nimport { PlaceholderRender } from '../plugin/placeholder'\n\n/**\n * Children.\n */\nconst useChildren = (props: {\n  node: Ancestor\n  selection: Range | null\n  renderPlaceholder?: PlaceholderRender\n}) => {\n  const { node, selection, renderPlaceholder } = props\n  const editor = useEditableStatic()\n  const path = Editable.findPath(editor, node)\n  const children = []\n  const isLeafBlock =\n    Element.isElement(node) && !editor.isInline(node) && Editor.hasInlines(editor, node)\n\n  for (let i = 0; i < node.children.length; i++) {\n    const p = path.concat(i)\n    const n = node.children[i] as Descendant\n    const key = Editable.findKey(editor, n)\n    const range = Editor.range(editor, p)\n    const sel = selection && Range.intersection(range, selection)\n    const focused =\n      selection && Range.includes(range, selection.anchor) && Range.includes(range, selection.focus)\n\n    if (Element.isElement(n)) {\n      const element = (\n        <NodeSelectedContext.Provider key={`selected-provider-${key.id}`} value={!!sel}>\n          <NodeFocusedContext.Provider key={`focused-provider-${key.id}`} value={focused ?? false}>\n            <ElementComponent\n              element={n}\n              key={key.id}\n              selection={sel}\n              renderPlaceholder={renderPlaceholder}\n            />\n          </NodeFocusedContext.Provider>\n        </NodeSelectedContext.Provider>\n      )\n      if (Editor.isGrid(editor, n)) {\n        children.push(\n          <GridContext.Provider key={`grid-provider-${key.id}`} value={n}>\n            {element}\n          </GridContext.Provider>,\n        )\n      } else {\n        children.push(element)\n      }\n    } else {\n      children.push(\n        <TextComponent\n          renderPlaceholder={renderPlaceholder}\n          key={key.id}\n          isLast={isLeafBlock && i === node.children.length - 1}\n          parent={node}\n          text={n}\n        />,\n      )\n    }\n\n    NODE_TO_INDEX.set(n, i)\n    NODE_TO_PARENT.set(n, node)\n  }\n\n  return children\n}\n\nexport default useChildren\n","import * as React from 'react'\nimport getDirection from 'direction'\nimport { Editor, Node, Range, Element as SlateElement } from '@editablejs/models'\n\nimport Text from './text'\nimport useChildren from '../hooks/use-children'\nimport { Editable, useEditableStatic, ElementAttributes } from '..'\nimport { useIsomorphicLayoutEffect } from '../hooks/use-isomorphic-layout-effect'\nimport {\n  NODE_TO_ELEMENT,\n  ELEMENT_TO_NODE,\n  NODE_TO_PARENT,\n  NODE_TO_INDEX,\n  EDITOR_TO_KEY_TO_ELEMENT,\n} from '../utils/weak-maps'\nimport { DATA_EDITABLE_INLINE, DATA_EDITABLE_NODE, DATA_EDITABLE_VOID } from '../utils/constants'\nimport { useElementDecorations } from '../hooks/use-decorate'\nimport { PlaceholderRender } from '../plugin/placeholder'\nimport { usePlaceholder } from '../hooks/use-placeholder'\n\n/**\n * Element.\n */\nconst Element = (props: {\n  element: SlateElement\n  selection: Range | null\n  renderPlaceholder?: PlaceholderRender\n}) => {\n  const { element, selection, renderPlaceholder } = props\n  const ref = React.useRef<HTMLElement>(null)\n  const editor = useEditableStatic()\n  const isInline = editor.isInline(element)\n  const key = Editable.findKey(editor, element)\n\n  const currentRenderPlaceholder = usePlaceholder(element)\n  let children: React.ReactNode = useChildren({\n    node: element,\n    selection,\n    renderPlaceholder: Editor.isEmpty(editor, element)\n      ? currentRenderPlaceholder ?? renderPlaceholder\n      : undefined,\n  })\n\n  // Attributes that the developer must mix into the element in their\n  // custom node renderer component.\n  const attributes: ElementAttributes = {\n    [DATA_EDITABLE_NODE]: 'element',\n    ref,\n  }\n\n  if (isInline) {\n    attributes[DATA_EDITABLE_INLINE] = true\n  }\n\n  // If it's a block node with inline children, add the proper `dir` attribute\n  // for text direction.\n  if (!isInline && Editor.hasInlines(editor, element)) {\n    const text = Node.string(element)\n    const dir = getDirection(text)\n\n    if (dir === 'rtl') {\n      attributes.dir = dir\n    }\n  }\n\n  // If it's a void node, wrap the children in extra void-specific elements.\n  if (Editor.isVoid(editor, element)) {\n    attributes[DATA_EDITABLE_VOID] = true\n\n    const Tag = isInline ? 'span' : 'div'\n    const [[text]] = Node.texts(element)\n\n    children = (\n      <Tag\n        style={{\n          height: '0',\n          color: 'transparent',\n          outline: 'none',\n        }}\n      >\n        <Text\n          renderPlaceholder={renderPlaceholder ?? currentRenderPlaceholder}\n          isLast={false}\n          parent={element}\n          text={text}\n        />\n      </Tag>\n    )\n\n    NODE_TO_INDEX.set(text, 0)\n    NODE_TO_PARENT.set(text, element)\n  }\n\n  // Update element-related weak maps with the DOM element ref.\n  useIsomorphicLayoutEffect(() => {\n    const KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor)\n    if (ref.current) {\n      KEY_TO_ELEMENT?.set(key, ref.current)\n      NODE_TO_ELEMENT.set(element, ref.current)\n      ELEMENT_TO_NODE.set(ref.current, element)\n    } else {\n      KEY_TO_ELEMENT?.delete(key)\n      NODE_TO_ELEMENT.delete(element)\n    }\n  })\n  const path = Editable.findPath(editor, element)\n\n  const newAttributes = editor.renderElementAttributes({ attributes, element })\n\n  let content = editor.renderElement({ attributes: newAttributes, children, element })\n\n  const decorates = useElementDecorations(element, path)\n\n  if (decorates.length > 0) {\n    content = decorates.reduceRight((children, decorate) => {\n      return decorate.renderElement({\n        node: element,\n        path,\n        children,\n      })\n    }, content)\n  }\n\n  return content\n}\n\nconst MemoizedElement = React.memo(Element, (prev, next) => {\n  return (\n    prev.element === next.element &&\n    prev.renderPlaceholder === next.renderPlaceholder &&\n    (prev.selection === next.selection ||\n      (!!prev.selection && !!next.selection && Range.equals(prev.selection, next.selection)))\n  )\n})\n\nexport default MemoizedElement\n","import * as React from 'react'\nimport { Element, Text as SlateText } from '@editablejs/models'\n\nimport Leaf from './leaf'\nimport { useIsomorphicLayoutEffect } from '../hooks/use-isomorphic-layout-effect'\nimport { NODE_TO_ELEMENT, ELEMENT_TO_NODE, EDITOR_TO_KEY_TO_ELEMENT } from '../utils/weak-maps'\nimport { useEditableStatic } from '../hooks/use-editable'\nimport { Editable } from '../plugin/editable'\nimport { DATA_EDITABLE_NODE } from '../utils/constants'\nimport { useTextDecorations } from '../hooks/use-decorate'\nimport { PlaceholderRender } from '../plugin/placeholder'\n\n/**\n * Text.\n */\nconst Text = (props: {\n  isLast: boolean\n  parent: Element\n  text: SlateText\n  renderPlaceholder?: PlaceholderRender\n}) => {\n  const { isLast, parent, text, renderPlaceholder } = props\n  const editor = useEditableStatic()\n  const ref = React.useRef<HTMLSpanElement>(null)\n  const key = Editable.findKey(editor, text)\n  const path = Editable.findPath(editor, text)\n  const decorates = useTextDecorations(text, path).map((d, index) => ({\n    ...d,\n    key: `__decorate__${index}`,\n  }))\n\n  const ranges = decorates\n    .map(({ ranges, key }) => ranges.map(range => ({ ...range, [key]: true })))\n    .flat()\n  const leaves = SlateText.decorations(text, ranges)\n\n  const decorateKeys = decorates.map(d => d.key)\n  const children = []\n  for (let i = 0; i < leaves.length; i++) {\n    const leaf = leaves[i]\n    let content = (\n      <Leaf\n        renderPlaceholder={renderPlaceholder}\n        isLast={isLast && i === leaves.length - 1}\n        key={`${key.id}-${i}`}\n        text={text}\n        leaf={leaf}\n        parent={parent}\n      />\n    )\n    for (const key of decorateKeys) {\n      if (key in leaf) {\n        const dec = decorates[decorateKeys.indexOf(key)].decorate.renderText({\n          node: text,\n          path,\n          children: content,\n        })\n        content = React.cloneElement(dec, { key })\n      }\n    }\n    children.push(content)\n  }\n  // Update element-related weak maps with the DOM element ref.\n  useIsomorphicLayoutEffect(() => {\n    const KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor)\n    if (ref.current) {\n      KEY_TO_ELEMENT?.set(key, ref.current)\n      NODE_TO_ELEMENT.set(text, ref.current)\n      ELEMENT_TO_NODE.set(ref.current, text)\n    } else {\n      KEY_TO_ELEMENT?.delete(key)\n      NODE_TO_ELEMENT.delete(text)\n    }\n  })\n\n  return (\n    <span {...{ [DATA_EDITABLE_NODE]: 'text' }} ref={ref}>\n      {children}\n    </span>\n  )\n}\n\nconst MemoizedText = React.memo(Text, (prev, next) => {\n  return (\n    next.parent === prev.parent &&\n    next.isLast === prev.isLast &&\n    next.text === prev.text &&\n    prev.renderPlaceholder === next.renderPlaceholder\n  )\n})\n\nexport default MemoizedText\n","import * as React from 'react'\nimport { Element, Text } from '@editablejs/models'\nimport String from './string'\nimport { useEditableStatic } from '../hooks/use-editable'\nimport { TextAttributes } from '../plugin/editable'\nimport { DATA_EDITABLE_LEAF, DATA_EDITABLE_PLACEHOLDER } from '../utils/constants'\nimport { PlaceholderRender } from '../plugin/placeholder'\n\n/**\n * Individual leaves in a text node with unique formatting.\n */\nconst Leaf = (props: {\n  isLast: boolean\n  parent: Element\n  leaf: Text\n  text: Text\n  renderPlaceholder?: PlaceholderRender\n}) => {\n  const { isLast, text, leaf, parent, renderPlaceholder } = props\n\n  let children = <String isLast={isLast} parent={parent} text={text} leaf={leaf} />\n\n  const editor = useEditableStatic()\n  if (renderPlaceholder) {\n    const placeholderComponent = editor.renderPlaceholder({\n      attributes: { [DATA_EDITABLE_PLACEHOLDER]: true },\n      node: text,\n      children: renderPlaceholder({ node: text }),\n    })\n    if (placeholderComponent)\n      children = (\n        <React.Fragment>\n          {placeholderComponent}\n          {children}\n        </React.Fragment>\n      )\n  }\n\n  // COMPAT: Having the `data-` attributes on these leaf elements ensures that\n  // in certain misbehaving browsers they aren't weirdly cloned/destroyed by\n  // contenteditable behaviors. (2019/05/08)\n  const attributes: TextAttributes = {\n    [DATA_EDITABLE_LEAF]: true,\n  }\n  const newAttributes = editor.renderLeafAttributes({ attributes, text })\n  return editor.renderLeaf({ attributes: newAttributes, children, text })\n}\n\nconst MemoizedLeaf = React.memo(Leaf, (prev, next) => {\n  return (\n    next.parent === prev.parent &&\n    prev.renderPlaceholder === next.renderPlaceholder &&\n    next.isLast === prev.isLast &&\n    next.text === prev.text\n  )\n})\n\nexport default MemoizedLeaf\n","import * as React from 'react'\nimport { Editor, Text, Path, Element, Node, CompositionText } from '@editablejs/models'\n\nimport { Editable } from '../plugin/editable'\nimport { useEditableStatic } from '../hooks/use-editable'\nimport {\n  DATA_EDITABLE_COMPOSITION,\n  DATA_EDITABLE_LENGTH,\n  DATA_EDITABLE_STRING,\n  DATA_EDITABLE_ZERO_WIDTH,\n} from '../utils/constants'\n\n/**\n * Leaf content strings.\n */\nconst String: React.FC<{\n  isLast: boolean\n  parent: Element\n  text: Text\n\n  leaf: Text\n}> = props => {\n  const { isLast, parent, text, leaf } = props\n  const editor = useEditableStatic()\n  const path = Editable.findPath(editor, text)\n  const parentPath = Path.parent(path)\n\n  // COMPAT: Render text inside void nodes with a zero-width space.\n  // So the node can contain selection but the text is not visible.\n  if (editor.isVoid(parent)) {\n    return <ZeroWidthString length={Node.string(parent).length} />\n  }\n\n  if (CompositionText.isCompositionText(text)) {\n    const { offset, text: compositionText } = text.composition\n    const content = text.text\n    const left = content.substring(0, offset)\n    const right = content.substring(offset)\n    return (\n      <>\n        {left && <TextString text={left} />}\n        <CompositionString text={compositionText} />\n        {right && <TextString text={right} />}\n      </>\n    )\n  }\n  // COMPAT: If this is the last text node in an empty block, render a zero-\n  // width space that will convert into a line break when copying and pasting\n  // to support expected plain text.\n  if (\n    leaf.text === '' &&\n    parent.children[parent.children.length - 1] === text &&\n    !editor.isInline(parent) &&\n    Editor.string(editor, parentPath) === ''\n  ) {\n    return <ZeroWidthString isLineBreak />\n  }\n\n  // COMPAT: If the text is empty, it's because it's on the edge of an inline\n  // node, so we render a zero-width space so that the selection can be\n  // inserted next to it still.\n  if (leaf.text === '') {\n    return <ZeroWidthString />\n  }\n\n  // COMPAT: Browsers will collapse trailing new lines at the end of blocks,\n  // so we need to add an extra trailing new lines to prevent that.\n  if (isLast && leaf.text.slice(-1) === '\\n') {\n    return <TextString isTrailing text={leaf.text} />\n  }\n  return <TextString text={leaf.text} />\n}\n\n/**\n * Leaf strings with text in them.\n */\nconst TextString = (props: { text: string; isTrailing?: boolean }) => {\n  const { text, isTrailing = false } = props\n\n  const getTextContent = () => {\n    return `${text ?? ''}${isTrailing ? '\\n' : ''}`\n  }\n\n  return <span {...{ [DATA_EDITABLE_STRING]: true }}>{getTextContent()}</span>\n}\n\nconst CompositionString = (props: { text: string }) => {\n  const { text } = props\n  return <u {...{ [DATA_EDITABLE_COMPOSITION]: true }}>{text}</u>\n}\n\n/**\n * Leaf strings without text, render as zero-width strings.\n */\n\nconst ZeroWidthString = (props: { length?: number; isLineBreak?: boolean }) => {\n  const { length = 0, isLineBreak = false } = props\n  return (\n    <span\n      {...{ [DATA_EDITABLE_ZERO_WIDTH]: isLineBreak ? 'n' : 'z', [DATA_EDITABLE_LENGTH]: length }}\n    >\n      {'\\uFEFF'}\n      {isLineBreak ? <br /> : null}\n    </span>\n  )\n}\n\nexport default String\n","import {\n  Editor,\n  Node,\n  Text,\n  Element,\n  Path,\n  Point,\n  Range,\n  Scrubber,\n  Transforms,\n  SelectionEdge,\n  Key,\n  DOMElement,\n  DOMNode,\n  DOMPoint,\n  DOMRange,\n  DOMSelection,\n  DOMStaticRange,\n  isDOMElement,\n  isDOMSelection,\n  isDOMNode,\n  isDOMText,\n} from '@editablejs/models'\n\nimport {\n  EDITOR_TO_ELEMENT,\n  ELEMENT_TO_NODE,\n  NODE_TO_INDEX,\n  NODE_TO_KEY,\n  NODE_TO_PARENT,\n  EDITOR_TO_WINDOW,\n  EDITOR_TO_KEY_TO_ELEMENT,\n  IS_COMPOSING,\n  NODE_TO_ELEMENT,\n} from '../utils/weak-maps'\nimport { normalizeDOMPoint, hasShadowRoot } from '../utils/dom'\nimport { IS_CHROME, IS_FIREFOX } from '../utils/environment'\nimport findNearbyNodes, { isAlignY } from '../utils/nearby'\nimport { getTextOffset } from '../utils/text'\nimport { getLineRectsByNode, getLineRectsByRange } from '../utils/selection'\nimport { Focused } from '../hooks/use-focused'\nimport { EventHandler, EventType } from './event'\nimport {\n  DATA_EDITABLE_COMPOSITION,\n  DATA_EDITABLE_INLINE,\n  DATA_EDITABLE_LEAF,\n  DATA_EDITABLE_LENGTH,\n  DATA_EDITABLE_NODE,\n  DATA_EDITABLE_PLACEHOLDER,\n  DATA_EDITABLE_STRING,\n  DATA_EDITABLE_VOID,\n  DATA_EDITABLE_ZERO_WIDTH,\n} from '../utils/constants'\nimport { getNativeEvent, isTouch } from '../utils/event'\nimport { ReadOnly } from '../hooks/use-read-only'\nimport scrollIntoView from 'scroll-into-view-if-needed'\n\nexport type BaseAttributes = Omit<React.HTMLAttributes<HTMLElement>, 'children'>\n\nexport interface ElementAttributes<T extends any = any> extends BaseAttributes {\n  [DATA_EDITABLE_NODE]: 'element'\n  [DATA_EDITABLE_INLINE]?: true\n  [DATA_EDITABLE_VOID]?: true\n  dir?: 'rtl'\n  ref: React.MutableRefObject<T>\n}\n\nexport interface TextAttributes extends BaseAttributes {\n  [DATA_EDITABLE_LEAF]?: true\n}\n\nexport type NodeAttributes = ElementAttributes | TextAttributes\n\nexport interface PlaceholderAttributes extends BaseAttributes {\n  [DATA_EDITABLE_PLACEHOLDER]: true\n}\n\nexport interface RenderElementAttributes<T extends Element = Element> {\n  element: T\n  attributes: ElementAttributes\n}\n\nexport interface RenderLeafAttributes<T extends Text = Text> {\n  text: T\n  attributes: TextAttributes\n}\n\n/**\n * `RenderElementProps` are passed to the `renderElement` handler.\n */\nexport interface RenderElementProps<T extends Element = Element, R extends any = any> {\n  children: any\n  element: T\n  attributes: ElementAttributes<R>\n}\n\n/**\n * `RenderLeafProps` are passed to the `renderLeaf` handler.\n */\nexport interface RenderLeafProps<T extends Text = Text> {\n  children: any\n  text: T\n  attributes: TextAttributes\n}\n\nexport interface RenderPlaceholderProps<T extends Node = Node> {\n  children: any\n  attributes: PlaceholderAttributes\n  node: T\n}\n\nexport interface SerializeHtmlOptions {\n  node: Node\n  attributes?: Record<string, any>\n  styles?: Record<string, any>\n}\n\nexport interface DeserializeHtmlOptions {\n  node: DOMNode\n  attributes?: Record<string, any>\n  markAttributes?: Record<string, any>\n  stripBreak?: true | ((text: string) => boolean)\n}\n\nexport interface SelectWordOptions {\n  at?: Range\n  edge?: SelectionEdge\n}\n\n/**\n * A React and DOM-specific version of the `Editor` interface.\n */\nexport interface Editable extends Editor {\n  blur(): void\n  focus(start?: boolean): void\n  copy(range?: Range): void\n  cut(range?: Range): void\n  selectWord: (options?: SelectWordOptions) => void\n  selectLine: (options?: SelectWordOptions) => void\n  insertFromClipboard(at?: Range): void\n  insertTextFromClipboard(at?: Range): void\n  insertFile(file: File, at?: Range): void\n  on: <T extends EventType>(type: T, handler: EventHandler<T>, prepend?: boolean) => void\n  once: <T extends EventType>(type: T, handler: EventHandler<T>, prepend?: boolean) => void\n  off: <T extends EventType>(type: T, handler: EventHandler<T>) => void\n  emit: <T extends EventType>(type: T, ...args: Parameters<EventHandler<T>>) => void\n  onKeydown: (event: KeyboardEvent) => void\n  onKeyup: (event: KeyboardEvent) => void\n  onFocus: () => void\n  onBlur: () => void\n  onPaste: (event: ClipboardEvent) => void\n  onCut: (event: ClipboardEvent) => void\n  onCopy: (event: ClipboardEvent) => void\n  onInput: (value: string) => void\n  onBeforeInput: (value: string) => void\n  onCompositionStart: (value: string) => void\n  onCompositionEnd: (value: string) => void\n  onSelectStart: () => void\n  onSelecting: () => void\n  onSelectEnd: () => void\n  onSelectionChange: () => void\n  onTouchHold: (event: TouchEvent) => void\n  onTouchTrack: () => void\n  onContextMenu: (event: MouseEvent) => void\n  onDestory: () => void\n  renderElementAttributes: (props: RenderElementAttributes) => ElementAttributes\n  renderLeafAttributes: (props: RenderLeafAttributes) => TextAttributes\n  renderElement: (props: RenderElementProps) => JSX.Element\n  renderLeaf: (props: RenderLeafProps) => JSX.Element\n  renderPlaceholder: (props: RenderPlaceholderProps) => JSX.Element | void | null\n  toDataTransfer: (range?: Range) => DataTransfer | null\n}\n\nexport const Editable = {\n  isEditor(value: any): value is Editable {\n    return !!value && Editor.isEditor(value) && 'onSelectionChange' in value\n  },\n  /**\n   * Check if the user is currently composing inside the editor.\n   */\n  isComposing(editor: Editor): boolean {\n    return !!IS_COMPOSING.get(editor)\n  },\n\n  /**\n   * 获取在选区内选中一行内容的节点以及所在行的索引\n   * @param editor\n   * @param options\n   * @returns\n   */\n  getSelectLine(\n    editor: Editor,\n    options: { range?: Range; match?: (element: Element) => boolean } = {},\n  ): [Element, number] | undefined {\n    const { range = editor.selection, match = () => true } = options\n    if (!range || Range.isCollapsed(range)) return\n    const start = Range.start(range)\n    const entry = Editor.above(editor, { at: start, match: n => Editor.isBlock(editor, n) })\n    if (!entry) return\n    const rangeLines = getLineRectsByRange(editor, range)\n    let [block, path] = entry\n    while (block) {\n      if (match(block)) {\n        const elLines = getLineRectsByNode(editor, block)\n        for (const rangeLine of rangeLines) {\n          const index = elLines.findIndex(\n            elLine =>\n              elLine.left === rangeLine.left &&\n              elLine.top === rangeLine.top &&\n              elLine.width === rangeLine.width,\n          )\n          if (~index) {\n            return [block, index]\n          }\n        }\n      }\n      const next = Editor.next(editor, { at: path, match: n => Editor.isBlock(editor, n) })\n      if (!next) return\n      const [n, p] = next\n      block = n as Element\n      path = p\n    }\n    return\n  },\n  /**\n   * 检查选区是否选中在内容一行的开始或者结尾\n   * @param editor\n   * @param options\n   * @returns\n   */\n  isSelectLineEdge(editor: Editor, options: { point?: Point; edge?: SelectionEdge } = {}): boolean {\n    const { point = editor.selection?.focus, edge = 'start' } = options\n    if (!point) return false\n    const entry = Editor.above(editor, { at: point, match: n => Editor.isBlock(editor, n) })\n    if (!entry) return false\n    const [block] = entry\n    const rangeLines = getLineRectsByRange(editor, { anchor: point, focus: point })\n    if (rangeLines.length === 0) return false\n    const rangeLine = rangeLines[0]\n    const lines = getLineRectsByNode(editor, block)\n    for (const line of lines) {\n      if (\n        ~['start', 'anchor'].indexOf(edge) &&\n        line.left === rangeLine.left &&\n        line.top === rangeLine.top\n      ) {\n        return true\n      } else if (\n        ~['end', 'focus'].indexOf(edge) &&\n        line.right === rangeLine.right &&\n        line.top === rangeLine.top\n      ) {\n        return true\n      }\n    }\n    return false\n  },\n\n  /**\n   * Return the host window of the current editor.\n   */\n  getWindow(editor: Editor): Window {\n    const window = EDITOR_TO_WINDOW.get(editor)\n    if (!window) {\n      throw new Error('Unable to find a host window element for this editor')\n    }\n    return window\n  },\n\n  /**\n   * Find a key for a Editor node.\n   */\n\n  findKey(editor: Editor, node: Node): Key {\n    let key = NODE_TO_KEY.get(node)\n\n    if (!key) {\n      key = new Key()\n      NODE_TO_KEY.set(node, key)\n    }\n\n    return key\n  },\n\n  /**\n   * Find the path of Editor node.\n   */\n\n  findPath(editor: Editor, node: Node): Path {\n    const path: Path = []\n    let child = node\n\n    while (true) {\n      const parent = NODE_TO_PARENT.get(child)\n\n      if (parent == null) {\n        if (Editor.isEditor(child)) {\n          return path\n        } else {\n          break\n        }\n      }\n\n      const i = NODE_TO_INDEX.get(child)\n\n      if (i == null) {\n        break\n      }\n\n      path.unshift(i)\n      child = parent\n    }\n\n    throw new Error(`Unable to find the path for Editor node: ${Scrubber.stringify(node)}`)\n  },\n\n  /**\n   * Find the DOM node that implements DocumentOrShadowRoot for the editor.\n   */\n\n  findDocumentOrShadowRoot(editor: Editor): Document | ShadowRoot {\n    const el = Editable.toDOMNode(editor, editor)\n    const root = el.getRootNode()\n\n    if (\n      (root instanceof Document || root instanceof ShadowRoot) &&\n      (root as any).getSelection != null\n    ) {\n      return root\n    }\n\n    return el.ownerDocument\n  },\n\n  /**\n   * Check if the editor is focused.\n   */\n  isFocused(editor: Editor): boolean {\n    return Focused.is(editor)\n  },\n\n  /**\n   * Check if the editor is in read-only mode.\n   */\n\n  isReadOnly(editor: Editor): boolean {\n    return ReadOnly.is(editor)\n  },\n\n  /**\n   * Blur the editor.\n   */\n\n  blur(editor: Editable): void {\n    editor.blur()\n  },\n\n  /**\n   * Focus the editor.\n   */\n  focus(editor: Editable): void {\n    editor.focus()\n  },\n\n  deselect(editor: Editor): void {\n    const { selection } = editor\n    if (selection) {\n      Transforms.deselect(editor)\n    }\n  },\n\n  /**\n   * Check if a DOM node is within the editor.\n   */\n  hasDOMNode(editor: Editor, target: DOMNode): boolean {\n    const editorEl = Editable.toDOMNode(editor, editor)\n    let targetEl\n\n    // COMPAT: In Firefox, reading `target.nodeType` will throw an error if\n    // target is originating from an internal \"restricted\" element (e.g. a\n    // stepper arrow on a number input). (2018/05/04)\n    // https://github.com/ianstormtaylor/slate/issues/1819\n    try {\n      targetEl = (isDOMElement(target) ? target : target.parentElement) as HTMLElement\n    } catch (err: any) {\n      if (!err.message.includes('Permission denied to access property \"nodeType\"')) {\n        throw err\n      }\n    }\n\n    if (!targetEl) {\n      return false\n    }\n\n    return targetEl.closest(`[${DATA_EDITABLE_NODE}=\"editor\"]`) === editorEl\n  },\n\n  /**\n   * Find the native DOM element from a Editor node.\n   */\n\n  toDOMNode(editor: Editor, node: Node): HTMLElement {\n    const KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor)\n    const offsetNode = Editor.isEditor(node)\n      ? EDITOR_TO_ELEMENT.get(editor)\n      : KEY_TO_ELEMENT?.get(Editable.findKey(editor, node))\n\n    if (!offsetNode) {\n      throw new Error(`Cannot resolve a DOM node from Editor node: ${Scrubber.stringify(node)}`)\n    }\n\n    return offsetNode\n  },\n\n  /**\n   * Find a native DOM selection point from a Editor point.\n   */\n  toDOMPoint(editor: Editor, point: Point): DOMPoint {\n    const [node] = Editor.node(editor, point.path)\n    const el = Editable.toDOMNode(editor, node)\n    let domPoint: DOMPoint | undefined\n\n    // If we're inside a void node, force the offset to 0, otherwise the zero\n    // width spacing character will result in an incorrect offset of 1\n    if (Editor.void(editor, { at: point })) {\n      point = { path: point.path, offset: 0 }\n    }\n\n    // For each leaf, we need to isolate its content, which means filtering\n    // to its direct text and zero-width spans. (We have to filter out any\n    // other siblings that may have been rendered alongside them.)\n    const selector = `[${DATA_EDITABLE_STRING}], [${DATA_EDITABLE_COMPOSITION}], [${DATA_EDITABLE_ZERO_WIDTH}]`\n    const texts = Array.from(el.querySelectorAll(selector))\n    let start = 0\n\n    for (const text of texts) {\n      const offsetNode = text.childNodes[0] as HTMLElement\n\n      if (offsetNode == null || offsetNode.textContent == null) {\n        continue\n      }\n\n      const { length } = offsetNode.textContent\n      const attr = text.getAttribute(DATA_EDITABLE_LENGTH)\n      const trueLength = attr == null ? length : parseInt(attr, 10)\n      const end = start + trueLength\n\n      if (point.offset <= end) {\n        const offset = Math.min(length, Math.max(0, point.offset - start))\n        domPoint = [offsetNode, offset]\n        break\n      }\n\n      start = end\n    }\n\n    if (!domPoint) {\n      throw new Error(`Cannot resolve a DOM point from Editor point: ${Scrubber.stringify(point)}`)\n    }\n\n    return domPoint\n  },\n\n  /**\n   * Find a native DOM range from a Editor `range`.\n   *\n   * Notice: the returned range will always be ordinal regardless of the direction of Editor `range` due to DOM API limit.\n   *\n   * there is no way to create a reverse DOM Range using Range.setStart/setEnd\n   * according to https://dom.spec.whatwg.org/#concept-range-bp-set.\n   */\n  toDOMRange(editor: Editor, range: Range): DOMRange {\n    const { anchor, focus } = range\n    const isBackward = Range.isBackward(range)\n    const domAnchor = Editable.toDOMPoint(editor, anchor)\n    const domFocus = Range.isCollapsed(range) ? domAnchor : Editable.toDOMPoint(editor, focus)\n\n    const window = Editable.getWindow(editor)\n    const domRange = window.document.createRange()\n    const [startNode, startOffset] = isBackward ? domFocus : domAnchor\n    const [endNode, endOffset] = isBackward ? domAnchor : domFocus\n\n    // A editor Point at zero-width Leaf always has an offset of 0 but a native DOM selection at\n    // zero-width node has an offset of 1 so we have to check if we are in a zero-width node and\n    // adjust the offset accordingly.\n    const startEl = (isDOMElement(startNode) ? startNode : startNode.parentElement) as HTMLElement\n    const isStartAtZeroWidth = !!startEl.getAttribute(DATA_EDITABLE_ZERO_WIDTH)\n    const endEl = (isDOMElement(endNode) ? endNode : endNode.parentElement) as HTMLElement\n    const isEndAtZeroWidth = !!endEl.getAttribute(DATA_EDITABLE_ZERO_WIDTH)\n\n    domRange.setStart(startNode, isStartAtZeroWidth ? 1 : startOffset)\n    domRange.setEnd(endNode, isEndAtZeroWidth ? 1 : endOffset)\n    return domRange\n  },\n\n  /**\n   * Find a Editor node from a native DOM `element`.\n   */\n  toEditorNode(editor: Editor, offsetNode: DOMNode): Node {\n    let domEl = isDOMElement(offsetNode) ? offsetNode : offsetNode.parentElement\n\n    if (domEl && !domEl.hasAttribute(DATA_EDITABLE_NODE)) {\n      domEl = domEl.closest(`[${DATA_EDITABLE_NODE}]`)\n    }\n\n    const node = domEl ? ELEMENT_TO_NODE.get(domEl as HTMLElement) : null\n\n    if (!node) {\n      throw new Error(`Cannot resolve a Editor node from DOM node: ${domEl}`)\n    }\n\n    return node\n  },\n\n  findLowestDOMElements(editor: Editor, node: Node) {\n    const domNode = Editable.toDOMNode(editor, node)\n    if (Editor.isVoid(editor, node)) return [domNode]\n    const nodes = domNode.querySelectorAll(\n      `[${DATA_EDITABLE_STRING}], [${DATA_EDITABLE_COMPOSITION}], [${DATA_EDITABLE_ZERO_WIDTH}]`,\n    )\n    return Array.from(nodes)\n  },\n\n  findClosestPoint(editor: Editor, domNode: DOMNode, x: number, y: number): Point | null {\n    const domEl = isDOMElement(domNode) ? domNode : domNode.parentElement\n    if (!domEl) return null\n    const elements: DOMElement[] = []\n    let element: DOMElement | null = domEl.hasAttribute(DATA_EDITABLE_NODE)\n      ? domEl\n      : domEl.closest(`[${DATA_EDITABLE_NODE}]`)\n\n    const addToElements = (node: Node) => {\n      if (!NODE_TO_ELEMENT.get(node)) return\n      const children = Editable.findLowestDOMElements(editor, node)\n      for (const child of children) {\n        if (~elements.indexOf(child)) continue\n        elements.push(child)\n      }\n    }\n\n    if (!element) {\n      const nodes = Node.nodes(editor)\n      for (const [node] of nodes) {\n        addToElements(node)\n      }\n    } else {\n      const node = Editable.toEditorNode(editor, element)\n      if (Text.isText(node) || Editor.isVoid(editor, node)) {\n        addToElements(node)\n      } else {\n        if (!Editor.isSolidVoid(editor, node)) {\n          const rect = element.getBoundingClientRect()\n          const reverse = x < rect.left + rect.width / 2\n          const adjacent = (reverse ? Editor.previous : Editor.next)(editor, {\n            at: Editable.findPath(editor, node),\n          })\n          if (adjacent) {\n            addToElements(adjacent[0])\n          }\n        } else {\n          const isGrid = Editor.isGrid(editor, node)\n          const nodes = Editor.nodes(editor, {\n            at: Editable.findPath(editor, node),\n            match: n => (isGrid && Editor.isGridCell(editor, n)) || Text.isText(n),\n            mode: 'highest',\n          })\n          for (const [child] of nodes) {\n            if (Editor.isBlock(editor, child)) {\n              elements.push(Editable.toDOMNode(editor, child))\n            } else addToElements(child)\n          }\n        }\n      }\n    }\n    let top = y,\n      left = x\n    const nodes = findNearbyNodes(elements, x, y)\n    if (!nodes) return null\n    let offsetNode: DOMElement | null = null\n    if (isDOMNode(nodes)) {\n      offsetNode = nodes\n    } else {\n      const { top: nearbyTop, left: nearbyLeft, right: nearbyRight, below: nearbyBelow } = nodes\n\n      if (nearbyLeft && nearbyBelow) {\n        if (isAlignY(nearbyBelow.rect, nearbyLeft.rect)) {\n          offsetNode = nearbyBelow.node\n          top = nearbyBelow.rect.top\n        } else {\n          offsetNode = nearbyLeft.node\n          left = nearbyLeft.rect.right\n        }\n      } else if (nearbyRight && nearbyBelow) {\n        if (isAlignY(nearbyBelow.rect, nearbyRight.rect)) {\n          offsetNode = nearbyBelow.node\n          top = nearbyBelow.rect.top\n        } else {\n          offsetNode = nearbyRight.node\n          left = nearbyRight.rect.left\n        }\n      } else if (nearbyLeft) {\n        offsetNode = nearbyLeft.node\n        if (left <= nearbyLeft.rect.left) left = nearbyLeft.rect.left\n        else if (left >= nearbyLeft.rect.right) left = nearbyLeft.rect.right\n        else {\n          top = nearbyLeft.rect.top\n        }\n      } else if (nearbyRight) {\n        offsetNode = nearbyRight.node\n        if (left <= nearbyRight.rect.left) left = nearbyRight.rect.left\n        else if (left >= nearbyRight.rect.right) left = nearbyRight.rect.right\n        else {\n          top = nearbyRight.rect.top\n        }\n      } else if (nearbyBelow) {\n        if (left < nearbyBelow.rect.left) {\n          left = nearbyBelow.rect.left\n        } else if (left > nearbyBelow.rect.right) {\n          left = nearbyBelow.rect.right\n        }\n        top = nearbyBelow.rect.top\n        offsetNode = nearbyBelow.node\n      } else if (nearbyTop) {\n        offsetNode = nearbyTop.node\n        if (left < nearbyTop.rect.left) {\n          left = nearbyTop.rect.left\n        } else if (left > nearbyTop.rect.right) {\n          left = nearbyTop.rect.right\n        }\n        top = nearbyTop.rect.bottom\n      }\n    }\n    if (!offsetNode) return null\n    const node = Editable.toEditorNode(editor, offsetNode)\n    if (Text.isText(node)) {\n      const path = Editable.findPath(editor, node)\n      if (node.text.length === 0) {\n        return {\n          path,\n          offset: 0,\n        }\n      }\n      const textNodes = Editable.findLowestDOMElements(editor, node)\n      let startOffset = 0\n      for (let s = 0; s < textNodes.length; s++) {\n        const textNode = textNodes[s]\n        if (textNode === offsetNode) break\n        startOffset += (textNode.textContent ?? '').length\n      }\n      const textNode = isDOMText(offsetNode) ? offsetNode : offsetNode.firstChild\n      if (!isDOMText(textNode)) return null\n      const content = textNode.textContent ?? ''\n      const offset = getTextOffset(textNode, left, top, 0, content.length, content.length)\n      return {\n        path,\n        offset: startOffset + offset,\n      }\n    } else if (Element.isElement(node)) {\n      const point = Editable.toEditorPoint(editor, [offsetNode, 0], {\n        exactMatch: false,\n        suppressThrow: true,\n      })\n      if (!point) return Editor.start(editor, Editable.findPath(editor, node))\n      return point\n    }\n    return null\n  },\n  /**\n   * Get the target point from a DOM `event`.\n   */\n  findEventPoint(editor: Editor, event: any): Point | null {\n    event = getNativeEvent(event)\n    const { clientX: x, clientY: y } = event\n\n    if (x == null || y == null) {\n      throw new Error(`Cannot resolve a Editor range from a DOM event: ${event}`)\n    }\n    let target = event.target\n    if (isTouch(event)) {\n      target = document.elementFromPoint(event.clientX, event.clientY)\n    }\n    return Editable.findClosestPoint(editor, target, x, y)\n  },\n\n  findPreviousLinePoint(editor: Editor, at?: Range): Point | null {\n    const { selection } = editor\n    if (!at && selection) at = selection\n    if (!at) return null\n    const startPoint = Range.start(at)\n    const endPoint = Range.end(at)\n    const startRange = Editable.toDOMRange(editor, { anchor: startPoint, focus: startPoint })\n    const endRange = Editable.toDOMRange(editor, { anchor: endPoint, focus: endPoint })\n\n    const startRects = startRange.getClientRects()\n    const endRects = endRange.getClientRects()\n\n    const block = Editor.above(editor, {\n      at: at.focus,\n      match: n => Editor.isBlock(editor, n),\n    })\n    let top = endRects[0].top\n    let isFind = false\n\n    let isSameLine = true\n\n    let prevBlock = block\n    let domBlock: DOMElement | null = null\n    while (prevBlock && !isFind) {\n      const [block, path] = prevBlock\n      domBlock = Editable.toDOMNode(editor, block)\n      const lowestElements = Editable.findLowestDOMElements(editor, block)\n      for (let l = lowestElements.length - 1; l >= 0 && !isFind; l--) {\n        const lowestElement = lowestElements[l]\n        const rects = lowestElement.getClientRects()\n        for (let i = 0; i < rects.length; i++) {\n          const rect = rects[i]\n          if (rect.height === 0) continue\n          if (rect.bottom <= top) {\n            isFind = true\n            top = rect.bottom - rect.height / 2\n            break\n          }\n        }\n      }\n      if (!isFind) {\n        isSameLine = false\n        prevBlock = Editor.previous(editor, {\n          at: path,\n          match: n => Editor.isBlock(editor, n),\n        })\n      }\n    }\n    if (!domBlock) return null\n    return Editable.findClosestPoint(\n      editor,\n      domBlock,\n      isFind && !isSameLine ? startRects[0].x : 0,\n      top,\n    )\n  },\n\n  findLineEdgePoint(\n    editor: Editor,\n    { at, edge = 'start' }: { at?: Range; edge?: 'start' | 'end' } = {},\n  ): Point | null {\n    const { selection } = editor\n    if (!at && selection) at = selection\n    if (!at) return null\n    const isStart = edge === 'start'\n    const point = isStart ? Range.start(at) : Range.end(at)\n    const range = Editable.toDOMRange(editor, {\n      anchor: point,\n      focus: point,\n    })\n    range.collapse(isStart)\n    const rects = range.getClientRects()\n    const rect = rects[rects.length - 1]\n    const bottom = rect.top + rect.height / 2\n    const block = Editor.above(editor, {\n      at: point,\n      match: n => Editor.isBlock(editor, n),\n    })\n    if (!block) return null\n    const domBlock = Editable.toDOMNode(editor, block[0])\n    return Editable.findClosestPoint(editor, domBlock, isStart ? -99999 : 99999, bottom)\n  },\n\n  findNextLinePoint(editor: Editor, at?: Range): Point | null {\n    const { selection } = editor\n    if (!at && selection) at = selection\n    if (!at) return null\n    const startPoint = Range.start(at)\n    const endPoint = Range.end(at)\n    const startRange = Editable.toDOMRange(editor, { anchor: startPoint, focus: startPoint })\n    const endRange = Editable.toDOMRange(editor, { anchor: endPoint, focus: endPoint })\n\n    const startRects = startRange.getClientRects()\n    const endRects = endRange.getClientRects()\n\n    let blockEntry = Editor.above(editor, {\n      at: at.focus,\n      match: n => Editor.isBlock(editor, n),\n    })\n    let bottom = endRects[0].bottom\n    let isFind = false\n    let isSameLine = true\n    let domBlock: DOMElement | null = null\n    while (blockEntry && !isFind) {\n      const [block, path] = blockEntry\n      domBlock = Editable.toDOMNode(editor, block)\n      const lowestElements = Editable.findLowestDOMElements(editor, block)\n      for (let l = 0; l < lowestElements.length && !isFind; l++) {\n        const lowestElement = lowestElements[l]\n        const rects = lowestElement.getClientRects()\n        for (let i = 0; i < rects.length; i++) {\n          const rect = rects[i]\n          if (rect.height === 0) continue\n          if (rect.top >= bottom) {\n            isFind = true\n            bottom = rect.top + rect.height / 2\n            break\n          }\n        }\n      }\n      if (!isFind) {\n        blockEntry = Editor.next(editor, {\n          at: path,\n          match: n => Editor.isBlock(editor, n),\n        })\n        isSameLine = false\n      }\n    }\n    if (!domBlock) return null\n\n    return Editable.findClosestPoint(\n      editor,\n      domBlock,\n      isFind && !isSameLine ? startRects[0].x : 99999,\n      bottom,\n    )\n  },\n\n  findTextOffsetOnLine(editor: Editor, point: Point) {\n    const blockEntry = Editor.above(editor, {\n      match: n => Editor.isBlock(editor, n),\n      at: point,\n    })\n    const data = {\n      text: '',\n      offset: 0,\n    }\n    if (!blockEntry) {\n      throw new Error(`Cannot resolve a Editor block from a point: ${point}`)\n    }\n    const textNodes = Node.texts(blockEntry[0])\n    let isFindOffset = false\n    for (const [textNode, textPath] of textNodes) {\n      let { text } = textNode\n      const path = blockEntry[1].concat(textPath)\n      const [parent] = Editor.parent(editor, path)\n      if (parent && Editor.isVoid(editor, parent)) {\n        text = ''\n      }\n      if (Path.equals(path, point.path)) {\n        data.offset += point.offset\n        isFindOffset = true\n      } else if (!isFindOffset) {\n        data.offset += text.length\n      }\n      data.text += text\n    }\n    return data\n  },\n\n  findPointOnLine(editor: Editor, path: Path, offset: number, moveNext: boolean = false) {\n    const blockEntry = Editor.above(editor, {\n      match: n => Editor.isBlock(editor, n),\n      at: path,\n    })\n    if (!blockEntry) {\n      throw new Error(`Cannot resolve a Editor block from a path: ${path}`)\n    }\n    const textNodes = Node.texts(blockEntry[0])\n    let findOffset = 0\n    for (const [textNode, textPath] of textNodes) {\n      let { text } = textNode\n      const path = blockEntry[1].concat(textPath)\n      const [parent, parentPath] = Editor.parent(editor, path)\n      const isVoid = parent && Editor.isVoid(editor, parent)\n      if (isVoid) {\n        text = ' '\n      }\n      const textLength = text.length\n      const totalOffset = findOffset + textLength\n      if (totalOffset >= offset) {\n        if (moveNext && offset > 0 && totalOffset === offset) {\n          const next = Editor.next(editor, {\n            at: isVoid ? parentPath : path,\n          })\n          if (next) {\n            return {\n              path: next[1],\n              offset: 0,\n            }\n          }\n        }\n        return { path, offset: textLength - (totalOffset - offset) }\n      } else {\n        findOffset += textLength\n      }\n    }\n    return { path, offset }\n  },\n\n  /**\n   * Find a Editor point from a DOM selection's `offsetNode` and `domOffset`.\n   */\n  toEditorPoint<T extends boolean>(\n    editor: Editor,\n    domPoint: DOMPoint,\n    options: {\n      exactMatch: T\n      suppressThrow: T\n    },\n  ): T extends true ? Point | null : Point {\n    const { exactMatch, suppressThrow } = options\n    const [nearestNode, nearestOffset] = exactMatch ? domPoint : normalizeDOMPoint(domPoint)\n    const parentNode = nearestNode.parentNode as DOMElement\n    let textNode: DOMElement | null = null\n    let offset = 0\n\n    if (parentNode) {\n      const editorEl = Editable.toDOMNode(editor, editor)\n      const potentialVoidNode = parentNode.closest(`[${DATA_EDITABLE_VOID}]`)\n      // Need to ensure that the closest void node is actually a void node\n      // within this editor, and not a void node within some parent editor. This can happen\n      // if this editor is within a void node of another editor (\"nested editors\", like in\n      // the \"Editable Voids\" example on the docs site).\n      const voidNode =\n        potentialVoidNode && editorEl.contains(potentialVoidNode) ? potentialVoidNode : null\n      let leafNode = parentNode.closest(`[${DATA_EDITABLE_LEAF}]`)\n      let offsetNode: DOMElement | null = null\n\n      // Calculate how far into the text node the `nearestNode` is, so that we\n      // can determine what the offset relative to the text node is.\n      if (leafNode) {\n        textNode = leafNode.closest(`[${DATA_EDITABLE_NODE}=\"text\"]`)\n\n        if (textNode) {\n          const window = Editable.getWindow(editor)\n          const range = window.document.createRange()\n          range.setStart(textNode, 0)\n          range.setEnd(nearestNode, nearestOffset)\n\n          const contents = range.cloneContents()\n          const removals = [\n            ...Array.prototype.slice.call(\n              contents.querySelectorAll(`[${DATA_EDITABLE_ZERO_WIDTH}]`),\n            ),\n          ]\n\n          removals.forEach(el => {\n            el!.parentNode!.removeChild(el)\n          })\n\n          // COMPAT: Edge has a bug where Range.prototype.toString() will\n          // convert \\n into \\r\\n. The bug causes a loop when slate-react\n          // attempts to reposition its cursor to match the native position. Use\n          // textContent.length instead.\n          // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\n          offset = contents.textContent!.length\n          offsetNode = textNode\n        }\n      } else if (voidNode) {\n        // For void nodes, the element with the offset key will be a cousin, not an\n        // ancestor, so find it by going down from the nearest void parent.\n        leafNode = voidNode.querySelector(`[${DATA_EDITABLE_LEAF}]`)!\n\n        // COMPAT: In read-only editors the leaf is not rendered.\n        if (!leafNode) {\n          offset = 1\n        } else {\n          textNode = leafNode.closest(`[${DATA_EDITABLE_NODE}=\"text\"]`)!\n          offsetNode = leafNode\n          offset = offsetNode.textContent!.length\n          offsetNode.querySelectorAll(`[${DATA_EDITABLE_ZERO_WIDTH}]`).forEach(el => {\n            offset -= el.textContent!.length\n          })\n        }\n      }\n\n      if (\n        offsetNode &&\n        offset === offsetNode.textContent!.length &&\n        // COMPAT: If the parent node is a Editor zero-width space, editor is\n        // because the text node should have no characters. However, during IME\n        // composition the ASCII characters will be prepended to the zero-width\n        // space, so subtract 1 from the offset to account for the zero-width\n        // space character.\n        (parentNode.hasAttribute(DATA_EDITABLE_ZERO_WIDTH) ||\n          // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\\n'\n          // when the document ends with a new-line character. This results in the offset\n          // length being off by one, so we need to subtract one to account for this.\n          (IS_FIREFOX && offsetNode.textContent?.endsWith('\\n\\n')))\n      ) {\n        offset--\n      }\n    }\n\n    if (!textNode) {\n      if (suppressThrow) {\n        return null as T extends true ? Point | null : Point\n      }\n      throw new Error(`Cannot resolve a Editor point from DOM point: ${domPoint}`)\n    }\n\n    // COMPAT: If someone is clicking from one Editor editor into another,\n    // the select event fires twice, once for the old editor's `element`\n    // first, and then afterwards for the correct `element`. (2017/03/03)\n    const editorNode = Editable.toEditorNode(editor, textNode!)\n    const path = Editable.findPath(editor, editorNode)\n    return { path, offset } as T extends true ? Point | null : Point\n  },\n\n  /**\n   * Find a Editor range from a DOM range or selection.\n   */\n  toEditorRange<T extends boolean>(\n    editor: Editor,\n    domRange: DOMRange | DOMStaticRange | DOMSelection,\n    options: {\n      exactMatch: T\n      suppressThrow: T\n    },\n  ): T extends true ? Range | null : Range {\n    const { exactMatch, suppressThrow } = options\n    const el = isDOMSelection(domRange) ? domRange.anchorNode : domRange.startContainer\n    let anchorNode\n    let anchorOffset\n    let focusNode\n    let focusOffset\n    let isCollapsed\n\n    if (el) {\n      if (isDOMSelection(domRange)) {\n        anchorNode = domRange.anchorNode\n        anchorOffset = domRange.anchorOffset\n        focusNode = domRange.focusNode\n        focusOffset = domRange.focusOffset\n        // COMPAT: There's a bug in chrome that always returns `true` for\n        // `isCollapsed` for a Selection that comes from a ShadowRoot.\n        // (2020/08/08)\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n        if (IS_CHROME && hasShadowRoot()) {\n          isCollapsed =\n            domRange.anchorNode === domRange.focusNode &&\n            domRange.anchorOffset === domRange.focusOffset\n        } else {\n          isCollapsed = domRange.isCollapsed\n        }\n      } else {\n        anchorNode = domRange.startContainer\n        anchorOffset = domRange.startOffset\n        focusNode = domRange.endContainer\n        focusOffset = domRange.endOffset\n        isCollapsed = domRange.collapsed\n      }\n    }\n\n    if (anchorNode == null || focusNode == null || anchorOffset == null || focusOffset == null) {\n      throw new Error(`Cannot resolve a Editor range from DOM range: ${domRange}`)\n    }\n\n    const anchor = Editable.toEditorPoint(editor, [anchorNode, anchorOffset], {\n      exactMatch,\n      suppressThrow,\n    })\n    if (!anchor) {\n      return null as T extends true ? Range | null : Range\n    }\n\n    const focus = isCollapsed\n      ? anchor\n      : Editable.toEditorPoint(editor, [focusNode, focusOffset], {\n          exactMatch,\n          suppressThrow,\n        })\n    if (!focus) {\n      return null as T extends true ? Range | null : Range\n    }\n\n    let range: Range = { anchor: anchor as Point, focus: focus as Point }\n    // if the selection is a hanging range that ends in a void\n    // and the DOM focus is an Element\n    // (meaning that the selection ends before the element)\n    // unhang the range to avoid mistakenly including the void\n    if (\n      Range.isExpanded(range) &&\n      Range.isForward(range) &&\n      isDOMElement(focusNode) &&\n      Editor.void(editor, { at: range.focus, mode: 'highest' })\n    ) {\n      range = Editor.unhangRange(editor, range, { voids: true })\n    }\n\n    return range as unknown as T extends true ? Range | null : Range\n  },\n\n  toRelativePosition(editor: Editor, x: number, y: number): [number, number] {\n    const container = Editable.toDOMNode(editor, editor)\n    const rootRect = container.getBoundingClientRect()\n\n    return [x - rootRect.left, y - rootRect.top]\n  },\n\n  reverseRelativePosition(editor: Editor, x: number, y: number): [number, number] {\n    const container = Editable.toDOMNode(editor, editor)\n    const rootRect = container.getBoundingClientRect()\n    return [x + rootRect.left, y + rootRect.top]\n  },\n\n  scrollIntoView(editor: Editor, range = editor.selection) {\n    if (!range) return\n    const domRange = Editable.toDOMRange(editor, range)\n    const focusEl = domRange.endContainer.parentElement!\n    scrollIntoView(focusEl, {\n      scrollMode: 'if-needed',\n    })\n  },\n}\n","import { Ancestor, Editor, Node, Key } from '@editablejs/models'\n\n/**\n * Two weak maps that allow us rebuild a path given a node. They are populated\n * at render time such that after a render occurs we can always backtrack.\n */\n\nexport const NODE_TO_INDEX: WeakMap<Node, number> = new WeakMap()\nexport const NODE_TO_PARENT: WeakMap<Node, Ancestor> = new WeakMap()\n\n/**\n * Weak maps that allow us to go between Slate nodes and DOM nodes. These\n * are used to resolve DOM event-related logic into Slate actions.\n */\nexport const EDITOR_TO_WINDOW: WeakMap<Editor, Window> = new WeakMap()\nexport const EDITOR_TO_ELEMENT: WeakMap<Editor, HTMLElement> = new WeakMap()\nexport const EDITOR_TO_INPUT: WeakMap<Editor, HTMLTextAreaElement> = new WeakMap()\nexport const EDITOR_TO_SHADOW: WeakMap<Editor, ShadowRoot | null> = new WeakMap()\nexport const ELEMENT_TO_NODE: WeakMap<HTMLElement, Node> = new WeakMap()\nexport const NODE_TO_ELEMENT: WeakMap<Node, HTMLElement> = new WeakMap()\nexport const NODE_TO_KEY: WeakMap<Node, Key> = new WeakMap()\nexport const EDITOR_TO_KEY_TO_ELEMENT: WeakMap<Editor, WeakMap<Key, HTMLElement>> = new WeakMap()\nexport const EDITOR_TO_SELECTION_RECTS = new WeakMap<Editor, DOMRect[]>()\n\n/**\n * Weak maps for storing editor-related state.\n */\nexport const IS_CLICKING: WeakMap<Editor, boolean> = new WeakMap()\nexport const IS_COMPOSING: WeakMap<Editor, boolean> = new WeakMap()\nexport const IS_ON_COMPOSITION_END: WeakMap<Editor, boolean> = new WeakMap()\nexport const IS_SHIFT_PRESSED: WeakMap<Editor, boolean> = new WeakMap()\nexport const IS_MOUSEDOWN: WeakMap<Editor, boolean> = new WeakMap()\nexport const IS_TOUCHMOVING: WeakMap<Editor, boolean> = new WeakMap()\nexport const IS_TOUCHING: WeakMap<Editor, boolean> = new WeakMap()\nexport const IS_TOUCH_HOLD: WeakMap<Editor, boolean> = new WeakMap()\n/**\n * Weak map for associating the context `onChange` context with the plugin.\n */\nexport const NODE_TO_RESTORE_DOM = new WeakMap<Node, () => void>()\n\nexport const IS_PASTE_TEXT: WeakMap<Editor, boolean> = new WeakMap()\n","// COMPAT: This is required to prevent TypeScript aliases from doing some very\n// weird things for Slate's types with the same name as globals. (2019/11/27)\nimport {\n  DOMPoint,\n  isDOMElement,\n  DOMElement,\n  DOMNode,\n  isDOMComment,\n  isDOMHTMLElement,\n} from '@editablejs/models'\nimport { Constants } from './constants'\nimport { CAN_USE_DOM } from './environment'\n\n/**\n * Normalize a DOM point so that it always refers to a text node.\n */\n\nexport const normalizeDOMPoint = (domPoint: DOMPoint): DOMPoint => {\n  let [node, offset] = domPoint\n\n  // If it's an element node, its offset refers to the index of its children\n  // including comment nodes, so try to find the right text child node.\n  if (isDOMElement(node) && node.childNodes.length) {\n    let isLast = offset === node.childNodes.length\n    let index = isLast ? offset - 1 : offset\n    ;[node, index] = getEditableChildAndIndex(node, index, isLast ? 'backward' : 'forward')\n    // If the editable child found is in front of input offset, we instead seek to its end\n    isLast = index < offset\n\n    // If the node has children, traverse until we have a leaf node. Leaf nodes\n    // can be either text nodes, or other void DOM nodes.\n    while (isDOMElement(node) && node.childNodes.length) {\n      const i = isLast ? node.childNodes.length - 1 : 0\n      node = getEditableChild(node, i, isLast ? 'backward' : 'forward')\n    }\n\n    // Determine the new offset inside the text node.\n    offset = isLast && node.textContent != null ? node.textContent.length : 0\n  }\n\n  // Return the node and offset.\n  return [node, offset]\n}\n\n/**\n * Determines wether the active element is nested within a shadowRoot\n */\n\nexport const hasShadowRoot = () => {\n  return !!(window.document.activeElement && window.document.activeElement.shadowRoot)\n}\n\n/**\n * Get the nearest editable child and index at `index` in a `parent`, preferring\n * `direction`.\n */\n\nexport const getEditableChildAndIndex = (\n  parent: DOMElement,\n  index: number,\n  direction: 'forward' | 'backward',\n): [DOMNode, number] => {\n  const { childNodes } = parent\n  let child = childNodes[index]\n  let i = index\n  let triedForward = false\n  let triedBackward = false\n\n  // While the child is a comment node, or an element node with no children,\n  // keep iterating to find a sibling non-void, non-comment node.\n  while (isDOMComment(child) || (isDOMElement(child) && child.childNodes.length === 0)) {\n    if (triedForward && triedBackward) {\n      break\n    }\n\n    if (i >= childNodes.length) {\n      triedForward = true\n      i = index - 1\n      direction = 'backward'\n      continue\n    }\n\n    if (i < 0) {\n      triedBackward = true\n      i = index + 1\n      direction = 'forward'\n      continue\n    }\n\n    child = childNodes[i]\n    index = i\n    i += direction === 'forward' ? 1 : -1\n  }\n\n  return [child, index]\n}\n\n/**\n * Get the nearest editable child at `index` in a `parent`, preferring\n * `direction`.\n */\n\nexport const getEditableChild = (\n  parent: DOMElement,\n  index: number,\n  direction: 'forward' | 'backward',\n): DOMNode => {\n  const [child] = getEditableChildAndIndex(parent, index, direction)\n  return child\n}\n\nexport const isEditableDOMElement = (value: any): boolean => {\n  if (isDOMHTMLElement(value)) {\n    return ['INPUT', 'TEXTAREA'].indexOf(value.nodeName) > -1 || value.isContentEditable\n  }\n  return false\n}\n\nexport const canForceTakeFocus = () => {\n  if (!CAN_USE_DOM) return true\n  const activeElement = document.activeElement\n  if (isEditableDOMElement(activeElement)) return false\n  return true\n}\n\nexport const inAbsoluteDOMElement = (value: any): boolean => {\n  if (isDOMHTMLElement(value)) {\n    let node: HTMLElement | null = value\n    while (node) {\n      const attributeNames = node.getAttributeNames()\n      if (attributeNames.some(name => Constants.dataNode === name)) return false\n      const styles = getComputedStyle(node)\n      if (~['absolute', 'fixed'].indexOf(styles.position)) {\n        return true\n      }\n      node = node.parentElement\n    }\n  }\n  return false\n}\n","import * as React from 'react'\n\nexport const IS_REACT_VERSION_17_OR_ABOVE = parseInt(React.version.split('.')[0], 10) >= 17\n\nexport const IS_IOS =\n  typeof navigator !== 'undefined' &&\n  typeof window !== 'undefined' &&\n  /iPad|iPhone|iPod/.test(navigator.userAgent) &&\n  !(window as any).MSStream\n\nexport const IS_APPLE = typeof navigator !== 'undefined' && /Mac OS X/.test(navigator.userAgent)\n\nexport const IS_FIREFOX =\n  typeof navigator !== 'undefined' && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent)\n\nexport const IS_SAFARI =\n  typeof navigator !== 'undefined' && /Version\\/[\\d\\.]+.*Safari/.test(navigator.userAgent)\n\n// \"modern\" Edge was released at 79.x\nexport const IS_EDGE_LEGACY =\n  typeof navigator !== 'undefined' &&\n  /Edge?\\/(?:[0-6][0-9]|[0-7][0-8])(?:\\.)/i.test(navigator.userAgent)\n\nexport const IS_CHROME = typeof navigator !== 'undefined' && /Chrome/i.test(navigator.userAgent)\n\n// Native `beforeInput` events don't work well with react on Chrome 75\n// and older, Chrome 76+ can use `beforeInput` though.\nexport const IS_CHROME_LEGACY =\n  typeof navigator !== 'undefined' &&\n  /Chrome?\\/(?:[0-7][0-5]|[0-6][0-9])(?:\\.)/i.test(navigator.userAgent)\n\n// Firefox did not support `beforeInput` until `v87`.\nexport const IS_FIREFOX_LEGACY =\n  typeof navigator !== 'undefined' &&\n  /^(?!.*Seamonkey)(?=.*Firefox\\/(?:[0-7][0-9]|[0-8][0-6])(?:\\.)).*/i.test(navigator.userAgent)\n\n// qq browser\nexport const IS_QQBROWSER =\n  typeof navigator !== 'undefined' && /.*QQBrowser/.test(navigator.userAgent)\n\n// UC mobile browser\nexport const IS_UC_MOBILE =\n  typeof navigator !== 'undefined' && /.*UCBrowser/.test(navigator.userAgent)\n\n// Wechat browser\nexport const IS_WECHATBROWSER =\n  typeof navigator !== 'undefined' && /.*Wechat/.test(navigator.userAgent)\n\n// Check if DOM is available as React does internally.\n// https://github.com/facebook/react/blob/master/packages/shared/ExecutionEnvironment.js\nexport const CAN_USE_DOM = !!(\n  typeof window !== 'undefined' &&\n  typeof window.document !== 'undefined' &&\n  typeof window.document.createElement !== 'undefined'\n)\n\n// COMPAT: Firefox/Edge Legacy don't support the `beforeinput` event\n// Chrome Legacy doesn't support `beforeinput` correctly\nexport const HAS_BEFORE_INPUT_SUPPORT =\n  !IS_CHROME_LEGACY &&\n  !IS_EDGE_LEGACY &&\n  // globalThis is undefined in older browsers\n  typeof globalThis !== 'undefined' &&\n  globalThis.InputEvent &&\n  // @ts-ignore The `getTargetRanges` property isn't recognized.\n  typeof globalThis.InputEvent.prototype.getTargetRanges === 'function'\n\n/**\n * Touch devices\n */\nexport const isTouchDevice = CAN_USE_DOM && 'ontouchstart' in document.documentElement\n","interface NearbyNode {\n  node: Element\n  rect: DOMRect\n}\n\n/**\n * 是否在一个节点前面\n * @param rect\n * @param node\n * @param otherNode\n * @returns\n */\nexport const isPrecedingY = (rect: DOMRect, node: Node, other: NearbyNode) => {\n  return (\n    rect.bottom > other.rect.bottom ||\n    (rect.top === other.rect.bottom &&\n      node.compareDocumentPosition(other.node) === Node.DOCUMENT_POSITION_PRECEDING)\n  )\n}\n\nexport const isFollowingY = (rect: DOMRect, node: Node, other: NearbyNode) => {\n  return (\n    rect.top < other.rect.top ||\n    (rect.top === other.rect.top &&\n      node.compareDocumentPosition(other.node) === Node.DOCUMENT_POSITION_FOLLOWING)\n  )\n}\n\nexport const isPrecedingX = (rect: DOMRect, node: Node, other: NearbyNode) => {\n  return (\n    rect.right > other.rect.right ||\n    (rect.right === other.rect.right &&\n      node.compareDocumentPosition(other.node) === Node.DOCUMENT_POSITION_PRECEDING)\n  )\n}\n\nexport const isFollowingX = (rect: DOMRect, node: Node, other: NearbyNode) => {\n  return (\n    rect.left < other.rect.left ||\n    (rect.left === other.rect.left &&\n      node.compareDocumentPosition(other.node) === Node.DOCUMENT_POSITION_FOLLOWING)\n  )\n}\n\n/**\n * 是否垂直对齐\n * @param rect\n * @param other\n * @param scale\n * @returns\n */\nexport const isAlignY = (rect: DOMRect, other: DOMRect, scale = 0.4) => {\n  if (rect.bottom === other.bottom) return true\n  // 未在水平上\n  if (rect.top > other.bottom || other.top > rect.bottom) return false\n  const minHeight = Math.min(other.height, rect.height)\n  const innerHeight = Math.min(rect.bottom, other.bottom) - Math.max(rect.top, other.top)\n  // 超过多少比例在水平上\n  return 0 === minHeight || innerHeight / minHeight > scale\n}\n\n/**\n * 判断 x 在 rect 中是否处于 left 与 right 之间\n * @param x\n * @param rect\n * @returns\n */\nexport const isBetweenX = (x: number, rect: DOMRect) => {\n  return x >= rect.left && x <= rect.right\n}\n\n/**\n * 判断 y 在 rect 中是否处于 top 与 bottom 之间\n * @param y\n * @param rect\n * @returns\n */\nexport const isBetweenY = (y: number, rect: DOMRect) => {\n  return y >= rect.top && y <= rect.bottom\n}\n\n/**\n * 获取 x 在 rect 中 left 与 right 之间最小的距离\n * @param x\n * @param rect\n * @returns\n */\nexport const getMinXInRect = (x: number, rect: DOMRect) => {\n  return Math.min(Math.abs(x - rect.left), Math.abs(x - rect.right))\n}\n\nexport const onNearbyY = (\n  x: number,\n  rect: DOMRect,\n  node: Node,\n  nearbyNode: NearbyNode,\n  preceding = true,\n) => {\n  if (isAlignY(rect, nearbyNode.rect)) {\n    const topBetween = isBetweenX(x, nearbyNode.rect)\n    const isBetween = isBetweenX(x, rect)\n    const topMin = getMinXInRect(x, nearbyNode.rect)\n    const min = getMinXInRect(x, rect)\n    if (!topBetween && (isBetween || min < topMin)) {\n      return true\n    }\n    return false\n  } else if (preceding) {\n    return isPrecedingY(rect, node, nearbyNode)\n  } else {\n    return isFollowingY(rect, node, nearbyNode)\n  }\n}\n\ntype NearbyNodes = {\n  top: NearbyNode | null\n  below: NearbyNode | null\n  left: NearbyNode | null\n  right: NearbyNode | null\n}\n\n/**\n * 查找附近的节点\n * @param nodes\n * @param x\n * @param y\n * @returns\n */\nconst findNearbyNodes = (nodes: Element[], x: number, y: number): Element | NearbyNodes | null => {\n  const closerNode: NearbyNodes = {\n    top: null,\n    below: null,\n    left: null,\n    right: null,\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    const child = nodes[i]\n    const rects = child.getClientRects()\n    for (let r = 0; r < rects.length; r++) {\n      const rect = rects[r]\n      // 刚好在区域内\n      if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {\n        return child\n      }\n      // 点击位置在区域 top上方\n      else if (y < rect.top) {\n        if (!closerNode.below || onNearbyY(x, rect, child, closerNode.below, false)) {\n          closerNode.below = {\n            rect,\n            node: child,\n          }\n        }\n      }\n      // 点击区域在 bottom 上方\n      else if (y > rect.bottom) {\n        if (!closerNode.top || onNearbyY(x, rect, child, closerNode.top)) {\n          closerNode.top = {\n            rect,\n            node: child,\n          }\n        }\n        if (closerNode.left && isPrecedingX(rect, child, closerNode.left)) {\n          closerNode.left = {\n            rect,\n            node: child,\n          }\n        }\n      } else if (\n        isBetweenY(y, rect) &&\n        x > rect.left &&\n        (!closerNode.left || isPrecedingX(rect, child, closerNode.left))\n      ) {\n        closerNode.left = {\n          rect,\n          node: child,\n        }\n      } else if (\n        isBetweenY(y, rect) &&\n        x < rect.right &&\n        (!closerNode.right || isFollowingX(rect, child, closerNode.right))\n      ) {\n        closerNode.right = {\n          rect,\n          node: child,\n        }\n      }\n    }\n  }\n  return closerNode\n}\n\nexport default findNearbyNodes\n","import { nextBreak, previousBreak } from '@editablejs/breaker'\n\n/**\n * @zh-CN 获取字符串索引处的向前或向后字符\n * @param text 文本\n * @param offset 索引\n * @param backward 是否取向后的字符，默认 false\n * @returns 字符串索引处的上或下个字符\n */\nexport const getCharFromGraphemeBreaker = (text: string, offset: number, backward = false) => {\n  if (offset < 0 || offset > text.length) {\n    return ''\n  }\n  let value\n  if (backward) {\n    value = previousBreak(text, offset)\n    return text.substring(value, offset)\n  } else {\n    value = nextBreak(text, offset)\n    return text.substring(offset, value)\n  }\n}\n\n/**\n * 获取字符串索引处的向后的字符索引\n * @param text 文本\n * @param offset 索引\n * @returns 向后的字符索引\n */\nexport const getCharOffsetBackward = (text: string, offset: number) => {\n  return getCharFromGraphemeBreaker(text, offset, true).length || 1\n}\n\n/**\n * 获取字符串索引处的向前的字符索引\n * @param text 文本\n * @param offset 索引\n * @returns 向前的字符索引\n */\nexport const getCharOffsetForward = (text: string, offset: number) => {\n  return getCharFromGraphemeBreaker(text, offset).length || 1\n}\n\n/**\n * 字形断路器\n * 获取字符串中的字符范围，Unicode字符范围不确定（高代理、低代理、私有代理字符存在）\n * @param text 文本\n * @param offset 当前索引\n * @returns [start, end]\n */\nexport const getCharRange = (text: string, offset: number) => {\n  let i = 0\n  for (; i <= offset; ) {\n    const end = i + getCharOffsetForward(text, i)\n    if (end > offset) return [i, end]\n    i = end\n  }\n  return [i, i + Math.min(text.length, 1)]\n}\n\nconst isSpace = (char: string) => /\\s/.test(char)\n// http://www.unicode.org/charts/\nconst isIdeograph = (char: string) =>\n  /[\\u3040-\\u30ff\\u3400-\\u4dbf\\u4e00-\\u9fff\\uf900-\\ufaff\\uff66-\\uff9f\\u3131-\\uD79D]/.test(char)\n// http://www.unicode.org/charts/\n// https://zh.wikipedia.org/zh-cn/Unicode%E5%AD%97%E7%AC%A6%E5%88%97%E8%A1%A8\nconst isSpecialCharacters = (char: string) =>\n  /[\\u0021-\\u002F\\u003A-\\u0040\\u005B-\\u0060\\u007B-\\u007E\\u00A1-\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65\\uFFE5]/.test(\n    char,\n  )\n\nconst equalOfCharacterType = (char: string, other: string) => {\n  return (\n    !!char &&\n    !!other &&\n    !isSpace(char) &&\n    !isSpecialCharacters(char) &&\n    !isSpace(other) &&\n    !isSpecialCharacters(other) &&\n    isIdeograph(char) === isIdeograph(other)\n  )\n}\n\ninterface Segment {\n  segment: string\n  index: number\n  input: string\n  isWordLike: boolean\n}\n\ndeclare global {\n  interface Window {\n    Intl: {\n      Segmenter?: new (\n        locale?: string,\n        options?: { granularity: 'word' | 'sentence' | 'line' },\n      ) => {\n        segment: (text: string) => Iterable<Segment>\n      }\n    }\n  }\n}\n\nexport const splitTextOfWord = (text: string, callback?: (segments: Segment[]) => Segment) => {\n  // split word\n  const Segmenter = window.Intl.Segmenter\n  if (Segmenter && isIdeograph(text)) {\n    const segments: Segment[] = Array.from(\n      new Segmenter(undefined, { granularity: 'word' }).segment(text),\n    )\n    if (segments.length > 0) {\n      const { segment, index } = callback ? callback(segments) : segments[segments.length - 1]\n      return { text: segment, offset: index }\n    }\n  }\n  return { text, offset: 0 }\n}\n\nexport const getWordBackward = (text: string, offset: number) => {\n  let currentChar = getCharFromGraphemeBreaker(text, offset, true)\n  let backwardOffset = offset - 1\n  for (; backwardOffset >= 0; ) {\n    const backwardChar = getCharFromGraphemeBreaker(text, backwardOffset, true)\n    if (equalOfCharacterType(currentChar, backwardChar)) {\n      backwardOffset -= backwardChar.length\n    } else break\n  }\n  if (offset - backwardOffset > 1) {\n    const wordText = text.substring(backwardOffset, offset)\n    const { offset: wordOffset } = splitTextOfWord(wordText)\n    backwardOffset += wordOffset\n  }\n  return text.substring(backwardOffset < 0 ? 0 : backwardOffset, offset)\n}\n\nexport const getWordOffsetBackward = (text: string, offset: number) => {\n  return offset - getWordBackward(text, offset).length\n}\n\nexport const getWordForward = (text: string, offset: number) => {\n  let currentChar = getCharFromGraphemeBreaker(text, offset)\n  let forwardOffset = offset + 1\n  for (; forwardOffset < text.length; ) {\n    const forwardChar = getCharFromGraphemeBreaker(text, forwardOffset)\n    if (equalOfCharacterType(currentChar, forwardChar)) {\n      forwardOffset += forwardChar.length\n    } else break\n  }\n  if (forwardOffset - offset > 1) {\n    const newText = text.substring(offset, forwardOffset)\n    const { text: wordText, offset: wordOffset } = splitTextOfWord(newText, segments => segments[0])\n    forwardOffset = offset + wordOffset + wordText.length\n  }\n  return text.substring(offset, forwardOffset > text.length ? text.length : forwardOffset)\n}\n\nexport const getWordOffsetForward = (text: string, offset: number) => {\n  return offset + getWordForward(text, offset).length\n}\n\nexport const getWordRange = (text: string, offset: number) => {\n  if (!text) return [0, 0]\n  offset = Math.min(offset, text.length)\n\n  let previousChar = getCharFromGraphemeBreaker(text, offset, true)\n  let nextChar = getCharFromGraphemeBreaker(text, offset)\n\n  let backwardOffset = offset - 1\n  let forwardOffset = offset + 1\n  if (!nextChar) {\n    return [offset, offset]\n  }\n  if (previousChar && equalOfCharacterType(previousChar, nextChar)) {\n    for (; backwardOffset >= 0; ) {\n      const backwardChar = getCharFromGraphemeBreaker(text, backwardOffset, true)\n      if (equalOfCharacterType(previousChar, backwardChar)) {\n        backwardOffset -= backwardChar.length\n      } else break\n    }\n  } else {\n    backwardOffset = offset\n  }\n\n  for (; forwardOffset < text.length; ) {\n    const forwardChar = getCharFromGraphemeBreaker(text, forwardOffset)\n    if (equalOfCharacterType(nextChar, forwardChar)) {\n      forwardOffset += forwardChar.length\n    } else break\n  }\n  // split word\n  if (forwardOffset - backwardOffset > 1) {\n    const newText = text.substring(backwardOffset, forwardOffset)\n    const { text: wordText, offset: wordOffset } = splitTextOfWord(newText, segments => {\n      for (let i = segments.length - 1; i >= 0; i--) {\n        const segment = segments[i]\n        const wordStart = segment.index + backwardOffset\n        if (offset >= wordStart && offset < wordStart + segment.segment.length) {\n          return segment\n        }\n      }\n      return segments[0]\n    })\n    backwardOffset += wordOffset\n    forwardOffset = wordText.length + backwardOffset\n  }\n  return [backwardOffset, forwardOffset]\n}\n\n/**\n * @zh-CN 获取在Text节点处鼠标点击坐标时的字符索引\n * @param node Text Node\n * @param x\n * @param y\n * @param start\n * @param end\n * @param length\n * @returns\n *\n */\nexport const getTextOffset = (\n  node: Text,\n  x: number,\n  y: number,\n  start: number,\n  end: number,\n  length: number,\n): number => {\n  const range = document.createRange()\n  if (end - start > 1) {\n    const mid = Math.floor((start + end) / 2)\n    try {\n      range.setStart(node, mid)\n      range.setEnd(node, Math.max(Math.min(mid, length), 0))\n    } catch (e) {\n      return start\n    }\n    const rects = range.getClientRects()\n    if (rects.length === 0) {\n      return start\n    }\n    for (const rect of rects) {\n      if (y < rect.top) {\n        return getTextOffset(node, x, y, start, mid, length)\n      } else if (y > rect.bottom) {\n        return getTextOffset(node, x, y, mid, end, length)\n      } else if (x <= rect.left + rect.width) {\n        return getTextOffset(node, x, y, start, mid, length)\n      }\n    }\n    return getTextOffset(node, x, y, mid, end, length)\n  }\n  const [rStart, rEnd] = getCharRange(node.textContent || '', start)\n  try {\n    range.setStart(node, rStart)\n    range.setEnd(node, Math.max(Math.min(rEnd, length), 0))\n  } catch (err) {\n    return rStart\n  }\n  const rects = range.getClientRects()\n  if (rects.length === 0) return rStart\n\n  for (const rect of rects) {\n    if (rect.width === 0) continue\n    if (y < rect.top) {\n      return rStart\n    } else if (y > rect.bottom) {\n      return rEnd\n    } else if (x <= rect.left + rect.width / 2) {\n      return rStart\n    }\n  }\n  return rEnd\n}\n","import {\n  Editor,\n  Node,\n  Range,\n  Element,\n  NodeEntry,\n  Path,\n  DOMElement,\n  DOMRange,\n  isDOMElement,\n} from '@editablejs/models'\nimport { Editable } from '../plugin/editable'\nimport {\n  DATA_EDITABLE_COMPOSITION,\n  DATA_EDITABLE_NODE,\n  DATA_EDITABLE_STRING,\n  DATA_EDITABLE_ZERO_WIDTH,\n} from './constants'\n\ninterface LineRectangle {\n  top: number\n  height: number\n  bottom: number\n  left: number\n  right: number\n}\n\n/**\n * Splits the rectangles into lines based on their positions.\n * @param rects\n */\nconst splitRectsIntoLines = (rects: DOMRect[] | DOMRectList) => {\n  const lines: Map<LineRectangle, DOMRect[]> = new Map()\n  if (rects.length === 0) return lines\n\n  const lineKeys: LineRectangle[] = []\n\n  /**\n   * Finds the line that the rectangle belongs to.\n   * @param rect\n   */\n  const findLineKey = (rect: DOMRect) => {\n    for (const lineKey of lineKeys) {\n      const { right } = lineKey\n      const previousRects = lines.get(lineKey)\n      const lastRect = previousRects\n        ? previousRects\n            .concat()\n            .reverse()\n            .find(p => p.width > 0) ?? previousRects[previousRects.length - 1]\n        : null\n      if (isRectInLine(rect, lineKey) && rect.left <= (lastRect ? lastRect.right : right) + 1) {\n        return lineKey\n      }\n    }\n    return null\n  }\n\n  // Loop through each rectangle and find its line\n  for (let r = 0; r < rects.length; r++) {\n    const rect = rects[r]\n    const key = findLineKey(rect)\n    if (key) {\n      lines.get(key)?.push(rect)\n    } else {\n      const lineRect = {\n        top: rect.top,\n        height: rect.height,\n        bottom: rect.bottom,\n        left: rect.left,\n        right: rect.right,\n      }\n      lines.set(lineRect, [rect])\n      lineKeys.push(lineRect)\n    }\n  }\n\n  // Find the minimum top, maximum bottom, and maximum right for each line\n  for (const [line, rects] of lines) {\n    // If there's only one rectangle in the line, skip\n    if (rects.length === 1) continue\n\n    let minTop = line.top,\n      maxBottom = line.bottom,\n      maxRight = line.right\n\n    // Compare each rectangle\n    for (const rect of rects) {\n      const { top, bottom, right } = rect\n      if (top < minTop) minTop = top\n      if (bottom > maxBottom) maxBottom = bottom\n      if (right > maxRight && rect.width > 0) maxRight = right\n    }\n    line.top = minTop\n    line.bottom = maxBottom\n    line.right = maxRight\n  }\n  return lines\n}\n\n/**\n * Calculates the height of a node based on line height and font size\n * @param el The DOM element to calculate height for\n * @returns The calculated height\n */\nconst calculateElementHeight = (el: DOMElement) => {\n  const { lineHeight, fontSize } = window.getComputedStyle(el)\n\n  // TODO: Handle pt, em, rem units\n\n  let height = 0\n  // Ends with px\n  if (lineHeight.endsWith('px')) {\n    height = parseFloat(lineHeight)\n    return height\n  }\n  // Ends with %\n  else if (lineHeight.endsWith('%')) {\n    height = parseInt(lineHeight, 10) / 100\n  }\n  // Number\n  else if (/^\\d+(\\.\\d+)?$/.test(lineHeight)) {\n    height = parseFloat(lineHeight)\n  } else {\n    return el.getBoundingClientRect().height\n  }\n\n  let size = 0\n  if (fontSize.endsWith('px')) {\n    size = parseInt(fontSize, 10)\n  }\n\n  return height * size\n}\n\n/**\n * Resets the DOMRect of an element to the specified height\n * @param rect The DOMRect to reset\n * @param height The new height for the rect\n * @returns The reset DOMRect\n */\nconst resetElementRect = (rect: DOMRect, height: number) => {\n  const oldHeight = rect.height\n  if (oldHeight >= height) return rect\n  const top = rect.top + (oldHeight - height) / 2\n  return new DOMRect(rect.left, top, rect.width, height)\n}\n\n/**\n * Check if a given DOMRect intersects with a given line defined by its top, bottom, and height values\n * @param {DOMRect} rect - The DOMRect to check\n * @param {Object} line - An object with top, bottom, and height properties representing the line\n * @return {Boolean} - True if the rect intersects with the line, false otherwise\n */\nconst isRectInLine = (rect: DOMRect, line: Record<'top' | 'bottom' | 'height', number>) => {\n  const deltaEdge = rect.height / 3\n  return (\n    // Check if the rect is fully contained within the line\n    (rect.top >= line.top &&\n      (rect.bottom <= line.bottom ||\n        // Check if the top of the rect is in the line and the overflow of the bottom is within 2/3\n        rect.top + deltaEdge < line.bottom ||\n        // Check if the bottom of the rect is within 2/3 from the top of the line and the top of the rect is above the bottom of the line\n        (rect.top <= line.top + line.height / 3 && rect.bottom > line.top))) ||\n    // Check if the rect covers the height of the line and the line is within the top and bottom of the rect\n    (rect.top <= line.top &&\n      (rect.bottom >= line.bottom ||\n        // Check if the top of the rect is above or equal to the top of the line and the bottom of the rect is within 2/3 of the line\n        rect.bottom - deltaEdge > line.top)) ||\n    // Check if the bottom of the rect is within 2/3 from the bottom of the line and the top of the rect is above the bottom of the line\n    (rect.bottom <= line.bottom &&\n      rect.bottom >= line.bottom - line.height / 3 &&\n      rect.top < line.bottom)\n  )\n}\n/**\n * Find the maximum position in the line of the top position in the el node\n * @param editor - The Editor instance\n * @param element - The DOM element\n * @param top - The top position\n * @param bottom - The bottom position\n * @returns - Object containing the line rect information\n */\nconst matchHighest = (editor: Editor, element: DOMElement, top: number, bottom: number) => {\n  const lineRect = {\n    top,\n    height: bottom - top,\n    bottom,\n  }\n\n  /**\n   * Compare the height of the current rect with the line rect\n   * and update the line rect with the highest values\n   * @param rect - The current rect\n   */\n  const compareHeight = (rect: DOMRect) => {\n    if (isRectInLine(rect, lineRect)) {\n      const newTop = lineRect.top < rect.top ? lineRect.top : rect.top\n      const newBottom = lineRect.bottom > rect.bottom ? lineRect.bottom : rect.bottom\n      lineRect.height = newBottom - newTop\n      lineRect.top = newTop\n      lineRect.bottom = newBottom\n    }\n  }\n\n  /**\n   * Recursively find the child nodes of the element and compare their rects\n   * @param element - The DOM element\n   */\n  const match = (element: DOMElement) => {\n    for (const child of element.childNodes) {\n      if (isDOMElement(child)) {\n        const hasNode = child.hasAttribute(DATA_EDITABLE_NODE)\n        const node = hasNode ? Editable.toEditorNode(editor, child) : null\n        if (node) {\n          if (Element.isElement(node)) {\n            if (editor.isVoid(node)) {\n              const rect = resetElementRect(\n                child.getBoundingClientRect(),\n                calculateElementHeight(child),\n              )\n              compareHeight(rect)\n            } else if (editor.isInline(node)) {\n              const height = calculateElementHeight(child)\n              const rects = child.getClientRects()\n              for (let r = 0; r < rects.length; r++) {\n                const rect = resetElementRect(rects[r], height)\n                compareHeight(rect)\n              }\n            } else {\n              match(child)\n            }\n          } else {\n            const nodes = child.querySelectorAll(\n              `[${DATA_EDITABLE_STRING}], [${DATA_EDITABLE_COMPOSITION}], [${DATA_EDITABLE_ZERO_WIDTH}]`,\n            )\n            nodes.forEach(node => {\n              const height = calculateElementHeight(node)\n              const rects = node.getClientRects()\n              for (let r = 0; r < rects.length; r++) {\n                const rect = resetElementRect(rects[r], height)\n                compareHeight(rect)\n              }\n            })\n          }\n        } else {\n          match(child)\n        }\n      }\n    }\n  }\n\n  match(element)\n  return lineRect\n}\n/**\n * Get the line rectangles of a given node in an editor.\n * @param editor The editor instance.\n * @param node The node to get line rectangles of.\n * @param minWidth The minimum width of the line rectangles. Default value is 4.\n * @returns An array of DOMRect objects representing the line rectangles.\n */\nexport const getLineRectsByNode = (editor: Editor, node: Node, minWidth = 4) => {\n  const path = Editable.findPath(editor, node)\n  const block: NodeEntry | undefined =\n    Editor.isBlock(editor, node) && path.length === 1\n      ? [node, path]\n      : Editor.above<Element>(editor, {\n          at: path,\n          match: n => Editor.isBlock(editor, n),\n          mode: 'highest',\n        })\n  if (!block) return []\n  const domEl = Editable.toDOMNode(editor, block[0])\n  const domRect = domEl.getBoundingClientRect()\n  const range = document.createRange()\n  range.selectNodeContents(Editable.toDOMNode(editor, node))\n  const lines = splitRectsIntoLines(range.getClientRects())\n  const lineRects: DOMRect[] = []\n  for (const [line, rects] of lines) {\n    let width = line.right - line.left\n    const lineRect = matchHighest(editor, domEl, line.top, line.bottom)\n    line.top = lineRect.top\n    line.height = lineRect.height\n    line.bottom = lineRect.bottom\n    // 空节点的宽度给个最小值\n    if (width < 1 && domRect.left === rects[0].left) {\n      width = minWidth\n    }\n    lineRects.push(new DOMRect(rects[0].left, line.top, width, line.height))\n  }\n  return lineRects\n}\n\n/**\n * Get DOMRect objects split by line within range\n * @param editor\n * @param range\n * @param minWidth minimum width of empty node, default to 4\n * @returns array of DOMRect objects\n */\nexport const getLineRectsByRange = (editor: Editor, range: Range, minWidth = 4) => {\n  const anchor = Range.start(range)\n  const focus = Range.end(range)\n  // 开始位置的 block节点\n  const anchorEntry = Editor.above<Element>(editor, {\n    at: anchor,\n    match: n => Editor.isBlock(editor, n),\n    mode: 'lowest',\n  })\n  // 结束位置的 block 节点\n  const focusEntry = Editor.above<Element>(editor, {\n    at: focus,\n    match: n => Editor.isBlock(editor, n),\n    mode: 'lowest',\n  })\n  if (!anchorEntry || !focusEntry) return []\n\n  const blockRects: DOMRect[] = []\n  const rectMap: Map<\n    DOMRect,\n    {\n      dom: DOMElement\n      element: Element\n    }\n  > = new Map()\n\n  let [startBlock, startPath] = anchorEntry\n  let [_, endPath] = focusEntry\n  const ranges: DOMRange[] = []\n  let isStart = true\n  let next: NodeEntry<Element> | undefined = anchorEntry\n  while (next) {\n    const [nextBlock, nextPath] = next as NodeEntry<Element>\n    const element = Editable.toDOMNode(editor, nextBlock)\n    const rect = element.getBoundingClientRect()\n    rectMap.set(rect, {\n      dom: element,\n      element: nextBlock,\n    })\n    blockRects.push(rect)\n\n    if (Path.equals(nextPath, endPath)) break\n    if (!isStart) {\n      const range = document.createRange()\n      range.selectNodeContents(element)\n      ranges.push(range)\n    } else {\n      isStart = false\n    }\n    next = Editor.next<Element>(editor, {\n      at: nextPath,\n      match: n => Editor.isBlock(editor, n),\n    })\n  }\n  if (Path.equals(startPath, endPath)) {\n    ranges.unshift(Editable.toDOMRange(editor, range))\n  } else {\n    ranges.unshift(\n      Editable.toDOMRange(editor, {\n        anchor,\n        focus: Editor.end(editor, {\n          path: startPath,\n          offset: startBlock.children.length,\n        }),\n      }),\n    )\n    ranges.push(\n      Editable.toDOMRange(editor, {\n        anchor: Editor.start(editor, {\n          path: endPath,\n          offset: 0,\n        }),\n        focus,\n      }),\n    )\n  }\n\n  // 拆分的行\n  const rects: DOMRect[] = []\n  for (const range of ranges) {\n    rects.push(...range.getClientRects())\n  }\n  const lines = splitRectsIntoLines(rects)\n  const lineRects: DOMRect[] = []\n  let prevLineRect: DOMRect | null = null\n  for (const [line, rects] of lines) {\n    // 找到对应行所在的 element\n    const blockRect = blockRects.find(\n      r =>\n        isRectInLine(r, line) &&\n        (line.left >= r.left || Math.abs(line.left - r.left) < 1) &&\n        (line.right <= r.right || Math.abs(line.right - r.right) < 1),\n    )\n    const block = blockRect ? rectMap.get(blockRect) : null\n\n    let width = line.right - line.left\n    if (block) {\n      const { dom, element } = block\n      const lineRect = matchHighest(editor, dom, line.top, line.bottom)\n      line.top = lineRect.top\n      line.height = lineRect.height\n      // 空节点的宽度给个最小值\n      if (\n        dom &&\n        Editor.isEmpty(editor, element) &&\n        width < 1 &&\n        dom.getBoundingClientRect().left === line.left\n      ) {\n        width = minWidth\n      }\n    }\n    // 去除行与行直接多余覆盖部分\n    if (prevLineRect && prevLineRect.bottom > line.top) {\n      const diffVal = prevLineRect.bottom - line.top\n      line.top += diffVal\n      line.height -= diffVal\n    }\n    const lineRect = new DOMRect(rects[0].left, line.top, width, line.height)\n\n    prevLineRect = lineRect\n    lineRects.push(lineRect)\n  }\n  return lineRects\n}\n","import { Editor } from '@editablejs/models'\nimport create, { StoreApi, UseBoundStore, useStore } from 'zustand'\nimport { Editable } from '../plugin/editable'\nimport { useEditableStatic } from './use-editable'\n\ninterface FocusedStore {\n  isFocused: boolean\n}\n\nconst EDITABLE_TO_FOCUSED_STORE = new WeakMap<Editor, UseBoundStore<StoreApi<FocusedStore>>>()\n\nconst getStore = (editor: Editor) => {\n  let store = EDITABLE_TO_FOCUSED_STORE.get(editor)\n  if (!store) {\n    store = create<FocusedStore>(() => ({\n      isFocused: false,\n    }))\n    EDITABLE_TO_FOCUSED_STORE.set(editor, store)\n    store.subscribe(({ isFocused }) => {\n      if (!Editable.isEditor(editor)) return\n\n      if (isFocused) {\n        editor.onFocus()\n      } else {\n        editor.onBlur()\n      }\n    })\n  }\n\n  return store\n}\n\nexport const useFocused = (): [boolean, (isFocused: boolean) => void] => {\n  const editor = useEditableStatic()\n  const store = getStore(editor)\n  const isFocused = useStore(store, state => state.isFocused)\n\n  return [\n    isFocused,\n    (isFocused: boolean) => {\n      store.setState({ isFocused })\n    },\n  ]\n}\n\nexport const Focused = {\n  is: (editor: Editor) => {\n    const store = getStore(editor)\n    return store.getState().isFocused\n  },\n}\n","export const composeEventHandlers = <E>(\n  originalEventHandler?: (event: E) => void,\n  ourEventHandler?: (event: E) => void,\n  { checkForDefaultPrevented = true } = {},\n) => {\n  return function handleEvent(event: E) {\n    originalEventHandler?.(event)\n\n    if (checkForDefaultPrevented === false || !(event as unknown as Event).defaultPrevented) {\n      return ourEventHandler?.(event)\n    }\n  }\n}\n\nexport const isTouchEvent = (event: any): event is TouchEvent => {\n  return typeof window.TouchEvent !== 'undefined' && event instanceof TouchEvent\n}\n\nexport const isTouch = (event: any): event is Touch => {\n  return typeof window.Touch !== 'undefined' && event instanceof Touch\n}\n\nexport const isMouseEvent = (event: any): event is MouseEvent => {\n  return event instanceof MouseEvent\n}\n\nexport const getNativeEvent = (event: any) => {\n  const { nativeEvent } = event\n  event = nativeEvent ?? event\n  if (isTouchEvent(event)) {\n    return event.touches[0] || event.changedTouches[0]\n  }\n  return event\n}\n","import { Editor } from '@editablejs/models'\nimport create, { StoreApi, UseBoundStore, useStore } from 'zustand'\nimport { useEditableStatic } from './use-editable'\n\ninterface ReadOnlyStore {\n  isReadOnly: boolean\n}\n\nconst EDITABLE_TO_FOCUSED_STORE = new WeakMap<Editor, UseBoundStore<StoreApi<ReadOnlyStore>>>()\n\nconst getStore = (editor: Editor) => {\n  let store = EDITABLE_TO_FOCUSED_STORE.get(editor)\n  if (!store) {\n    store = create<ReadOnlyStore>(() => ({\n      isReadOnly: false,\n    }))\n    EDITABLE_TO_FOCUSED_STORE.set(editor, store)\n  }\n\n  return store\n}\n\nexport const useReadOnly = (): [boolean, (isReadOnly: boolean) => void] => {\n  const editor = useEditableStatic()\n  const store = getStore(editor)\n  const isReadOnly = useStore(store, state => state.isReadOnly)\n\n  return [\n    isReadOnly,\n    (isReadOnly: boolean) => {\n      store.setState({ isReadOnly })\n    },\n  ]\n}\n\nexport const ReadOnly = {\n  is: (editor: Editor) => {\n    const store = getStore(editor)\n    return store.getState().isReadOnly\n  },\n}\n","import * as React from 'react'\nimport { CAN_USE_DOM } from '../utils/environment'\n\n/**\n * Prevent warning on SSR by falling back to useEffect when DOM isn't available\n */\n\nexport const useIsomorphicLayoutEffect = CAN_USE_DOM ? React.useLayoutEffect : React.useEffect\n","import * as React from 'react'\nimport { Text, Path, Range, Element } from '@editablejs/models'\nimport { useStore } from 'zustand'\nimport { Decorate, ElementDecorate, getDecorateStore, TextDecorate } from '../plugin/decorate'\nimport { useEditableStatic } from './use-editable'\n\nexport const useDecorateStore = () => {\n  const editor = useEditableStatic()\n  return React.useMemo(() => {\n    return getDecorateStore(editor)\n  }, [editor])\n}\n\nexport const useTextDecorations = (text: Text, path: Path) => {\n  const store = useDecorateStore()\n  const decorations = useStore(store, state => state.decorations)\n  return React.useMemo(() => {\n    return decorations.reduce<{ decorate: TextDecorate; ranges: Range[] }[]>((acc, decorate) => {\n      if (!Decorate.isTextDecorate(decorate)) return acc\n      const ranges = decorate.match(text, path)\n      if (ranges.length > 0) {\n        acc.push({ decorate, ranges })\n      }\n      return acc\n    }, [])\n  }, [decorations, text, path])\n}\n\nexport const useElementDecorations = (element: Element, path: Path) => {\n  const store = useDecorateStore()\n  const decorations = useStore(store, state => state.decorations)\n  return React.useMemo(() => {\n    return decorations.reduce<ElementDecorate[]>((acc, decorate) => {\n      if (Decorate.isTextDecorate(decorate)) return acc\n      if (decorate.match(element, path)) {\n        acc.push(decorate)\n      }\n      return acc\n    }, [])\n  }, [decorations, element, path])\n}\n","// Import necessary dependencies and models from @editablejs\nimport * as React from 'react'\nimport { Editor, Range, Node, Path, Text, Element } from '@editablejs/models'\n\n// Import the create and StoreApi from zustand\nimport create, { StoreApi, UseBoundStore } from 'zustand'\n\n// Define interface for properties passed to the render function of a text decoration\nexport interface DecorateRenderProps<T = Node> {\n  node: T\n  path: Path\n  children: React.ReactElement\n}\n\n// Define BaseDecorate interface with a key property that is optional\nexport interface BaseDecorate {\n  key?: string\n}\n\n// Define TextDecorate interface with match and renderText functions\nexport interface TextDecorate extends BaseDecorate {\n  match: (node: Text, path: Path) => Range[]\n  renderText: (props: DecorateRenderProps<Text>) => React.ReactElement\n}\n\n// Define ElementDecorate interface with match and renderElement functions\nexport interface ElementDecorate extends BaseDecorate {\n  match: (node: Element, path: Path) => boolean\n  renderElement: (props: DecorateRenderProps<Element>) => React.ReactElement\n}\n\n// Define a type for decorations which can either be a TextDecorate or an ElementDecorate\nexport type Decorate = TextDecorate | ElementDecorate\n\n// Define DecorateStore interface with decorations property\nexport interface DecorateStore {\n  decorations: Decorate[]\n}\n\n// Define a WeakMap to store Editor instances and their associated decoration stores\nconst EDITOR_TO_DECORATE_STORE = new WeakMap<Editor, UseBoundStore<StoreApi<DecorateStore>>>()\n\n// Function to retrieve the decoration store for a given Editor instance\nexport const getDecorateStore = (editor: Editor) => {\n  let store = EDITOR_TO_DECORATE_STORE.get(editor)\n  if (!store) {\n    store = create<DecorateStore>(() => ({\n      decorations: [],\n    }))\n    EDITOR_TO_DECORATE_STORE.set(editor, store)\n  }\n  return store\n}\n\n// Helper function to determine if a decoration is specified by its key or by its reference\nconst predicate = (decorate: Decorate | string) => {\n  const isKey = typeof decorate === 'string'\n  return (d: Decorate) => {\n    return isKey ? d.key === decorate : d === decorate\n  }\n}\n\n// Object to handle adding, removing, and checking the presence of decorations in a given Editor instance\nexport const Decorate = {\n  // Check if a given value is a TextDecorate\n  isTextDecorate: (value: any): value is TextDecorate => {\n    return value && typeof value.match === 'function' && typeof value.renderText === 'function'\n  },\n\n  // Add a decoration to the decorations array of a given Editor instance\n  create: (editor: Editor, decorate: Decorate) => {\n    const store = getDecorateStore(editor)\n    store.setState(state => ({\n      decorations: [...state.decorations, decorate],\n    }))\n  },\n\n  // Remove\n  remove: (editor: Editor, decorate: Decorate | string) => {\n    const store = getDecorateStore(editor)\n    store.setState(state => ({\n      decorations: state.decorations.filter(d => !predicate(decorate)(d)),\n    }))\n  },\n\n  has: (editor: Editor, decorate: Decorate | string) => {\n    const store = getDecorateStore(editor)\n    return store.getState().decorations.some(predicate(decorate))\n  },\n}\n","import * as React from 'react'\nimport { Editor, Node } from '@editablejs/models'\nimport { useStore } from 'zustand'\nimport { Placeholder } from '../plugin/placeholder'\nimport { useEditableStatic } from './use-editable'\nimport { useIsomorphicLayoutEffect } from './use-isomorphic-layout-effect'\nimport { Editable } from '../plugin/editable'\n\nexport const usePlaceholderStore = () => {\n  const editor = useEditableStatic()\n  return React.useMemo(() => {\n    return Placeholder.getStore(editor)\n  }, [editor])\n}\n\nexport const usePlaceholders = () => {\n  const store = usePlaceholderStore()\n  const placeholders = useStore(store, state => state.placeholders)\n  return placeholders\n}\n\nexport const usePlaceholder = (node: Node) => {\n  const editor = useEditableStatic()\n  const store = usePlaceholderStore()\n  const actives = useStore(store, state => state.actives)\n  useIsomorphicLayoutEffect(() => {\n    if (Editor.isEmpty(editor, node)) {\n      Placeholder.update(editor, [node, Editable.findPath(editor, node)])\n      return () => {\n        store.setState(({ actives }) => {\n          return {\n            actives: actives.filter(d => d.entry[0] !== node),\n          }\n        })\n      }\n    }\n  }, [store, node, editor])\n\n  return React.useMemo(() => {\n    return actives.find(d => d.entry[0] === node)?.render\n  }, [actives, node])\n}\n","import * as React from 'react'\nimport { Editor, Node, NodeEntry, Range } from '@editablejs/models'\nimport create, { UseBoundStore, StoreApi } from 'zustand'\nimport { Editable } from './editable'\n\nexport interface RenderPlaceholderProps {\n  node: Node\n}\nexport type PlaceholderRender = (props: RenderPlaceholderProps) => React.ReactNode\n\nexport type PlaceholderSubscribe = (entry: NodeEntry) => PlaceholderRender | void\n\nconst PLACEHOLDER_IS_ALONE = new WeakMap<PlaceholderSubscribe, boolean>()\nexport interface ActivePlaceholder {\n  entry: NodeEntry\n  alone: boolean\n  render: PlaceholderRender\n  placeholder: PlaceholderSubscribe\n}\n\nexport interface PlaceholderStore {\n  placeholders: PlaceholderSubscribe[]\n  actives: ActivePlaceholder[]\n}\n\nconst EDITOR_TO_PLACEHOLDER_STORE = new WeakMap<\n  Editable,\n  UseBoundStore<StoreApi<PlaceholderStore>>\n>()\n\nconst getPlaceholderStore = (editor: Editable) => {\n  let store = EDITOR_TO_PLACEHOLDER_STORE.get(editor)\n  if (!store) {\n    store = create<PlaceholderStore>(() => ({\n      placeholders: [],\n      actives: [],\n    }))\n    EDITOR_TO_PLACEHOLDER_STORE.set(editor, store)\n  }\n  return store\n}\n\nexport const Placeholder = {\n  getStore: getPlaceholderStore,\n\n  isAlone: (fn: PlaceholderSubscribe) => {\n    return PLACEHOLDER_IS_ALONE.get(fn) ?? false\n  },\n\n  subscribe: (editor: Editable, fn: PlaceholderSubscribe, alone = false) => {\n    const store = getPlaceholderStore(editor)\n    PLACEHOLDER_IS_ALONE.set(fn, alone)\n\n    store.setState(state => ({\n      placeholders: [...state.placeholders.filter(d => d !== fn), fn],\n    }))\n\n    return () => {\n      store.setState(state => ({\n        placeholders: state.placeholders.filter(d => d !== fn),\n      }))\n      PLACEHOLDER_IS_ALONE.delete(fn)\n    }\n  },\n\n  update: (editor: Editable, entry: NodeEntry) => {\n    const store = getPlaceholderStore(editor)\n    const state = store.getState()\n    let render: PlaceholderRender | null = null\n    let placeholder: PlaceholderSubscribe | null = null\n    const aloneActive = state.actives.find(d => d.alone && d.entry[0] === entry[0])\n    if (aloneActive) {\n      const r = aloneActive.placeholder(entry)\n      if (r) {\n        render = r\n        placeholder = aloneActive.placeholder\n      }\n    }\n    // 没有以编辑器为placeholder的情况下，才会去找其他的placeholder\n    else {\n      const hasEditorPlaceholder = state.actives.some(d => d.entry[0] === editor)\n      const placeholders = state.placeholders.sort(a => (Placeholder.isAlone(a) ? 1 : 0))\n      for (let i = placeholders.length - 1; i >= 0; i--) {\n        placeholder = placeholders[i]\n        if (!Placeholder.isAlone(placeholder) && hasEditorPlaceholder) continue\n        const r = placeholder(entry)\n        if (r) {\n          render = r\n          break\n        }\n      }\n    }\n\n    const actives = state.actives.filter(d => {\n      if (!d.alone || (d.entry[0] === entry[0] && render)) return false\n      return Editor.isEmpty(editor, d.entry[0])\n    })\n\n    if (render && placeholder) {\n      actives.push({\n        entry,\n        alone: Placeholder.isAlone(placeholder),\n        render,\n        placeholder,\n      })\n    }\n    store.setState({ actives })\n    return render\n  },\n\n  refresh: (editor: Editable) => {\n    const isReadOnly = Editable.isReadOnly(editor)\n    const store = getPlaceholderStore(editor)\n    if (isReadOnly) {\n      store.setState({ actives: [] })\n    } else if (Editor.isEmpty(editor, editor)) {\n      Placeholder.update(editor, [editor, []])\n    } else if (editor.selection && Range.isCollapsed(editor.selection)) {\n      const nodes = Editor.nodes(editor, {\n        at: editor.selection,\n      })\n      for (const entry of nodes) {\n        if (Editor.isEmpty(editor, entry[0])) {\n          return Placeholder.update(editor, entry)\n        }\n      }\n      store.setState(({ actives }) => {\n        return {\n          actives: actives.filter(d => {\n            if (!d.alone) return false\n            return Editor.isEmpty(editor, d.entry[0])\n          }),\n        }\n      })\n    } else {\n      store.setState(({ actives }) => ({\n        actives: actives.filter(d => d.alone),\n      }))\n    }\n  },\n}\n","import * as React from 'react'\n\nexport const NodeSelectedContext = React.createContext<boolean>(false)\n\n/**\n * Get the current `selected` state of an element.\n */\nexport const useNodeSelected = (): boolean => {\n  return React.useContext(NodeSelectedContext)\n}\n","import * as React from 'react'\n\nexport const NodeFocusedContext = React.createContext<boolean>(false)\n\n/**\n * Get the current `focused` state of an element.\n */\nexport const useNodeFocused = (): boolean => {\n  return React.useContext(NodeFocusedContext)\n}\n","import * as React from 'react'\nimport { Grid } from '@editablejs/models'\n\nexport const GridContext = React.createContext<Grid | null>(null)\n\nexport const useGrid = (): Grid | null => {\n  return React.useContext(GridContext)\n}\n","import * as React from 'react'\n\nimport { cancellablePromise, useCancellablePromises } from './use-cancellable-promises'\n\nconst useMultipleClick = (options: {\n  onClick?: (event: React.MouseEvent) => void\n  onMultipleClick: (event: React.MouseEvent, count: number) => boolean | void\n}) => {\n  const { onClick, onMultipleClick } = options\n  const api = useCancellablePromises()\n  const pointRef = React.useRef<{ x: number; y: number }>()\n  const countRef = React.useRef(0)\n\n  const isSamePoint = (event: React.MouseEvent | MouseEvent | Touch) => {\n    const point = pointRef.current\n    return point\n      ? Math.abs(event.clientY - point.y) < 10 && Math.abs(event.clientX - point.x) < 10\n      : false\n  }\n\n  const clear = () => {\n    api.clearPendingPromises()\n    pointRef.current = undefined\n  }\n\n  const handleMultipleClick = (event: React.MouseEvent) => {\n    if (event.button === 2) return\n    const point = pointRef.current\n    if (point) {\n      if (isSamePoint(event)) {\n        api.clearPendingPromises()\n        countRef.current += 1\n        if (onMultipleClick(event, countRef.current) === false) {\n          clear()\n          return\n        }\n      } else {\n        clear()\n      }\n    } else {\n      countRef.current = 1\n      pointRef.current = {\n        x: event.clientX,\n        y: event.clientY,\n      }\n    }\n    if (countRef.current === 1 && onMultipleClick(event, 1) === false) {\n      clear()\n    } else {\n      const waitForClick = cancellablePromise(api.delay(500))\n      api.appendPendingPromise(waitForClick)\n      return waitForClick.promise\n        .then(() => {\n          api.removePendingPromise(waitForClick)\n          if (onClick) onClick(event)\n          pointRef.current = undefined\n        })\n        .catch(errorInfo => {\n          api.removePendingPromise(waitForClick)\n          if (!errorInfo.isCanceled) {\n            throw errorInfo.error\n          }\n        })\n    }\n  }\n\n  return { handleMultipleClick, isSamePoint }\n}\n\nexport { useMultipleClick }\n","import * as React from 'react'\n\nexport interface CellablePromise<T> {\n  promise: Promise<T>\n  cancel: () => void\n}\n\nconst cancellablePromise = <T>(promise: Promise<T>) => {\n  let isCanceled = false\n\n  const wrappedPromise = new Promise((resolve, reject) => {\n    promise.then(\n      value => (isCanceled ? reject({ isCanceled, value }) : resolve(value)),\n      error => reject({ isCanceled, error }),\n    )\n  })\n\n  return {\n    promise: wrappedPromise,\n    cancel: () => (isCanceled = true),\n  }\n}\n\nconst noop = () => {}\n\nconst delay = (n: number) => new Promise(resolve => setTimeout(resolve, n))\n\nconst useCancellablePromises = <T>() => {\n  const pendingPromises = React.useRef<CellablePromise<T>[]>([])\n\n  const appendPendingPromise = (promise: CellablePromise<T>) =>\n    (pendingPromises.current = [...pendingPromises.current, promise])\n\n  const removePendingPromise = (promise: CellablePromise<T>) =>\n    (pendingPromises.current = pendingPromises.current.filter(p => p !== promise))\n\n  const clearPendingPromises = () => pendingPromises.current.map(p => p.cancel())\n\n  const api = {\n    pendingPromises,\n    appendPendingPromise,\n    removePendingPromise,\n    clearPendingPromises,\n    delay,\n    noop,\n  }\n\n  return api\n}\n\nexport { useCancellablePromises, cancellablePromise }\n","import * as React from 'react'\nimport ReactDOM from 'react-dom'\nimport { useIsomorphicLayoutEffect } from '../hooks/use-isomorphic-layout-effect'\n\nexport interface ShadowRect {\n  left: number\n  top: number\n  width: number\n  height: number\n  color?: string\n  style?: React.CSSProperties\n}\n\ntype ShadowBlockProps = {\n  rect: ShadowRect\n} & React.HTMLAttributes<HTMLDivElement>\n\nexport const ShadowBlockDefault: React.FC<ShadowBlockProps & React.RefAttributes<HTMLDivElement>> =\n  React.forwardRef<HTMLDivElement, ShadowBlockProps>(({ children, rect, style, ...props }, ref) => (\n    <div\n      ref={ref}\n      style={{\n        position: 'absolute',\n        top: rect.top,\n        left: rect.left,\n        width: rect.width,\n        height: rect.height,\n        // 数值为单数的情况下，两组重合位置会有阴影\n        // transform: `translateX(${rect.left || 0}px) translateY(${rect.top || 0}px)`,\n        opacity: 1,\n        backgroundColor: `${rect.color || 'transparent'}`,\n        zIndex: 1,\n        ...style,\n      }}\n      {...props}\n    >\n      {children}\n    </div>\n  ))\n\nShadowBlockDefault.displayName = 'ShadowBlock'\n\nexport const ShadowBlock = React.memo(ShadowBlockDefault, (prev, next) => {\n  return (\n    prev.rect.left === next.rect.left &&\n    prev.rect.top === next.rect.top &&\n    prev.rect.width === next.rect.width &&\n    prev.rect.height === next.rect.height &&\n    prev.rect.color === next.rect.color &&\n    prev.children === next.children\n  )\n})\n\ninterface ShadowContainerProps {\n  children?: React.ReactNode\n}\n\nconst ShadowContainer: React.FC<ShadowContainerProps & React.RefAttributes<ShadowRoot>> =\n  React.forwardRef<ShadowRoot, ShadowContainerProps>(({ children }, ref) => {\n    const [root, setRoot] = React.useState<ShadowRoot>()\n    const containerRef = React.useRef<HTMLDivElement>(null)\n\n    useIsomorphicLayoutEffect(() => {\n      if (!containerRef.current || containerRef.current.shadowRoot) return\n      const root = containerRef.current.attachShadow({ mode: 'open' })\n      setRoot(root)\n    }, [])\n\n    React.useImperativeHandle(ref, () => root!, [root])\n\n    return (\n      <div ref={containerRef} style={{ position: 'absolute', zIndex: 2, top: 0, left: 0 }}>\n        {root &&\n          ReactDOM.createPortal(<div style={{ pointerEvents: 'none' }}>{children}</div>, root)}\n      </div>\n    )\n  })\n\nShadowContainer.displayName = 'Shadow'\n\nexport default ShadowContainer\n","import * as React from 'react'\nimport { Range } from '@editablejs/models'\nimport { useEditableStatic } from '../hooks/use-editable'\nimport { useFocused } from '../hooks/use-focused'\nimport { useIsomorphicLayoutEffect } from '../hooks/use-isomorphic-layout-effect'\nimport { IS_MOUSEDOWN } from '../utils/weak-maps'\nimport {\n  useSelectionDrawingEnabled,\n  useSelectionDrawingRects,\n  useSelectionDrawingSelection,\n  useSelectionDrawingStyle,\n} from '../hooks/use-selection-drawing'\nimport { isTouchDevice } from '../utils/environment'\nimport { useReadOnly } from '../hooks/use-read-only'\nimport { ShadowBlock } from './shadow'\n\ninterface CaretProps {\n  timeout?: number | false\n}\n\nconst CaretComponent: React.FC<CaretProps> = React.memo(({ timeout = 530 }) => {\n  const editor = useEditableStatic()\n\n  const [focused] = useFocused()\n\n  const timer = React.useRef<number>()\n\n  const ref = React.useRef<HTMLDivElement>(null)\n\n  const [readOnly] = useReadOnly()\n\n  const enabled = useSelectionDrawingEnabled()\n  const selection = useSelectionDrawingSelection()\n  const rects = useSelectionDrawingRects()\n  const style = useSelectionDrawingStyle()\n\n  const caretWidth = isTouchDevice ? style.touchWidth : style.caretWidth\n  const caretColor = isTouchDevice ? style.touchColor : style.caretColor\n\n  const rect = React.useMemo(() => {\n    if (!selection || rects.length === 0 || !focused || !Range.isCollapsed(selection)) return null\n    return rects[0].toJSON()\n  }, [focused, rects, selection])\n\n  const clearActive = React.useCallback(() => {\n    clearTimeout(timer.current)\n  }, [])\n\n  const setOpacity = (opacity?: number) => {\n    const elRef = ref.current\n    if (elRef) {\n      elRef.style.opacity =\n        opacity !== undefined ? String(opacity) : elRef.style.opacity === '1' ? '0' : '1'\n    }\n  }\n\n  const active = React.useCallback(\n    (opacity?: number) => {\n      clearActive()\n      if (!rect || timeout === false) return\n      if (IS_MOUSEDOWN.get(editor)) {\n        setOpacity(1)\n      } else {\n        setOpacity(opacity)\n      }\n      timer.current = setTimeout(() => {\n        active()\n      }, timeout)\n    },\n    [clearActive, editor, rect, timeout],\n  )\n\n  useIsomorphicLayoutEffect(() => {\n    if (readOnly) {\n      clearActive()\n    } else active(1)\n    return () => clearActive()\n  }, [editor, readOnly, active, clearActive])\n\n  if (!enabled || readOnly) return null\n\n  return (\n    <ShadowBlock\n      rect={\n        rect\n          ? Object.assign({}, rect, { width: caretWidth, color: caretColor })\n          : { width: 0, height: 0, top: 0, left: 0 }\n      }\n      ref={ref}\n      style={{ willChange: 'opacity, transform', opacity: rect ? 1 : 0 }}\n    />\n  )\n})\nCaretComponent.displayName = 'CaretComponent'\nexport { CaretComponent }\n","import * as React from 'react'\nimport { useStore } from 'zustand'\nimport { SelectionDrawing } from '../plugin/selection-drawing'\nimport { EDITOR_TO_SELECTION_RECTS } from '../utils/weak-maps'\nimport { useEditableStatic } from './use-editable'\nimport { useIsomorphicLayoutEffect } from './use-isomorphic-layout-effect'\n\nexport const useSelectionDrawingStore = () => {\n  const editor = useEditableStatic()\n  return React.useMemo(() => {\n    return SelectionDrawing.getStore(editor)\n  }, [editor])\n}\n\nexport const useSelectionDrawingStyle = () => {\n  const store = useSelectionDrawingStore()\n  return useStore(store, state => state.style)\n}\n\nexport const useSelectionDrawingSelection = () => {\n  const store = useSelectionDrawingStore()\n  return useStore(store, state => state.selection)\n}\n\nexport const useSelectionDrawingRects = () => {\n  const editor = useEditableStatic()\n  const selection = useSelectionDrawingSelection()\n  const [rects, setRects] = React.useState<DOMRect[]>([])\n  useIsomorphicLayoutEffect(() => {\n    const rects = selection ? SelectionDrawing.toRects(editor, selection) : []\n    EDITOR_TO_SELECTION_RECTS.set(editor, rects)\n    setRects(rects)\n  }, [editor, selection])\n\n  return rects\n}\n\nexport const useSelectionDrawingEnabled = () => {\n  const store = useSelectionDrawingStore()\n  return useStore(store, state => state.enabled)\n}\n","import create, { StoreApi, UseBoundStore } from 'zustand'\nimport { Selection, Range, Editor } from '@editablejs/models'\nimport { getLineRectsByRange } from '../utils/selection'\nimport { Editable } from './editable'\n\nexport interface SelectionDrawingStyle {\n  /**\n   * 拖蓝聚焦颜色\n   */\n  focusColor?: string\n  /**\n   * 拖蓝失焦颜色\n   */\n  blurColor?: string\n  /**\n   * 光标颜色\n   */\n  caretColor?: string\n  /**\n   * 光标宽度\n   */\n  caretWidth?: number\n  /**\n   * 拖拽光标的颜色\n   */\n  dragColor?: string\n  /**\n   * 触摸光标的颜色\n   */\n  touchColor?: string\n  /**\n   * 触摸光标的宽度\n   */\n  touchWidth?: number\n}\n\nexport interface SelectionDrawingStore {\n  style: SelectionDrawingStyle\n  selection: Selection | null\n  enabled: boolean\n}\n\nconst EDITOR_TO_SELECTION_DRAWING_STORE = new WeakMap<\n  Editor,\n  UseBoundStore<StoreApi<SelectionDrawingStore>>\n>()\n\nconst getStore = (editor: Editor) => {\n  let store = EDITOR_TO_SELECTION_DRAWING_STORE.get(editor)\n  if (!store) {\n    store = create<SelectionDrawingStore>(() => ({\n      style: {\n        focusColor: 'rgba(0,127,255,0.3)',\n\n        blurColor: 'rgba(136, 136, 136, 0.3)',\n\n        caretColor: '#000',\n\n        caretWidth: 1,\n\n        dragColor: 'rgb(37, 99, 235)',\n\n        touchWidth: 2,\n\n        touchColor: 'rgb(37, 99, 235)',\n      },\n      selection: null,\n      rects: null,\n      enabled: true,\n    }))\n    EDITOR_TO_SELECTION_DRAWING_STORE.set(editor, store)\n  }\n  return store\n}\n\nexport const SelectionDrawing = {\n  getStore,\n\n  setStyle: (editor: Editor, style: Partial<SelectionDrawingStyle>) => {\n    const store = getStore(editor)\n    store.setState(state => ({ ...state, style }))\n  },\n\n  setSelection: (editor: Editor, selection: Selection | null) => {\n    const store = getStore(editor)\n    store.setState(state => ({ ...state, selection }))\n  },\n\n  setEnabled: (editor: Editor, enabled: boolean) => {\n    const store = getStore(editor)\n    store.setState(state => ({ ...state, enabled }))\n  },\n\n  toRects(editor: Editor, range: Range, relative = true) {\n    let rects: DOMRect[] = []\n    if (Range.isCollapsed(range)) {\n      const domRange = Editable.toDOMRange(editor, range)\n      const clientRects = domRange.getClientRects()\n      if (clientRects.length > 1) {\n        rects = [clientRects[clientRects.length - 1]]\n      } else {\n        rects = [domRange.getBoundingClientRect()]\n      }\n    } else {\n      rects = getLineRectsByRange(editor, range)\n    }\n\n    return relative\n      ? rects.map(r => {\n          const [x, y] = Editable.toRelativePosition(editor, r.left, r.top)\n          r.x = x\n          r.y = y\n          return r\n        })\n      : rects\n  },\n}\n","import * as React from 'react'\nimport { Range } from '@editablejs/models'\nimport { useFocused } from '../hooks/use-focused'\nimport {\n  useSelectionDrawingSelection,\n  useSelectionDrawingRects,\n  useSelectionDrawingEnabled,\n  useSelectionDrawingStyle,\n} from '../hooks/use-selection-drawing'\nimport { ShadowBlock } from './shadow'\nimport { isTouchDevice } from '../utils/environment'\n\ninterface SelectionProps {}\n\nconst SelectionComponent: React.FC<SelectionProps> = () => {\n  const selection = useSelectionDrawingSelection()\n  const rects = useSelectionDrawingRects()\n  const enabled = useSelectionDrawingEnabled()\n  const style = useSelectionDrawingStyle()\n  const [focused] = useFocused()\n  if (!enabled || !selection || Range.isCollapsed(selection)) return null\n\n  return (\n    <>\n      {rects.map((rect, index) => {\n        return (\n          <ShadowBlock\n            key={`sel-${index}`}\n            rect={Object.assign({}, rect.toJSON(), {\n              color: isTouchDevice || focused ? style.focusColor : style.blurColor,\n            })}\n          />\n        )\n      })}\n    </>\n  )\n}\n\nexport { SelectionComponent }\n","import { Range } from '@editablejs/models'\nimport * as React from 'react'\nimport { Editable } from '../plugin/editable'\nimport {\n  EDITOR_TO_INPUT,\n  IS_COMPOSING,\n  IS_MOUSEDOWN,\n  IS_PASTE_TEXT,\n  IS_TOUCHING,\n} from '../utils/weak-maps'\nimport { useFocused } from '../hooks/use-focused'\nimport { ShadowBlock, ShadowRect } from './shadow'\nimport { useIsomorphicLayoutEffect } from '../hooks/use-isomorphic-layout-effect'\nimport { useEditableStatic } from '../hooks/use-editable'\nimport {\n  useSelectionDrawingSelection,\n  useSelectionDrawingRects,\n} from '../hooks/use-selection-drawing'\nimport { ReadOnly, useReadOnly } from '../hooks/use-read-only'\nimport { composeEventHandlers } from '../utils/event'\nimport { useEffect } from 'react'\n\ninterface InputProps {\n  autoFocus?: boolean\n}\n\nconst InputComponent: React.FC<InputProps> = ({ autoFocus }) => {\n  const editor = useEditableStatic()\n  const inputRef = React.useRef<HTMLTextAreaElement>(null)\n  const [focused, setFocused] = useFocused()\n  const [readOnly] = useReadOnly()\n\n  const [rect, setRect] = React.useState<ShadowRect | null>(null)\n\n  useIsomorphicLayoutEffect(() => {\n    if (inputRef.current) EDITOR_TO_INPUT.set(editor, inputRef.current)\n    return () => {\n      EDITOR_TO_INPUT.delete(editor)\n    }\n  }, [editor])\n\n  useEffect(() => {\n    if (autoFocus) {\n      editor.focus()\n      Editable.scrollIntoView(editor)\n    }\n  }, [editor, autoFocus])\n\n  const handleKeydown = (event: React.KeyboardEvent) => {\n    const { nativeEvent } = event\n    if (Editable.isComposing(editor) && nativeEvent.isComposing === false) {\n      IS_COMPOSING.set(editor, false)\n    }\n\n    if (event.defaultPrevented || Editable.isComposing(editor)) {\n      return\n    }\n    editor.onKeydown(nativeEvent)\n  }\n\n  const handleKeyup = (event: React.KeyboardEvent) => {\n    const { nativeEvent } = event\n    editor.onKeyup(nativeEvent)\n  }\n\n  const handleBlur = () => {\n    if (!IS_MOUSEDOWN.get(editor) && !IS_TOUCHING.get(editor)) setFocused(false)\n  }\n\n  const handleFocus = () => {\n    setFocused(true)\n  }\n\n  const handleBeforeInput = (event: React.FormEvent<HTMLTextAreaElement>) => {\n    const textarea = event.target\n    if (!(textarea instanceof HTMLTextAreaElement)) return\n    const { value } = textarea\n    editor.onBeforeInput(value)\n  }\n\n  const handleInput = (event: React.FormEvent<HTMLTextAreaElement>) => {\n    const textarea = event.target\n    if (!(textarea instanceof HTMLTextAreaElement)) return\n    const value = textarea.value\n    if (!IS_COMPOSING.get(editor)) {\n      textarea.value = ''\n    }\n    editor.onInput(value)\n  }\n\n  const handleCompositionStart = (ev: React.CompositionEvent) => {\n    const { data } = ev.nativeEvent\n    editor.onCompositionStart(data)\n  }\n\n  const handleCompositionEnd = (event: React.CompositionEvent) => {\n    const textarea = event.target\n    if (!(textarea instanceof HTMLTextAreaElement)) return\n    const value = textarea.value\n    textarea.value = ''\n    editor.onCompositionEnd(value)\n  }\n\n  const handlePaste = (event: React.ClipboardEvent) => {\n    composeEventHandlers(\n      (event: React.ClipboardEvent) => {\n        if (ReadOnly.is(editor)) {\n          event.preventDefault()\n        }\n      },\n      event => {\n        const { nativeEvent } = event\n        const isPasteText = IS_PASTE_TEXT.get(editor)\n        event.preventDefault()\n        const e = new ClipboardEvent(isPasteText ? 'pasteText' : 'paste', nativeEvent)\n        editor.onPaste(e)\n      },\n    )(event)\n  }\n\n  const selection = useSelectionDrawingSelection()\n  const rects = useSelectionDrawingRects()\n\n  useIsomorphicLayoutEffect(() => {\n    if (!selection || !focused || rects.length === 0) return setRect(null)\n    if (Range.isCollapsed(selection)) {\n      setRect(rects[0].toJSON())\n    } else {\n      const rect = rects[rects.length - 1].toJSON()\n      rect.left = rect.left + rect.width\n      return setRect(rect)\n    }\n  }, [focused, rects, selection])\n\n  return (\n    <ShadowBlock\n      rect={Object.assign({}, rect, { color: 'transparent', width: 1 })}\n      style={{ opacity: 0, outline: 'none', caretColor: 'transparent', overflow: 'hidden' }}\n    >\n      <textarea\n        ref={inputRef}\n        rows={1}\n        style={{\n          fontSize: 'inherit',\n          lineHeight: 1,\n          padding: 0,\n          border: 'none',\n          whiteSpace: 'nowrap',\n          width: '1em',\n          overflow: 'auto',\n          resize: 'vertical',\n        }}\n        readOnly={readOnly}\n        onKeyDown={handleKeydown}\n        onKeyUp={handleKeyup}\n        onBeforeInput={handleBeforeInput}\n        onInput={handleInput}\n        onCompositionStart={handleCompositionStart}\n        onCompositionEnd={handleCompositionEnd}\n        onBlur={handleBlur}\n        onFocus={handleFocus}\n        onPaste={handlePaste}\n      />\n    </ShadowBlock>\n  )\n}\n\nexport { InputComponent }\n","import * as React from 'react'\nimport { useEditableStatic } from './use-editable'\nimport { Drag, DragStore } from '../plugin/drag'\nimport { useStore } from 'zustand'\n\nexport const useDragStore = () => {\n  const editor = useEditableStatic()\n  const store = React.useMemo(() => {\n    return Drag.getStore(editor)\n  }, [editor])\n  return store\n}\n\n/**\n * 是否拖拽中\n * @returns\n */\nexport const useDragging = () => {\n  const store = useDragStore()\n\n  const drag = useStore(store, state => state.drag !== null)\n\n  return React.useMemo(() => drag, [drag])\n}\n\nexport const useDragType = () => {\n  const store = useDragStore()\n\n  const type = useStore(store, state => state.drag?.type ?? null)\n\n  return React.useMemo(() => type, [type])\n}\n\n/**\n * 拖拽到的目标\n * @returns\n */\nexport const useDragTo = () => {\n  const store = useDragStore()\n  const drag = useStore(store, state => state.drag)\n\n  return React.useMemo(() => drag?.to ?? null, [drag])\n}\n\n/**\n * 当前拖拽的鼠标位置\n * @returns\n */\nexport const useDragPosition = () => {\n  const store = useDragStore()\n  const drag = useStore(store, state => state.drag)\n\n  return React.useMemo(() => drag?.position ?? null, [drag])\n}\n\n/**\n * 当前拖拽的数据\n * @returns\n */\nexport const useDragData = () => {\n  const store = useDragStore()\n  const drag = useStore(store, state => state.drag)\n\n  return React.useMemo(() => drag?.data ?? 0, [drag])\n}\n\nexport const useDragMethods = () => {\n  const editor = useEditableStatic()\n\n  const setDrag = React.useCallback(\n    (drag: Partial<DragStore['drag']>) => {\n      Drag.setDrag(editor, drag)\n    },\n    [editor],\n  )\n\n  const getDrag = React.useCallback(() => {\n    return Drag.getDrag(editor)\n  }, [editor])\n\n  return React.useMemo(() => ({ setDrag, getDrag }), [setDrag, getDrag])\n}\n","import create, { StoreApi, UseBoundStore } from 'zustand'\nimport { Editor, Range, Element, Path, Selection } from '@editablejs/models'\nimport { Editable } from './editable'\n\nexport interface DragStore {\n  drag: {\n    type: 'block' | 'text'\n    /**\n     * 拖拽的开始位置\n     */\n    from: Range | Path\n    /**\n     * 拖拽到目标位置\n     */\n    to: Selection | Path\n    /**\n     * 拖拽的数据\n     */\n    data: DataTransfer\n    /**\n     * 当前鼠标位置\n     */\n    position: Record<'x' | 'y', number>\n  } | null\n}\n\nconst EDITOR_TO_DRAG_STORE = new WeakMap<Editor, UseBoundStore<StoreApi<DragStore>>>()\n\nconst getDragStore = (editor: Editor) => {\n  let store = EDITOR_TO_DRAG_STORE.get(editor)\n  if (!store) {\n    store = create<DragStore>(() => ({\n      drag: null,\n    }))\n    EDITOR_TO_DRAG_STORE.set(editor, store)\n  }\n  return store\n}\n\n/**\n * 拖拽相关状态操作\n */\nexport const Drag = {\n  getStore: getDragStore,\n\n  getDrag: (editor: Editor) => {\n    const store = getDragStore(editor)\n    const { drag } = store.getState()\n    return drag\n  },\n\n  setDrag: (editor: Editor, drag: Partial<DragStore['drag']>) => {\n    const store = getDragStore(editor)\n    store.setState(state => {\n      return {\n        drag: drag === null ? null : Object.assign({}, state.drag, drag),\n      }\n    })\n  },\n\n  clear: (editor: Editor) => {\n    const store = getDragStore(editor)\n    store.setState({ drag: null })\n  },\n\n  toBlockPath: (editor: Editor) => {\n    const drag = Drag.getDrag(editor)\n    if (!drag || drag.type !== 'block') return\n    const { to, position } = drag\n    if (!to) return\n    const entry = Editor.above(editor, {\n      at: Path.isPath(to) ? to : to.focus,\n      match: n => Element.isElement(n),\n      mode: 'lowest',\n    })\n    if (!entry) return\n    const element = Editable.toDOMNode(editor, entry[0])\n    const rect = element.getBoundingClientRect()\n    const { y, height } = rect\n    const { y: pY } = position\n    if (pY > y + height / 2) {\n      return Path.next(entry[1])\n    } else {\n      return entry[1]\n    }\n  },\n}\n","import * as React from 'react'\nimport { Editor, Element, Path, GridCell } from '@editablejs/models'\nimport { useDragPosition, useDragTo, useDragType } from '../hooks/use-drag'\nimport { useEditableStatic } from '../hooks/use-editable'\nimport { useSelectionDrawingStyle } from '../hooks/use-selection-drawing'\nimport { Editable } from '../plugin/editable'\nimport { SelectionDrawing } from '../plugin/selection-drawing'\nimport { ShadowBlock } from './shadow'\n\nexport const DragCaretComponent = React.memo(() => {\n  const editor = useEditableStatic()\n  const dragTo = useDragTo()\n  const dragType = useDragType()\n  const dragPosition = useDragPosition()\n  const rects = React.useMemo(() => {\n    if (!dragTo || !dragPosition) return null\n    if (dragType === 'block') {\n      const entry = Editor.above(editor, {\n        at: dragTo,\n        match: n => Element.isElement(n),\n        mode: 'lowest',\n      })\n      if (!entry) return null\n      const element = Editable.toDOMNode(editor, entry[0])\n      const rect = element.getBoundingClientRect()\n      let { x, y } = rect\n      const { height, width } = rect\n      const { y: pY } = dragPosition\n      const space = 1\n      // bottom\n      if (pY > y + height / 2) {\n        y += height + space\n      }\n      // find previous sibling\n      else {\n        const previous = Editor.previous(editor, {\n          at: entry[1],\n          match: (n, p) => {\n            if (!Element.isElement(n)) return false\n            const gridCell = GridCell.find(editor, entry[1])\n            if (!gridCell) return true\n            const matchCell = GridCell.find(editor, p)\n            if (!matchCell) return false\n\n            return Path.equals(gridCell[1], matchCell[1])\n          },\n          mode: 'lowest',\n        })\n        if (previous) {\n          const previousElement = Editable.toDOMNode(editor, previous[0])\n          const previousRect = previousElement.getBoundingClientRect()\n          y = previousRect.y + previousRect.height + space\n        } else {\n          y -= space\n        }\n      }\n      const [rx, ry] = Editable.toRelativePosition(editor, x, y)\n      return [new DOMRect(rx, ry, width, 2)]\n    }\n\n    return SelectionDrawing.toRects(editor, Editor.range(editor, dragTo))\n  }, [dragPosition, dragTo, dragType, editor])\n\n  const { dragColor, caretWidth } = useSelectionDrawingStyle()\n  if (!rects || rects.length === 0) return null\n  if (dragType === 'block') {\n    return (\n      <ShadowBlock\n        rect={Object.assign({}, rects[0].toJSON(), {\n          color: dragColor,\n        })}\n      />\n    )\n  }\n  return (\n    <ShadowBlock\n      rect={Object.assign({}, rects[0].toJSON(), {\n        width: caretWidth,\n        color: dragColor,\n      })}\n    />\n  )\n})\n\nDragCaretComponent.displayName = 'DragCaretComponent'\n","import React from 'react'\nimport { useSlotComponents } from '../hooks/use-slot'\n\nexport const Slots = React.memo(() => {\n  const slots = useSlotComponents()\n  return (\n    <>\n      {slots.map(({ component: Component, props }, index) => (\n        <Component key={index} {...props} />\n      ))}\n    </>\n  )\n})\nSlots.displayName = 'Slots'\n","import React from 'react'\nimport { useStore } from 'zustand'\nimport shallow from 'zustand/shallow'\nimport { Slot } from '../plugin/solt'\nimport { useEditableStatic } from './use-editable'\n\nexport const useSlotStore = () => {\n  const editor = useEditableStatic()\n  return React.useMemo(() => Slot.getStore(editor), [editor])\n}\n\nexport const useSlotComponents = () => {\n  const store = useSlotStore()\n  return useStore(store, state => state.components, shallow)\n}\n\nexport const useSlotActive = (component: React.FC) => {\n  const components = useSlotComponents()\n  const editor = useEditableStatic()\n  const slot = components.find(c => c.component === component)\n  return React.useMemo(() => {\n    return [\n      slot?.props.active ?? false,\n      (active: boolean) => {\n        Slot.update(editor, { active }, c => c === component)\n      },\n    ] as const\n  }, [editor, slot, component])\n}\n","import merge from 'lodash.merge'\nimport * as React from 'react'\nimport create, { StoreApi, UseBoundStore } from 'zustand'\nimport { Editor } from '@editablejs/models'\n\nexport interface SlotComponentProps {\n  active?: boolean\n}\n\nexport interface SlotState<T extends SlotComponentProps> {\n  component: React.FC\n  props: T\n}\n\nexport interface SlotStore<T extends SlotComponentProps> {\n  components: SlotState<T>[]\n}\n\nconst EDITOR_TO_SLOTS_STORE = new WeakMap<\n  Editor,\n  UseBoundStore<StoreApi<SlotStore<SlotComponentProps>>>\n>()\n\nconst getStore = (editor: Editor) => {\n  let store = EDITOR_TO_SLOTS_STORE.get(editor)\n  if (!store) {\n    store = create<SlotStore<SlotComponentProps>>(() => ({\n      components: [],\n    }))\n    EDITOR_TO_SLOTS_STORE.set(editor, store)\n  }\n  return store\n}\n\nexport const Slot = {\n  getStore,\n\n  mount<T extends SlotComponentProps>(editor: Editor, component: React.FC<T>, props: T = {} as T) {\n    const store = getStore(editor)\n    store.setState(state => {\n      const { components } = state\n      if (components.some(c => c.component === component)) return state\n      return {\n        components: [...components, { component, props } as SlotState<T>],\n      }\n    })\n  },\n\n  unmount(editor: Editor, component: React.FC) {\n    const store = getStore(editor)\n    store.setState(state => {\n      const { components } = state\n      if (!components.some(c => c.component === component)) return state\n      return {\n        components: components.filter(c => c.component !== component),\n      }\n    })\n  },\n\n  update: <T extends SlotComponentProps>(\n    editor: Editor,\n    props: Partial<T>,\n    predicate: (value: React.FC<T>, index: number) => boolean = () => true,\n  ) => {\n    const store = getStore(editor)\n    store.setState(state => {\n      const { components } = state\n      return {\n        components: components.map((c, index) => {\n          if (!predicate(c.component, index)) return c\n          return { ...c, props: merge(c.props, props) }\n        }),\n      }\n    })\n  },\n}\n","import * as React from 'react'\nimport { Range } from '@editablejs/models'\nimport { useEditableStatic } from '../hooks/use-editable'\nimport { useFocused } from '../hooks/use-focused'\nimport {\n  useSelectionDrawingSelection,\n  useSelectionDrawingRects,\n  useSelectionDrawingEnabled,\n  useSelectionDrawingStyle,\n} from '../hooks/use-selection-drawing'\nimport { isTouchDevice } from '../utils/environment'\nimport { IS_TOUCHING, IS_TOUCHMOVING, IS_TOUCH_HOLD } from '../utils/weak-maps'\nimport { ShadowBlock } from './shadow'\n\ninterface TouchPointProps {\n  onAnchorTouchStart?: (e: React.TouchEvent) => void\n  onFocusTouchStart?: (e: React.TouchEvent) => void\n}\n\nconst TouchPointComponent: React.FC<TouchPointProps> = React.memo(\n  ({ onAnchorTouchStart, onFocusTouchStart }) => {\n    const selection = useSelectionDrawingSelection()\n    const rects = useSelectionDrawingRects()\n    const enabled = useSelectionDrawingEnabled()\n    const style = useSelectionDrawingStyle()\n    const editor = useEditableStatic()\n\n    if (\n      rects.length === 0 ||\n      !isTouchDevice ||\n      !enabled ||\n      !selection ||\n      IS_TOUCHING.get(editor) ||\n      (!IS_TOUCHMOVING.get(editor) && Range.isCollapsed(selection))\n    )\n      return null\n    const anchor = rects[0]\n    const focus = rects[rects.length - 1]\n\n    const baseStyle: React.CSSProperties = {\n      position: 'absolute',\n      width: 12,\n      height: 12,\n      borderRadius: '100%',\n      overscrollBehavior: 'none',\n      background: style.dragColor,\n    }\n\n    return (\n      <>\n        <ShadowBlock\n          rect={Object.assign({}, anchor.toJSON(), {\n            color: style.dragColor,\n            width: 2,\n            left: anchor.left - 1,\n          })}\n          style={{\n            zIndex: 2,\n          }}\n        >\n          <div\n            onTouchStart={onAnchorTouchStart}\n            style={{\n              ...baseStyle,\n              top: -10,\n              left: -5,\n            }}\n          />\n        </ShadowBlock>\n        <ShadowBlock\n          rect={Object.assign({}, focus.toJSON(), {\n            color: style.dragColor,\n            width: 2,\n            left: focus.right - 1,\n          })}\n          style={{\n            zIndex: 2,\n          }}\n        >\n          <div\n            onTouchStart={onFocusTouchStart}\n            style={{\n              ...baseStyle,\n              bottom: -10,\n              right: -5,\n            }}\n          />\n        </ShadowBlock>\n      </>\n    )\n  },\n)\nTouchPointComponent.displayName = 'TouchPointComponent'\nexport { TouchPointComponent }\n","import * as React from 'react'\nimport { Descendant, Node, Editor, Scrubber } from '@editablejs/models'\nimport create, { StoreApi, UseBoundStore } from 'zustand'\nimport { Editable } from '../plugin/editable'\nimport { EditableStore, EditableStoreContext } from '../hooks/use-editable'\nimport { useIsomorphicLayoutEffect } from '../hooks/use-isomorphic-layout-effect'\n\nconst EDITABLE_TO_STORE = new WeakMap<Editable, UseBoundStore<StoreApi<EditableStore>>>()\n\nexport const EditableProvider = (props: {\n  editor: Editable\n  value?: Descendant[]\n  children: React.ReactNode\n  onChange?: (value: Descendant[]) => void\n}) => {\n  const {\n    editor,\n    children,\n    value = [{ type: 'paragraph', children: [{ text: '' }] }],\n    onChange,\n    ...rest\n  } = props\n\n  const store = React.useMemo(() => {\n    const store = EDITABLE_TO_STORE.get(editor)\n    if (store) {\n      return store\n    }\n    if (!Node.isNodeList(value)) {\n      throw new Error(\n        `[Editable] value is invalid! Expected a list of elements` +\n          `but got: ${Scrubber.stringify(value)}`,\n      )\n    }\n    if (!Editor.isEditor(editor)) {\n      throw new Error(`[Editable] editor is invalid! you passed:` + `${Scrubber.stringify(editor)}`)\n    }\n    editor.children = value\n    Object.assign(editor, rest)\n    const newStore = create<EditableStore>(() => ({\n      editor: [editor],\n    }))\n    EDITABLE_TO_STORE.set(editor, newStore)\n    editor.normalizeNode([editor, []])\n    return newStore\n  }, [editor, value, rest])\n\n  useIsomorphicLayoutEffect(() => {\n    const handleChange = () => {\n      if (onChange) {\n        onChange(editor.children)\n      }\n      store.setState({\n        editor: [editor],\n      })\n    }\n    editor.on('change', handleChange)\n    return () => {\n      editor.off('change', handleChange)\n    }\n  }, [editor, onChange])\n\n  return (\n    <EditableStoreContext.Provider\n      value={{\n        store,\n        editor,\n      }}\n    >\n      {children}\n    </EditableStoreContext.Provider>\n  )\n}\n","import * as React from 'react'\nimport { Path, Grid, GridSelection } from '@editablejs/models'\nimport { Editable } from '../plugin/editable'\nimport { useEditableStatic } from './use-editable'\nimport { useGrid } from './use-grid'\nimport { useIsomorphicLayoutEffect } from './use-isomorphic-layout-effect'\nimport { useNodeFocused } from './use-node-focused'\n\nconst useGridSelection = () => {\n  const editor = useEditableStatic()\n  const grid = useGrid()\n  // selection\n  const [selection, setSelection] = React.useState<GridSelection | null>(null)\n  const nodeFocused = useNodeFocused()\n\n  useIsomorphicLayoutEffect(() => {\n    if (grid && nodeFocused) {\n      const selection = Grid.getSelection(editor, [grid, Editable.findPath(editor, grid)])\n      if (selection) {\n        setSelection(prev => {\n          if (\n            !prev ||\n            !Path.equals(prev.start, selection.start) ||\n            !Path.equals(prev.end, selection.end)\n          ) {\n            const path = Editable.findPath(editor, grid)\n            const startPath = path.concat(selection.start)\n            const endPath = path.concat(selection.end)\n            const edgeSelection = Grid.edges(editor, [grid, path], selection)\n            const { start: tableStart, end: tableEnd } = Grid.span(\n              editor,\n              [grid, path],\n              edgeSelection,\n            )\n            const selStart = path.concat(tableStart)\n            const selEnd = path.concat(tableEnd)\n            // 有合并的单元格时选择区域会变大，所以需要重新select\n            if (!Path.equals(startPath, selStart) || !Path.equals(endPath, selEnd)) {\n              Grid.select(editor, [grid, path], edgeSelection)\n              return prev\n            }\n            return selection\n          }\n          return prev\n        })\n        return\n      }\n    }\n    setSelection(null)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [editor, editor.selection, nodeFocused])\n\n  return selection\n}\n\nexport { useGridSelection }\n","import * as React from 'react'\nimport { GridCell, Grid } from '@editablejs/models'\nimport { Editable } from '../plugin/editable'\nimport { useEditableStatic } from './use-editable'\nimport { useGrid } from './use-grid'\nimport { useGridSelection } from './use-grid-selection'\nimport { useIsomorphicLayoutEffect } from './use-isomorphic-layout-effect'\n\nconst useGridSelectionRect = () => {\n  const editor = useEditableStatic()\n\n  const grid = useGrid()\n\n  const selection = useGridSelection()\n\n  const [rect, setRect] = React.useState<DOMRect | null>(null)\n\n  useIsomorphicLayoutEffect(() => {\n    if (!selection || !grid) return setRect(null)\n    const { start, end } = GridCell.edges(selection)\n    if (GridCell.equal(start, end)) return setRect(null)\n    const path = Editable.findPath(editor, grid)\n    const startCell = Grid.getCell(editor, path, start)\n    if (!startCell) return setRect(null)\n    const endCell = Grid.getCell(editor, path, end)\n    if (!endCell) return setRect(null)\n    const startEl = Editable.toDOMNode(editor, startCell[0])\n    const endEl = Editable.toDOMNode(editor, endCell[0])\n    const tableEl = Editable.toDOMNode(editor, grid)\n    const tableRect = tableEl.getBoundingClientRect()\n    const startRect = startEl.getBoundingClientRect()\n    const endRect = endEl.getBoundingClientRect()\n    const width =\n      endRect.left < startRect.left\n        ? startRect.right - endRect.left\n        : endRect.right - startRect.left\n    const height = Math.max(endRect.bottom - startRect.top, startRect.height)\n    const top = startRect.top - tableRect.top\n    const left = Math.min(startRect.left - tableRect.left, endRect.left - tableRect.left)\n    setRect(new DOMRect(left, top, width, height))\n  }, [editor, selection, grid])\n\n  return rect\n}\n\nexport { useGridSelectionRect }\n","import * as React from 'react'\nimport { GridSelected, Grid } from '@editablejs/models'\nimport { Editable } from '../plugin/editable'\nimport { useEditableStatic } from './use-editable'\nimport { useGrid } from './use-grid'\nimport { useGridSelection } from './use-grid-selection'\n\nconst defaultSelected = {\n  rows: [],\n  cols: [],\n  rowFull: false,\n  colFull: false,\n  allFull: false,\n  cells: [],\n  count: 0,\n}\n\nconst useGridSelected = () => {\n  const editor = useEditableStatic()\n\n  const grid = useGrid()\n\n  const selection = useGridSelection()\n\n  const selected: GridSelected = React.useMemo(() => {\n    if (!grid) return defaultSelected\n    const sel = Grid.getSelected(editor, Editable.findPath(editor, grid), selection ?? undefined)\n    return sel ?? defaultSelected\n  }, [editor, selection, grid])\n\n  return selected\n}\n\nexport { useGridSelected }\n","import ReactDOM from 'react-dom'\nimport {\n  Editor,\n  Node,\n  Path,\n  Operation,\n  Transforms,\n  Range,\n  Point,\n  List,\n  Key,\n} from '@editablejs/models'\nimport { Editable, RenderElementProps, RenderLeafProps } from './editable'\nimport {\n  EDITOR_TO_KEY_TO_ELEMENT,\n  NODE_TO_KEY,\n  IS_SHIFT_PRESSED,\n  EDITOR_TO_INPUT,\n  EDITOR_TO_SHADOW,\n} from '../utils/weak-maps'\nimport { findCurrentLineRange } from '../utils/lines'\nimport { EventEmitter } from './event'\nimport { Placeholder } from './placeholder'\nimport { Focused } from '../hooks/use-focused'\nimport { canForceTakeFocus } from '../utils/dom'\nimport { withInput } from './with-input'\nimport { withKeydown } from './with-keydown'\nimport { withNormalizeNode } from './with-normalize-node'\nimport { withDataTransfer } from './with-data-transfer'\nimport { getWordRange } from '../utils/text'\nimport { ReadOnly } from '../hooks/use-read-only'\n\n/**\n * `withEditable` adds React and DOM specific behaviors to the editor.\n *\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\n * this plugin.\n *\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\n */\nexport const withEditable = <T extends Editor>(editor: T) => {\n  const e = editor as T & Editable\n\n  withInput(e)\n\n  withKeydown(e)\n\n  withNormalizeNode(e)\n\n  withDataTransfer(e)\n\n  const { apply, onChange, deleteBackward, deleteForward } = e\n\n  // The WeakMap which maps a key to a specific HTMLElement must be scoped to the editor instance to\n  // avoid collisions between editors in the DOM that share the same value.\n  EDITOR_TO_KEY_TO_ELEMENT.set(e, new WeakMap())\n\n  e.deleteForward = unit => {\n    const { selection } = editor\n\n    if (selection && Range.isCollapsed(selection)) {\n      const [cell] = Editor.nodes(editor, {\n        match: n => e.isGridCell(n),\n      })\n\n      if (cell) {\n        const [, cellPath] = cell\n        const end = Editor.end(editor, cellPath)\n        if (Point.equals(selection.anchor, end)) {\n          return\n        }\n      }\n    }\n    deleteForward(unit)\n  }\n\n  e.deleteBackward = unit => {\n    const { selection } = editor\n\n    if (selection && Range.isCollapsed(selection)) {\n      const [cell] = Editor.nodes(editor, {\n        match: n => e.isGridCell(n),\n      })\n\n      if (cell) {\n        const [, cellPath] = cell\n        const start = Editor.start(editor, cellPath)\n\n        if (Point.equals(selection.anchor, start)) {\n          return\n        }\n      }\n      const list = List.above(e)\n      if (list && Editor.isStart(e, selection.focus, list[1])) {\n        List.unwrapList(e)\n        return\n      }\n    }\n    if (unit !== 'line') {\n      return deleteBackward(unit)\n    }\n\n    if (selection && Range.isCollapsed(selection)) {\n      const parentBlockEntry = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at: selection,\n      })\n\n      if (parentBlockEntry) {\n        const [, parentBlockPath] = parentBlockEntry\n        const parentElementRange = Editor.range(editor, parentBlockPath, selection.anchor)\n\n        const currentLineRange = findCurrentLineRange(e, parentElementRange)\n\n        if (!Range.isCollapsed(currentLineRange)) {\n          Transforms.delete(editor, { at: currentLineRange })\n        }\n      }\n    }\n  }\n\n  // This attempts to reset the NODE_TO_KEY entry to the correct value\n  // as apply() changes the object reference and hence invalidates the NODE_TO_KEY entry\n  e.apply = (op: Operation) => {\n    const matches: [Path, Key][] = []\n\n    switch (op.type) {\n      case 'insert_text':\n      case 'remove_text':\n      case 'set_node':\n      case 'split_node': {\n        matches.push(...getMatches(e, op.path))\n        break\n      }\n\n      case 'set_selection': {\n        break\n      }\n\n      case 'insert_node':\n      case 'remove_node': {\n        matches.push(...getMatches(e, Path.parent(op.path)))\n        break\n      }\n\n      case 'merge_node': {\n        const prevPath = Path.previous(op.path)\n        matches.push(...getMatches(e, prevPath))\n        break\n      }\n\n      case 'move_node': {\n        const commonPath = Path.common(Path.parent(op.path), Path.parent(op.newPath))\n        matches.push(...getMatches(e, commonPath))\n        break\n      }\n    }\n\n    apply(op)\n\n    for (const [path, key] of matches) {\n      const [node] = Editor.node(e, path)\n      NODE_TO_KEY.set(node, key)\n    }\n    if (!Editable.isFocused(e) && canForceTakeFocus()) {\n      e.focus()\n    }\n  }\n\n  e.on = (type, handler, prepend) => {\n    EventEmitter.on(e, type, handler, prepend)\n  }\n\n  e.off = (type, handler) => {\n    EventEmitter.off(e, type, handler)\n  }\n\n  e.once = (type, handler, prepend) => {\n    EventEmitter.on(e, type, handler, prepend)\n  }\n\n  e.emit = (type, ...args) => {\n    EventEmitter.emit(e, type, ...args)\n  }\n\n  let prevSelection: Range | null = null\n  let prevAnchorNode: Node | null = null\n  let prevFocusNode: Node | null = null\n\n  e.onChange = () => {\n    if (\n      ((!prevSelection || !e.selection) && prevSelection !== e.selection) ||\n      (prevSelection &&\n        e.selection &&\n        (!Range.equals(prevSelection, e.selection) ||\n          prevAnchorNode !== Node.get(e, e.selection.anchor.path) ||\n          prevFocusNode !== Node.get(e, e.selection.focus.path)))\n    ) {\n      e.onSelectionChange()\n      prevSelection = e.selection ? Object.assign({}, e.selection) : null\n      prevAnchorNode = e.selection ? Node.get(e, e.selection.anchor.path) : null\n      prevFocusNode = e.selection ? Node.get(e, e.selection.focus.path) : null\n    }\n    Placeholder.refresh(e)\n    onChange()\n    e.emit('change')\n  }\n\n  e.blur = (): void => {\n    const shadow = EDITOR_TO_SHADOW.get(editor)\n    const textarea = EDITOR_TO_INPUT.get(editor)\n    if (textarea && shadow && shadow.activeElement !== textarea) {\n      textarea.blur()\n    }\n  }\n  /**\n   * Focus the editor.\n   */\n  e.focus = (start): void => {\n    if (!editor.selection) {\n      const path = Editable.findPath(e, e)\n      const point = start ? Editor.start(e, path) : Editor.end(e, path)\n      Transforms.select(e, point)\n    } else if (start === true) {\n      const path = Editable.findPath(e, e)\n      Transforms.select(e, Editor.start(e, path))\n    } else if (start === false) {\n      const path = Editable.findPath(e, e)\n      Transforms.select(e, Editor.end(e, path))\n    }\n\n    const shadow = EDITOR_TO_SHADOW.get(editor)\n    const textarea = EDITOR_TO_INPUT.get(editor)\n    if (textarea && shadow && shadow.activeElement !== textarea) {\n      textarea.focus({ preventScroll: true })\n    }\n  }\n\n  e.selectWord = (options = {}) => {\n    const { at, edge = 'focus' } = options\n    if (at) {\n      Transforms.select(e, at)\n    }\n    const { selection } = e\n    if (!selection) return\n    const point = ['focus', 'end'].includes(edge) ? Range.end(selection) : Range.start(selection)\n    const { text, offset } = Editable.findTextOffsetOnLine(e, point)\n    if (text) {\n      const { path } = point\n      const [startOffset, endOffset] = getWordRange(text, offset)\n      Transforms.select(e, {\n        anchor: Editable.findPointOnLine(e, path, startOffset, true),\n        focus: Editable.findPointOnLine(e, path, endOffset),\n      })\n      e.onSelectEnd()\n    }\n  }\n\n  e.selectLine = (options = {}) => {\n    const { at, edge = 'focus' } = options\n    if (at) {\n      Transforms.select(e, at)\n    }\n    const { selection } = e\n    if (!selection) return\n    const point = ['focus', 'end'].includes(edge) ? Range.end(selection) : Range.start(selection)\n    const { path } = point\n    const node = Node.get(e, path)\n    let linePath = path\n    if (!Editor.isBlock(e, node)) {\n      const block = Editor.above(e, {\n        match: n => Editor.isBlock(e, n),\n        at: path,\n      })\n\n      linePath = block?.[1] ?? path.slice(0, 1)\n    }\n\n    const range = Editor.range(e, linePath)\n    Transforms.select(e, range)\n    e.onSelectEnd()\n  }\n\n  e.onKeyup = (event: KeyboardEvent) => {\n    if (event.key.toLowerCase() === 'shift') {\n      IS_SHIFT_PRESSED.set(editor, false)\n    }\n    e.emit('keyup', event)\n  }\n\n  e.onFocus = () => {\n    e.focus()\n    Placeholder.refresh(e)\n    e.emit('focus')\n  }\n\n  e.onBlur = () => {\n    Placeholder.refresh(e)\n    e.emit('blur')\n  }\n\n  e.onSelectStart = () => {\n    e.emit('selectstart')\n  }\n\n  e.onSelecting = () => {\n    e.emit('selecting')\n  }\n\n  e.onSelectEnd = () => {\n    e.emit('selectend')\n  }\n\n  e.onSelectionChange = () => {\n    e.emit('selectionchange')\n  }\n\n  e.onTouchHold = event => {\n    e.emit('touchhold', event)\n  }\n\n  e.onTouchTrack = () => {\n    e.emit('touchtrack')\n  }\n\n  e.onContextMenu = event => {\n    e.emit('contextmenu', event)\n  }\n\n  e.onDestory = () => {\n    e.emit('destory')\n  }\n\n  e.renderElementAttributes = ({ attributes }) => {\n    return attributes\n  }\n\n  e.renderLeafAttributes = ({ attributes }) => {\n    return attributes\n  }\n\n  e.renderElement = (props: RenderElementProps) => {\n    const { attributes, children, element } = props\n    const Tag = e.isInline(element) ? 'span' : 'div'\n    return <Tag {...attributes}>{children}</Tag>\n  }\n\n  e.renderLeaf = (props: RenderLeafProps) => {\n    const { attributes, children } = props\n    return <span {...attributes}>{children}</span>\n  }\n\n  e.renderPlaceholder = ({ attributes, children }) => {\n    return (\n      <span\n        style={{\n          pointerEvents: 'none',\n          userSelect: 'none',\n          width: '100%',\n        }}\n      >\n        <span\n          style={{\n            position: 'absolute',\n            opacity: '0.333',\n            width: 'fit-content',\n            whiteSpace: 'nowrap',\n            textIndent: 'initial',\n            textOverflow: 'ellipsis',\n            maxWidth: '100%',\n            overflow: 'hidden',\n          }}\n          {...attributes}\n        >\n          {children}\n        </span>\n      </span>\n    )\n  }\n\n  const { insertBreak } = e\n\n  e.insertBreak = () => {\n    const { selection } = editor\n\n    if (!Editable.isEditor(editor) || !selection || Range.isExpanded(selection)) {\n      insertBreak()\n      return\n    }\n    const entrie = List.above(editor)\n    if (!entrie) {\n      insertBreak()\n      return\n    }\n    List.splitList(editor)\n  }\n\n  e.insertFile = (_, range) => {\n    if (range) {\n      Transforms.select(e, range)\n    }\n  }\n\n  return e\n}\n\nconst getMatches = (e: Editable, path: Path) => {\n  const matches: [Path, Key][] = []\n  for (const [n, p] of Editor.levels(e, { at: path })) {\n    const key = Editable.findKey(e, n)\n    matches.push([p, key])\n  }\n  return matches\n}\n","/**\n * Utilities for single-line deletion\n */\n\nimport { Range, Editor } from '@editablejs/models'\nimport { Editable } from '../plugin/editable'\n\nconst doRectsIntersect = (rect: DOMRect, compareRect: DOMRect) => {\n  const middle = (compareRect.top + compareRect.bottom) / 2\n\n  return rect.top <= middle && rect.bottom >= middle\n}\n\nconst areRangesSameLine = (editor: Editable, range1: Range, range2: Range) => {\n  const rect1 = Editable.toDOMRange(editor, range1).getBoundingClientRect()\n  const rect2 = Editable.toDOMRange(editor, range2).getBoundingClientRect()\n\n  return doRectsIntersect(rect1, rect2) && doRectsIntersect(rect2, rect1)\n}\n\n/**\n * A helper utility that returns the end portion of a `Range`\n * which is located on a single line.\n *\n * @param {Editor} editor The editor object to compare against\n * @param {Range} parentRange The parent range to compare against\n * @returns {Range} A valid portion of the parentRange which is one a single line\n */\nexport const findCurrentLineRange = (editor: Editable, parentRange: Range): Range => {\n  const parentRangeBoundary = Editor.range(editor, Range.end(parentRange))\n  const positions = Array.from(Editor.positions(editor, { at: parentRange }))\n\n  let left = 0\n  let right = positions.length\n  let middle = Math.floor(right / 2)\n\n  if (areRangesSameLine(editor, Editor.range(editor, positions[left]), parentRangeBoundary)) {\n    return Editor.range(editor, positions[left], parentRangeBoundary)\n  }\n\n  if (positions.length < 2) {\n    return Editor.range(editor, positions[positions.length - 1], parentRangeBoundary)\n  }\n\n  while (middle !== positions.length && middle !== left) {\n    if (areRangesSameLine(editor, Editor.range(editor, positions[middle]), parentRangeBoundary)) {\n      right = middle\n    } else {\n      left = middle\n    }\n\n    middle = Math.floor((left + right) / 2)\n  }\n\n  return Editor.range(editor, positions[right], parentRangeBoundary)\n}\n","export type Listener = (...args: any[]) => void\n\nexport class Emitter {\n  static listenerCount(emitter: Emitter, type: string | number): number {\n    return emitter.listenerCount(type)\n  }\n\n  static defaultMaxListeners: number = 10\n\n  events: Record<string | number, Listener | Listener[]> = {}\n\n  maxListeners: number | undefined = undefined\n\n  eventsCount = 0\n\n  listenerCount(type: string | number): number {\n    const evlistener = this.events[type]\n\n    if (typeof evlistener === 'function') {\n      return 1\n    } else if (evlistener !== undefined) {\n      return evlistener.length\n    }\n\n    return 0\n  }\n\n  eventNames(): Array<string | number> {\n    return Object.keys(this.events)\n  }\n\n  setMaxListeners(count: number): this {\n    this.maxListeners = count\n    return this\n  }\n\n  getMaxListeners(): number {\n    return this.maxListeners ?? Emitter.defaultMaxListeners\n  }\n\n  emit(type: string | number, ...args: any[]): boolean {\n    const handler = this.events[type]\n\n    if (handler === undefined) return false\n\n    if (typeof handler === 'function') {\n      handler(...args)\n    } else {\n      const len = handler.length\n      for (let i = 0; i < len; ++i) handler[i](...args)\n    }\n\n    return true\n  }\n\n  on(type: string | number, listener: Listener, prepend = false): this {\n    let existing = this.events[type]\n    if (existing === undefined) {\n      // Optimize the case of one listener. Don't need the extra array object.\n      this.events[type] = listener\n      ++this.eventsCount\n    } else {\n      if (typeof existing === 'function') {\n        // Adding the second element, need to change to array.\n        existing = this.events[type] = prepend ? [listener, existing] : [existing, listener]\n        // If we've already got an array, just append.\n      } else if (prepend) {\n        existing.unshift(listener)\n      } else {\n        existing.push(listener)\n      }\n\n      // Check for listener leak\n      const maxCount = this.getMaxListeners()\n      if (maxCount > 0 && existing.length > maxCount) {\n        // No error code for this since it is a Warning\n        // eslint-disable-next-line no-restricted-syntax\n        const e = new Error(\n          'Possible EventEmitter memory leak detected. ' +\n            existing.length +\n            ' ' +\n            String(type) +\n            ' listeners ' +\n            'added. Use emitter.setMaxListeners() to ' +\n            'increase limit',\n        )\n        console.warn(e)\n      }\n    }\n\n    return this\n  }\n\n  off(type: string | number, listener: Listener): this {\n    const list = this.events[type]\n    if (list === undefined) return this\n\n    if (list === listener) {\n      if (--this.eventsCount === 0) this.events = {}\n      else {\n        delete this.events[type]\n      }\n    } else if (typeof list !== 'function') {\n      let position = -1\n\n      for (let i = list.length - 1; i >= 0; i--) {\n        if (list[i] === listener) {\n          position = i\n          break\n        }\n      }\n\n      if (position < 0) return this\n\n      if (position === 0) list.shift()\n      else {\n        list.splice(position, 1)\n      }\n\n      if (list.length === 1) this.events[type] = list[0]\n    }\n\n    return this\n  }\n\n  once(type: string | number, listener: Listener, prepend = false): this {\n    const wrapper = (...args: any[]) => {\n      this.off(type, wrapper)\n      listener(...args)\n    }\n    return this.on(type, wrapper, prepend)\n  }\n}\n","import { Editable } from './editable'\nimport { Emitter } from './emitter'\n\nconst EDITOR_TO_EVENT: WeakMap<Editable, Emitter> = new WeakMap()\n\ntype EventEndingKey<\n  Set,\n  Needle extends string,\n  Key extends keyof Set = keyof Set,\n> = Key extends `${Needle}${infer _X}` ? (_X extends `` ? never : _X) : never\n\ntype EndingKey = EventEndingKey<Editable, 'on'>\n\nexport type EventType = Lowercase<EndingKey>\n\nexport type EventHandler<\n  T extends EventType,\n  Key extends EndingKey = EndingKey,\n> = Key extends `${Lowercase<Key>}`\n  ? never\n  : T extends Lowercase<Key>\n  ? Editable[`on${Key}`]\n  : never\n\nexport const EventEmitter = {\n  get: (editor: Editable) => {\n    let event = EDITOR_TO_EVENT.get(editor)\n    if (!event) {\n      event = new Emitter()\n      EDITOR_TO_EVENT.set(editor, event)\n    }\n    return event\n  },\n  on: <T extends EventType>(\n    editor: Editable,\n    type: T,\n    handler: EventHandler<T>,\n    prepend = false,\n  ) => {\n    EventEmitter.get(editor).on(type, handler, prepend)\n  },\n\n  off: <T extends EventType>(editor: Editable, type: T, handler: EventHandler<T>) => {\n    EventEmitter.get(editor).off(type, handler)\n  },\n\n  once: <T extends EventType>(\n    editor: Editable,\n    type: T,\n    handler: EventHandler<T>,\n    prepend = false,\n  ) => {\n    EventEmitter.get(editor).once(type, handler, prepend)\n  },\n\n  emit: <T extends EventType>(editor: Editable, type: T, ...args: Parameters<EventHandler<T>>) => {\n    EventEmitter.get(editor).emit(type, ...args)\n  },\n}\n","import { CompositionText, Editor, Transforms, Range, Text } from '@editablejs/models'\nimport { IS_COMPOSING } from '../utils/weak-maps'\nimport { Editable } from './editable'\n\nexport const withInput = <T extends Editor>(editor: T) => {\n  const e = editor as T & Editable\n\n  e.onInput = (value: string) => {\n    if (!editor.selection) return\n    if (Editable.isComposing(editor)) {\n      const { selection, marks } = editor\n      let [node, path] = Editor.node(editor, selection)\n      if (marks) {\n        // 使用零宽字符绕过slate里面不能插入空字符的问题。组合输入法完成后会删除掉\n        const compositionText: CompositionText = {\n          text: '\\u200b',\n          ...marks,\n          composition: {\n            text: value,\n            offset: 0,\n            isEmpty: true,\n          },\n        }\n        Transforms.insertNodes(editor, compositionText)\n        e.marks = null\n      } else if (Text.isText(node)) {\n        const composition = CompositionText.isCompositionText(node) ? node.composition : null\n        const offset = composition?.offset ?? Range.start(selection).offset\n\n        Transforms.setNodes<CompositionText>(\n          editor,\n          {\n            composition: {\n              ...composition,\n              text: value,\n              offset,\n            },\n          },\n          { at: path },\n        )\n        const point = { path, offset: offset + value.length }\n        Transforms.select(editor, {\n          anchor: point,\n          focus: point,\n        })\n      }\n    } else {\n      editor.insertText(value)\n    }\n    e.emit('input', value)\n  }\n\n  e.onBeforeInput = value => {\n    e.emit('beforeinput', value)\n  }\n\n  e.onCompositionStart = data => {\n    if (editor.selection && Range.isExpanded(editor.selection)) {\n      Editor.deleteFragment(editor)\n    }\n    IS_COMPOSING.set(editor, true)\n    e.emit('compositionstart', data)\n  }\n\n  e.onCompositionEnd = (value: string) => {\n    const { selection } = editor\n    if (!selection) return\n    const [node, path] = Editor.node(editor, selection)\n    if (Text.isText(node)) {\n      const composition = CompositionText.isCompositionText(node) ? node.composition : null\n      Transforms.setNodes<CompositionText>(\n        editor,\n        {\n          composition: undefined,\n        },\n        { at: path },\n      )\n      const point = { path, offset: composition?.offset ?? selection.anchor.offset }\n      const range = composition?.isEmpty\n        ? {\n            anchor: { path, offset: 0 },\n            focus: { path, offset: 1 },\n          }\n        : point\n      Transforms.select(editor, range)\n\n      IS_COMPOSING.set(editor, false)\n      Transforms.insertText(editor, value)\n    }\n    e.emit('compositionend', value)\n  }\n\n  return e\n}\n","import { Editor, Transforms, Node, Range } from '@editablejs/models'\nimport getDirection from 'direction'\nimport Hotkeys from '../utils/hotkeys'\nimport { getWordOffsetBackward, getWordOffsetForward } from '../utils/text'\nimport { IS_PASTE_TEXT, IS_SHIFT_PRESSED } from '../utils/weak-maps'\nimport { Editable } from './editable'\n\nexport const withKeydown = <T extends Editor>(editor: T) => {\n  const e = editor as T & Editable\n\n  e.onKeydown = (event: KeyboardEvent) => {\n    e.emit('keydown', event)\n    if (event.defaultPrevented) return\n    const { selection } = editor\n    const element = editor.children[selection !== null ? selection.focus.path[0] : 0]\n    const isRTL = getDirection(Node.string(element)) === 'rtl'\n\n    if (Hotkeys.isShift(event)) {\n      IS_SHIFT_PRESSED.set(e, true)\n    }\n\n    if (Hotkeys.isSelectAll(event)) {\n      event.preventDefault()\n      Transforms.select(e, Editor.range(e, []))\n      return\n    }\n\n    if (Hotkeys.isCut(event)) {\n      event.preventDefault()\n      e.cut()\n      return\n    }\n\n    if (Hotkeys.isCopy(event)) {\n      event.preventDefault()\n      e.copy()\n      return\n    }\n\n    if (Hotkeys.isPaste(event)) {\n      IS_PASTE_TEXT.set(e, false)\n      return\n    }\n\n    if (Hotkeys.isPasteText(event)) {\n      IS_PASTE_TEXT.set(e, true)\n      return\n    }\n\n    if (Hotkeys.isExtendForward(event)) {\n      event.preventDefault()\n      Transforms.move(e, { edge: 'focus' })\n      return\n    }\n\n    if (Hotkeys.isExtendBackward(event)) {\n      event.preventDefault()\n      Transforms.move(e, { edge: 'focus', reverse: true })\n      return\n    }\n\n    if (Hotkeys.isExtendUp(event)) {\n      event.preventDefault()\n      const point = Editable.findPreviousLinePoint(e)\n      if (point && selection)\n        Transforms.select(editor, {\n          anchor: selection.anchor,\n          focus: point,\n        })\n      return\n    }\n\n    if (Hotkeys.isExtendDown(event)) {\n      event.preventDefault()\n      const point = Editable.findNextLinePoint(e)\n      if (point && selection)\n        Transforms.select(editor, {\n          anchor: selection.anchor,\n          focus: point,\n        })\n      return\n    }\n\n    if (Hotkeys.isMoveUp(event)) {\n      event.preventDefault()\n      const point = Editable.findPreviousLinePoint(e)\n      if (point) Transforms.select(editor, point)\n      return\n    }\n\n    if (Hotkeys.isMoveDown(event)) {\n      event.preventDefault()\n      const point = Editable.findNextLinePoint(e)\n      if (point) Transforms.select(editor, point)\n      return\n    }\n\n    if (Hotkeys.isExtendLineBackward(event)) {\n      event.preventDefault()\n      Transforms.move(e, {\n        unit: 'line',\n        edge: 'focus',\n        reverse: true,\n      })\n      return\n    }\n\n    if (Hotkeys.isExtendLineForward(event)) {\n      event.preventDefault()\n      Transforms.move(e, { unit: 'line', edge: 'focus' })\n      return\n    }\n\n    if (Hotkeys.isMoveWordBackward(event)) {\n      event.preventDefault()\n\n      if (selection && Range.isExpanded(selection)) {\n        Transforms.collapse(editor, { edge: 'focus' })\n      }\n      if (selection) {\n        const { focus } = selection\n        const { path: focusPath } = focus\n        if (Editor.isStart(editor, focus, focusPath)) {\n          Transforms.move(e, { reverse: !isRTL })\n          return\n        }\n        const { text, offset } = Editable.findTextOffsetOnLine(e, focus)\n        if (text) {\n          const wordOffset = getWordOffsetBackward(text, offset)\n          const newPoint = Editable.findPointOnLine(e, focusPath, wordOffset)\n          Transforms.select(editor, newPoint)\n          return\n        }\n      }\n      Transforms.move(e, { unit: 'word', reverse: !isRTL })\n      return\n    }\n\n    if (Hotkeys.isMoveWordForward(event)) {\n      event.preventDefault()\n\n      if (selection && Range.isExpanded(selection)) {\n        Transforms.collapse(editor, { edge: 'focus' })\n      }\n      if (selection) {\n        const { focus } = selection\n        const { path: focusPath } = focus\n        if (Editor.isEnd(editor, focus, focusPath)) {\n          Transforms.move(e, { reverse: isRTL })\n          return\n        }\n        const { text, offset } = Editable.findTextOffsetOnLine(e, focus)\n        if (text) {\n          const wordOffset = getWordOffsetForward(text, offset)\n          Transforms.select(editor, Editable.findPointOnLine(e, focusPath, wordOffset))\n          return\n        }\n      }\n      Transforms.move(e, { unit: 'word', reverse: isRTL })\n      return\n    }\n\n    if (Hotkeys.isMoveBackward(event)) {\n      event.preventDefault()\n\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms.move(e, { reverse: !isRTL })\n      } else {\n        Transforms.collapse(editor, { edge: 'start' })\n      }\n\n      return\n    }\n\n    if (Hotkeys.isMoveForward(event)) {\n      event.preventDefault()\n\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms.move(e, { reverse: isRTL })\n      } else {\n        Transforms.collapse(editor, { edge: 'end' })\n      }\n\n      return\n    }\n\n    if (Hotkeys.isMoveLineStart(event)) {\n      event.preventDefault()\n\n      const point = Editable.findLineEdgePoint(e)\n      if (point) {\n        Transforms.select(editor, point)\n      }\n\n      return\n    }\n\n    if (Hotkeys.isMoveLineEnd(event)) {\n      event.preventDefault()\n\n      const point = Editable.findLineEdgePoint(e, { edge: 'end' })\n      if (point) {\n        Transforms.select(editor, point)\n      }\n\n      return\n    }\n\n    if (Hotkeys.isMoveEditorStart(event)) {\n      event.preventDefault()\n\n      e.focus(true)\n\n      return\n    }\n\n    if (Hotkeys.isMoveEditorEnd(event)) {\n      event.preventDefault()\n\n      e.focus(false)\n\n      return\n    }\n\n    if (Hotkeys.isSoftBreak(event)) {\n      event.preventDefault()\n      Editor.insertSoftBreak(editor)\n      return\n    }\n\n    if (Hotkeys.isSplitBlock(event)) {\n      event.preventDefault()\n      Editor.insertBreak(editor)\n      return\n    }\n\n    if (Hotkeys.isDeleteBackward(event)) {\n      event.preventDefault()\n      if (selection && Range.isExpanded(selection)) {\n        Editor.deleteFragment(editor)\n      } else {\n        Editor.deleteBackward(editor)\n      }\n      return\n    }\n\n    if (Hotkeys.isDeleteForward(event)) {\n      event.preventDefault()\n\n      if (selection && Range.isExpanded(selection)) {\n        Editor.deleteFragment(editor, { direction: 'forward' })\n      } else {\n        Editor.deleteForward(editor)\n      }\n\n      return\n    }\n\n    if (Hotkeys.isDeleteLineBackward(event)) {\n      event.preventDefault()\n\n      if (selection && Range.isExpanded(selection)) {\n        Editor.deleteFragment(editor, { direction: 'backward' })\n      } else {\n        Editor.deleteBackward(editor, { unit: 'line' })\n      }\n\n      return\n    }\n\n    if (Hotkeys.isDeleteLineForward(event)) {\n      event.preventDefault()\n\n      if (selection && Range.isExpanded(selection)) {\n        Editor.deleteFragment(editor, { direction: 'forward' })\n      } else {\n        Editor.deleteForward(editor, { unit: 'line' })\n      }\n\n      return\n    }\n\n    if (Hotkeys.isDeleteWordBackward(event)) {\n      event.preventDefault()\n\n      if (selection && Range.isExpanded(selection)) {\n        Editor.deleteFragment(editor, { direction: 'backward' })\n      } else {\n        Editor.deleteBackward(editor, { unit: 'word' })\n      }\n\n      return\n    }\n\n    if (Hotkeys.isDeleteWordForward(event)) {\n      event.preventDefault()\n\n      if (selection && Range.isExpanded(selection)) {\n        Editor.deleteFragment(editor, { direction: 'forward' })\n      } else {\n        Editor.deleteForward(editor, { unit: 'word' })\n      }\n\n      return\n    }\n  }\n}\n","import { isHotkey, isCodeHotkey, isKeyHotkey } from 'is-hotkey'\nimport { IS_APPLE } from './environment'\n\n/**\n * Hotkey mappings for each platform.\n */\n\nconst HOTKEYS: Record<string, string | string[]> = {\n  compose: ['down', 'left', 'right', 'up', 'backspace', 'enter'],\n  selectAll: 'mod+a',\n  cut: 'mod+x',\n  copy: 'mod+c',\n  paste: 'mod+v',\n  pasteText: 'mod+shift+v',\n  moveUp: 'up',\n  moveDown: 'down',\n  moveBackward: 'left',\n  moveForward: 'right',\n  shift: 'shift',\n  moveWordBackward: 'ctrl+left',\n  moveWordForward: 'ctrl+right',\n  extendUp: 'shift+up',\n  extendDown: 'shift+down',\n  deleteBackward: 'shift?+backspace',\n  deleteForward: 'shift?+delete',\n  extendBackward: 'shift+left',\n  extendForward: 'shift+right',\n  insertSoftBreak: 'shift+enter',\n  splitBlock: 'enter',\n  undo: 'mod+z',\n}\n\nconst APPLE_HOTKEYS: Record<string, string | string[]> = {\n  moveLineBackward: 'opt+up',\n  moveLineForward: 'opt+down',\n  moveWordBackward: 'opt+left',\n  moveWordForward: 'opt+right',\n  moveLineStart: 'cmd+left',\n  moveLineEnd: 'cmd+right',\n  moveEditorStart: 'cmd+up',\n  moveEditorEnd: 'cmd+down',\n  deleteBackward: ['ctrl+backspace', 'ctrl+h'],\n  deleteForward: ['ctrl+delete', 'ctrl+d'],\n  deleteLineBackward: 'cmd+shift?+backspace',\n  deleteLineForward: ['cmd+shift?+delete', 'ctrl+k'],\n  deleteWordBackward: 'opt+shift?+backspace',\n  deleteWordForward: 'opt+shift?+delete',\n  extendLineBackward: 'opt+shift+up',\n  extendLineForward: 'opt+shift+down',\n  redo: 'cmd+shift+z',\n  transposeCharacter: 'ctrl+t',\n}\n\nconst WINDOWS_HOTKEYS: Record<string, string | string[]> = {\n  deleteWordBackward: 'ctrl+shift?+backspace',\n  deleteWordForward: 'ctrl+shift?+delete',\n  redo: ['ctrl+y', 'ctrl+shift+z'],\n}\n\n/**\n * Create a platform-aware hotkey checker.\n */\n\nconst create = (key: string) => {\n  const generic = HOTKEYS[key]\n  const apple = APPLE_HOTKEYS[key]\n  const windows = WINDOWS_HOTKEYS[key]\n  const isGeneric = generic && isKeyHotkey(generic)\n  const isApple = apple && isKeyHotkey(apple)\n  const isWindows = windows && isKeyHotkey(windows)\n\n  return (event: KeyboardEvent) => {\n    if (isGeneric && isGeneric(event)) return true\n    if (IS_APPLE && isApple && isApple(event)) return true\n    if (!IS_APPLE && isWindows && isWindows(event)) return true\n    return false\n  }\n}\n\n/**\n * Hotkeys.\n */\n\nconst Hotkeys = {\n  isSelectAll: create('selectAll'),\n  isCut: create('cut'),\n  isCopy: create('copy'),\n  isPaste: create('paste'),\n  isPasteText: create('pasteText'),\n  isMoveUp: create('moveUp'),\n  isMoveDown: create('moveDown'),\n  isCompose: create('compose'),\n  isMoveBackward: create('moveBackward'),\n  isMoveForward: create('moveForward'),\n  isDeleteBackward: create('deleteBackward'),\n  isDeleteForward: create('deleteForward'),\n  isDeleteLineBackward: create('deleteLineBackward'),\n  isDeleteLineForward: create('deleteLineForward'),\n  isDeleteWordBackward: create('deleteWordBackward'),\n  isDeleteWordForward: create('deleteWordForward'),\n  isExtendUp: create('extendUp'),\n  isExtendDown: create('extendDown'),\n  isExtendBackward: create('extendBackward'),\n  isExtendForward: create('extendForward'),\n  isExtendLineBackward: create('extendLineBackward'),\n  isExtendLineForward: create('extendLineForward'),\n  isMoveLineBackward: create('moveLineBackward'),\n  isMoveLineForward: create('moveLineForward'),\n  isMoveWordBackward: create('moveWordBackward'),\n  isMoveWordForward: create('moveWordForward'),\n  isMoveLineStart: create('moveLineStart'),\n  isMoveLineEnd: create('moveLineEnd'),\n  isMoveEditorStart: create('moveEditorStart'),\n  isMoveEditorEnd: create('moveEditorEnd'),\n  isShift: create('shift'),\n  isRedo: create('redo'),\n  isSoftBreak: create('insertSoftBreak'),\n  isSplitBlock: create('splitBlock'),\n  isTransposeCharacter: create('transposeCharacter'),\n  isUndo: create('undo'),\n}\n\nexport default Hotkeys\n\nfunction match(\n  keys: string | string[] | ((e: KeyboardEvent) => boolean),\n  event: KeyboardEvent,\n): boolean\nfunction match<T extends string = string>(\n  keys: Record<T, string | string[] | ((e: KeyboardEvent) => boolean)>,\n  event: KeyboardEvent,\n): T | false\nfunction match<T extends string = string>(\n  keys:\n    | string\n    | string[]\n    | ((e: KeyboardEvent) => boolean)\n    | Record<T, string | string[] | ((e: KeyboardEvent) => boolean)>,\n  event: KeyboardEvent,\n): T | boolean {\n  if (typeof keys === 'string' || Array.isArray(keys)) {\n    return isHotkey(keys, event)\n  } else if (typeof keys === 'function') {\n    return keys(event)\n  } else {\n    for (const key in keys) {\n      const value = keys[key]\n      if (match(value, event)) {\n        return key\n      }\n    }\n  }\n  return false\n}\nexport const Hotkey = {\n  isCode: isCodeHotkey,\n  isKey: isKeyHotkey,\n  format: (key: string, char = '+') => {\n    let keys = key.toLowerCase().split('+')\n    keys = keys.map(key => {\n      if (key === 'mod') {\n        return IS_APPLE ? '⌘' : 'Ctrl'\n      } else if (key === 'opt') {\n        return IS_APPLE ? 'Option' : 'Alt'\n      } else if (key.length > 1) {\n        return key.substring(0, 1).toUpperCase() + key.substring(1).toLowerCase()\n      }\n      return key.toUpperCase()\n    })\n    return keys.join(char)\n  },\n  match,\n}\n","import { Editor, Transforms, Node, Path } from '@editablejs/models'\nimport { Editable } from './editable'\n\nexport const withNormalizeNode = <T extends Editor>(editor: T) => {\n  const e = editor as T & Editable\n\n  const { normalizeNode } = editor\n\n  e.normalizeNode = entry => {\n    const [node, path] = entry\n    if (Editor.isBlock(e, node)) {\n      const { type, ...attributes } = node\n      let isUnwrap = false\n      const isParagraph = !type || type === 'paragraph'\n      // 相同type类的block不嵌套，paragraph 下不能嵌套block节点\n      for (const [child, childPath] of Node.children(editor, path)) {\n        if (Editor.isBlock(e, child)) {\n          if (!isUnwrap && !isParagraph && child.type === type) {\n            Transforms.unwrapNodes(editor, { at: childPath })\n            return\n          } else if (isParagraph) {\n            Transforms.setNodes(editor, attributes, { at: childPath })\n            isUnwrap = true\n          }\n        }\n      }\n      if (isUnwrap) {\n        Transforms.unwrapNodes(editor, { at: path })\n        return\n      }\n    }\n    normalizeNode(entry)\n  }\n\n  return e\n}\n","import { HTMLDeserializer } from '@editablejs/deserializer/html'\nimport { Editor, Transforms, Range, Node } from '@editablejs/models'\nimport { HTMLSerializer } from '@editablejs/serializer/html'\nimport { TextSerializer } from '@editablejs/serializer/text'\nimport { readClipboardData, writeClipboardData } from '../utils/clipboard'\nimport {\n  APPLICATION_FRAGMENT_TYPE,\n  DATA_EDITABLE_FRAGMENT,\n  TEXT_HTML,\n  TEXT_PLAIN,\n} from '../utils/constants'\nimport { fragmentToString, parseDataTransfer } from '../utils/data-transfer'\nimport { IS_PASTE_TEXT } from '../utils/weak-maps'\nimport { Editable } from './editable'\n\nexport const withDataTransfer = <T extends Editor>(editor: T) => {\n  const e = editor as T & Editable\n\n  e.toDataTransfer = range => {\n    const fragment = e.getFragment(range)\n    const fragmentString = fragmentToString(fragment)\n\n    const text = fragment.map(node => TextSerializer.transformWithEditor(e, node)).join('\\n')\n\n    let html = fragment.map(node => HTMLSerializer.transformWithEditor(e, node)).join('')\n    html = `<div ${DATA_EDITABLE_FRAGMENT}=\"${fragmentString}\">${html}</div>`\n    html = `<html><head><meta name=\"source\" content=\"${DATA_EDITABLE_FRAGMENT}\" /></head><body>${html}</body></html>`\n    const dataTransfer = new DataTransfer()\n    dataTransfer.setData(TEXT_PLAIN, text)\n    dataTransfer.setData(TEXT_HTML, html)\n    dataTransfer.setData(APPLICATION_FRAGMENT_TYPE, fragmentString)\n    return dataTransfer\n  }\n\n  e.onCut = event => {\n    if (event.defaultPrevented) return\n    const { selection } = e\n    const { clipboardData } = event\n    if (clipboardData) writeClipboardData(clipboardData)\n    if (selection) {\n      if (Range.isExpanded(selection)) {\n        Editor.deleteFragment(e)\n      } else {\n        const node = Node.parent(e, selection.anchor.path)\n        if (Editor.isVoid(e, node)) {\n          Transforms.delete(e)\n        }\n      }\n    }\n    e.emit('cut', event)\n  }\n\n  e.onCopy = event => {\n    if (event.defaultPrevented) return\n    const { clipboardData } = event\n    if (clipboardData) writeClipboardData(clipboardData)\n    e.emit('copy', event)\n  }\n\n  e.onPaste = event => {\n    if (event.defaultPrevented) return\n    const { clipboardData } = event\n    if (!clipboardData) return\n    event.preventDefault()\n    const { text, fragment, html, files } = parseDataTransfer(clipboardData)\n    const isPasteText = event.type === 'pasteText'\n    if (!isPasteText && fragment.length > 0) {\n      e.insertFragment(fragment)\n    } else if (!isPasteText && html) {\n      const document = new DOMParser().parseFromString(html, TEXT_HTML)\n      const fragment = HTMLDeserializer.transformWithEditor(e, document.body)\n      e.insertFragment(fragment)\n    } else {\n      const lines = text.split(/\\r\\n|\\r|\\n/)\n      let split = false\n\n      for (const line of lines) {\n        if (split) {\n          Transforms.splitNodes(e, { always: true })\n        }\n        e.normalizeSelection(selection => {\n          if (selection !== e.selection) e.selection = selection\n          e.insertText(line)\n        })\n        split = true\n      }\n    }\n    for (const file of files) {\n      e.insertFile(file)\n    }\n    e.emit('paste', event)\n  }\n\n  e.copy = range => {\n    const data = e.toDataTransfer(range)\n    const event = new ClipboardEvent('copy', { clipboardData: data })\n    e.onCopy(event)\n  }\n\n  e.cut = range => {\n    const data = e.toDataTransfer(range)\n    const event = new ClipboardEvent('copy', { clipboardData: data })\n    if (range) {\n      Transforms.select(e, range)\n    }\n    e.onCut(event)\n  }\n\n  e.insertFromClipboard = range => {\n    if (range) {\n      Transforms.select(e, range)\n    }\n    readClipboardData().then(data => {\n      const event = new ClipboardEvent('paste', { clipboardData: data })\n      e.onPaste(event)\n    })\n  }\n\n  e.insertTextFromClipboard = range => {\n    if (range) {\n      Transforms.select(e, range)\n    }\n    readClipboardData().then(data => {\n      IS_PASTE_TEXT.set(e, true)\n      const event = new ClipboardEvent('pasteText', { clipboardData: data })\n      e.onPaste(event)\n    })\n  }\n\n  return e\n}\n","import { APPLICATION_FRAGMENT_TYPE, TEXT_HTML, TEXT_PLAIN } from './constants'\nimport { matchFragmentStringFromHTML, parseDataTransferFiles } from './data-transfer'\nimport { isDOMHTMLElement } from '@editablejs/models'\n\nconst deselectCurrent = () => {\n  const selection = document.getSelection()\n  if (!selection?.rangeCount) {\n    return function () {}\n  }\n  let active: HTMLElement | null = null\n  let activeElement = document.activeElement\n  if (activeElement && activeElement.shadowRoot) {\n    activeElement = activeElement.shadowRoot.activeElement\n  }\n  if (isDOMHTMLElement(activeElement)) {\n    active = activeElement\n  }\n  const ranges: Range[] = []\n  for (var i = 0; i < selection.rangeCount; i++) {\n    ranges.push(selection.getRangeAt(i))\n  }\n  switch (\n    active?.tagName.toUpperCase() // .toUpperCase handles XHTML\n  ) {\n    case 'INPUT':\n    case 'TEXTAREA':\n      active.blur()\n      break\n\n    default:\n      active = null\n      break\n  }\n\n  selection.removeAllRanges()\n  return () => {\n    if (selection.type === 'Caret') {\n      selection.removeAllRanges()\n    }\n\n    if (!selection.rangeCount) {\n      ranges.forEach(range => {\n        selection.addRange(range)\n      })\n    }\n    if (active) {\n      active.focus()\n    }\n  }\n}\n\nexport const readClipboardDataByCommand = () => {\n  return new Promise<DataTransfer | null>((resolve, reject) => {\n    let textarea: HTMLTextAreaElement | null = null\n    let reselectPrevious: (() => void) | null = null\n\n    let selection: Selection | null = null\n    try {\n      reselectPrevious = deselectCurrent()\n\n      selection = document.getSelection()\n\n      textarea = document.createElement('textarea')\n      textarea.style.cssText = 'position: fixed; top: -9999; left: -9999; opacity: 0;'\n\n      textarea.addEventListener('paste', e => {\n        e.preventDefault()\n        e.stopPropagation()\n        resolve(e.clipboardData)\n      })\n\n      document.body.appendChild(textarea)\n\n      textarea.focus()\n\n      const successful = document.execCommand('paste')\n      if (!successful) throw new Error('paste failed')\n    } catch (error) {\n      reject(error)\n    } finally {\n      if (selection) {\n        selection.removeAllRanges()\n      }\n      if (textarea) document.body.removeChild(textarea)\n      if (reselectPrevious) reselectPrevious()\n    }\n  })\n}\n\nexport const readClipboardData = async () => {\n  let text = ''\n  let html = ''\n  let fragment = ''\n  const dataTransfer = new DataTransfer()\n  try {\n    const items = await navigator.clipboard.read()\n    for (const item of items) {\n      try {\n        text += await (await item.getType(TEXT_PLAIN)).text()\n      } catch {}\n      try {\n        html += await (await item.getType(TEXT_HTML)).text()\n      } catch {}\n      if (!fragment) {\n        try {\n          fragment = await (await item.getType(APPLICATION_FRAGMENT_TYPE)).text()\n        } catch (error) {\n          fragment = matchFragmentStringFromHTML(html)\n        }\n      }\n\n      for (const type of item.types) {\n        if (~[APPLICATION_FRAGMENT_TYPE, TEXT_PLAIN, TEXT_HTML].indexOf(type)) continue\n        const blob = await item.getType(type)\n        const file = new File([blob], 'unknow', {\n          type,\n        })\n        dataTransfer.items.add(file)\n      }\n    }\n  } catch (error) {\n    try {\n      const data = await readClipboardDataByCommand()\n      if (data) return data\n    } catch (error) {\n      console.error(error)\n    }\n  }\n  dataTransfer.setData(TEXT_PLAIN, text)\n  dataTransfer.setData(TEXT_HTML, html)\n  dataTransfer.setData(APPLICATION_FRAGMENT_TYPE, fragment)\n  return dataTransfer\n}\n\nexport const writeClipboardDataByCommand = (data: DataTransfer) => {\n  return new Promise<boolean>((resolve, reject) => {\n    let mark: HTMLElement | null = null\n    let reselectPrevious: (() => void) | null = null\n    let selection: Selection | null = null\n    let range: Range | null = null\n    try {\n      reselectPrevious = deselectCurrent()\n\n      range = document.createRange()\n      selection = document.getSelection()\n\n      mark = document.createElement('span')\n      mark.style.cssText = 'position: fixed; top: -9999;'\n      mark.ariaHidden = 'true'\n      mark.textContent = 'copy content'\n      mark.style.userSelect = 'text'\n      mark.addEventListener('copy', e => {\n        e.stopPropagation()\n        const { clipboardData } = e\n        if (clipboardData) {\n          e.preventDefault()\n          clipboardData.clearData()\n          clipboardData.setData(TEXT_PLAIN, data.getData(TEXT_PLAIN))\n          clipboardData.setData(TEXT_HTML, data.getData(TEXT_HTML))\n          clipboardData.setData(APPLICATION_FRAGMENT_TYPE, data.getData(APPLICATION_FRAGMENT_TYPE))\n          const files = parseDataTransferFiles(data)\n          for (const file of files) {\n            clipboardData.items.add(file)\n          }\n          resolve(true)\n        } else {\n          resolve(false)\n        }\n      })\n      document.body.appendChild(mark)\n\n      range.selectNodeContents(mark)\n      selection?.addRange(range)\n\n      const successful = document.execCommand('copy')\n      if (!successful) throw new Error('copy failed')\n    } catch (error) {\n      reject(error)\n    } finally {\n      if (selection) {\n        if (range && typeof selection.removeRange == 'function') {\n          selection.removeRange(range)\n        } else {\n          selection.removeAllRanges()\n        }\n      }\n      if (mark) document.body.removeChild(mark)\n      if (reselectPrevious) reselectPrevious()\n    }\n  })\n}\n\nexport const writeClipboardData = (data: DataTransfer) => {\n  try {\n    const files = parseDataTransferFiles(data)\n\n    navigator.clipboard.write([\n      new ClipboardItem({\n        [TEXT_PLAIN]: new Blob([data.getData(TEXT_PLAIN)], { type: TEXT_PLAIN }),\n        [TEXT_HTML]: new Blob([data.getData(TEXT_HTML)], { type: TEXT_HTML }),\n        // 当前不支持自定义类型\n        // https://github.com/w3c/editing/blob/gh-pages/docs/clipboard-pickling/explainer.md\n        // [APPLICATION_FRAGMENT_TYPE]: data.getData(APPLICATION_FRAGMENT_TYPE),\n        ...files.reduce((acc, file) => ({ ...acc, [file.type]: file }), {}),\n      }),\n    ])\n  } catch (error) {\n    try {\n      writeClipboardDataByCommand(data)\n    } catch (error) {\n      console.error(error)\n    }\n  }\n}\n"],"mappings":"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","names":["React","useStore","useStore","match","key","React","Editor","Range","Transforms","Point","Path","Element","isDOMNode","Editor","Range","Element","React","Editor","Node","Range","React","React","Editor","Path","Node","Editor","Node","Element","Path","Range","isDOMElement","React","rects","isDOMElement","rects","match","element","isDOMElement","node","range","lineRect","create","useStore","getStore","create","useStore","isFocused","create","useStore","EDITABLE_TO_FOCUSED_STORE","getStore","create","useStore","isReadOnly","Editor","match","Range","n","window","isDOMElement","node","nodes","Node","textNode","Element","block","Path","path","String","Path","Node","Editor","jsx","jsxs","React","React","useStore","create","useStore","jsx","Text","ranges","key","React","Editor","useStore","Editor","Range","create","create","Editor","Range","useStore","Editor","actives","jsx","Element","Editor","Node","children","Range","React","React","React","jsx","Element","Editor","Range","React","React","React","jsx","root","React","Range","React","useStore","create","Range","getStore","create","Range","useStore","rects","jsx","Range","Range","Fragment","jsx","Range","Range","React","useEffect","jsx","event","Range","rect","React","create","Editor","Element","Path","create","Editor","Path","Element","useStore","React","Editor","Element","Path","jsx","Editor","Element","Path","React","React","useStore","merge","create","getStore","predicate","React","useStore","Fragment","jsx","React","React","Range","Fragment","jsx","jsxs","Range","jsx","jsxs","Editor","Range","Transforms","Element","Path","isDOMNode","window","Point","React","Node","Editor","Scrubber","create","jsx","store","Node","Scrubber","Editor","create","React","Path","selection","Path","React","GridCell","Grid","GridCell","Grid","React","Grid","Grid","Editor","Node","Path","Transforms","Range","Point","Range","Editor","Editor","Range","CompositionText","Editor","Transforms","Range","Text","Editor","Transforms","Text","CompositionText","Range","Editor","Transforms","Node","Range","getDirection","create","key","getDirection","Node","Transforms","Editor","Range","Editor","Transforms","Node","Editor","Transforms","Range","Node","isDOMHTMLElement","error","Range","Editor","Node","Transforms","document","fragment","jsx","Range","Editor","Point","Transforms","Path","Node"]}
\ No newline at end of file
